{"version":3,"file":"unsplash-js.cjs.production.min.js","sources":["../src/helpers/typescript.ts","../src/helpers/fp.ts","../src/helpers/errors.ts","../src/methods/search/types/request.ts","../src/types/request.ts","../src/helpers/json.ts","../src/helpers/response.ts","../src/helpers/request.ts","../src/helpers/url.ts","../src/helpers/feed.ts","../src/helpers/query.ts","../src/methods/collections/index.ts","../src/methods/photos/index.ts","../src/methods/search/index.ts","../src/methods/users/index.ts","../src/methods/topics/index.ts","../src/beacon.ts","../src/index.ts"],"sourcesContent":["// Copied from https://github.com/Microsoft/TypeScript/issues/1897#issuecomment-338650717\nexport type AnyJson = boolean | number | string | null | JsonArray | JsonMap;\nexport type JsonMap = { [key: string]: AnyJson };\nexport type JsonArray = Array<AnyJson>;\n\nexport const checkIsString = getRefinement(\n  (value: unknown): Nullable<string> => (typeof value === 'string' ? value : null),\n);\n\n/**\n * https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-377567046\n */\nexport type OmitStrict<T, K extends keyof T> = Omit<T, K>;\n\n/**\n * Unlike TypeScript's `NonNullable`, this does _not_ include `undefined`\n */\nexport type Nullable<T> = T | null;\n\nexport const isDefined = <T>(x: T | null | undefined): x is T => x !== null && x !== undefined;\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\ntype Refinement<A, B extends A> = (a: A) => a is B;\nexport function getRefinement<A, B extends A>(getB: (a: A) => Nullable<B>): Refinement<A, B> {\n  return (a: A): a is B => isDefined(getB(a));\n}\n\nexport const checkIsNonEmptyArray = <T>(a: T[]): a is NonEmptyArray<T> => a.length > 0;\n","import { isDefined } from './typescript';\n\n/** Takes a dictionary containing nullish values and returns a dictionary of all the defined\n * (non-nullish) values.\n */\nexport const compactDefined = <A>(obj: Record<string, A | null | undefined>) =>\n  Object.keys(obj).reduce<Record<string, A>>((acc, key) => {\n    const value = obj[key];\n    return {\n      ...acc,\n      ...(isDefined(value) ? { [key]: value } : {}),\n    };\n  }, {});\n\n/**\n * copied from `fp-ts`\n * https://github.com/gcanti/fp-ts/blob/70190b5a03ddc2d31b4708c75c6dfad81d0bfa21/perf/function/flow.tÂ¡s\n */\nexport function flow<A extends Array<unknown>, B>(ab: (...a: A) => B): (...a: A) => B;\nexport function flow<A extends Array<unknown>, B, C>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n): (...a: A) => C;\nexport function flow<A extends Array<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (b: C) => D,\n): (...a: A) => D;\nexport function flow(...fns: Array<Function>): Function {\n  const len = fns.length - 1;\n  return function(this: any, ...x: Array<any>) {\n    let y = fns[0].apply(this, x);\n    for (let i = 1; i <= len; i++) {\n      y = fns[i].call(this, y);\n    }\n    return y;\n  };\n}\n","import {\n  AnyJson,\n  checkIsString,\n  getRefinement,\n  isDefined,\n  checkIsNonEmptyArray,\n  JsonMap,\n  NonEmptyArray,\n  Nullable,\n} from './typescript';\n\nexport type Errors = NonEmptyArray<string>;\nexport type ErrorSource = 'api' | 'decoding';\n\nconst checkIsObject = getRefinement(\n  (response: AnyJson): Nullable<JsonMap> =>\n    isDefined(response) && typeof response === 'object' && !Array.isArray(response)\n      ? response\n      : null,\n);\n\nconst checkIsErrors = getRefinement(\n  (errors: AnyJson): Nullable<Errors> =>\n    Array.isArray(errors) && errors.every(checkIsString) && checkIsNonEmptyArray(errors)\n      ? errors\n      : null,\n);\n\nconst checkIsApiError = getRefinement(\n  (response: AnyJson): Nullable<{ errors: Errors }> =>\n    checkIsObject(response) && 'errors' in response && checkIsErrors(response.errors)\n      ? { errors: response.errors }\n      : null,\n);\n\nexport const getErrorForBadStatusCode = (\n  jsonResponse: AnyJson,\n): { errors: Errors; source: ErrorSource } => {\n  if (checkIsApiError(jsonResponse)) {\n    return { errors: jsonResponse.errors, source: 'api' };\n  } else {\n    return {\n      errors: [\n        'Responded with a status code outside the 2xx range, and the response body is not recognisable.',\n      ],\n      source: 'decoding',\n    };\n  }\n};\n\nexport class DecodingError {\n  constructor(readonly message: string) {}\n}\n","export type SearchOrderBy = 'relevant' | 'latest' | 'editorial';\n\nexport type ColorId =\n  | 'white'\n  | 'black'\n  | 'yellow'\n  | 'orange'\n  | 'red'\n  | 'purple'\n  | 'magenta'\n  | 'green'\n  | 'teal'\n  | 'blue'\n  | 'black_and_white';\n\nexport type ContentFilter = 'high' | 'low';\n\nexport enum Language {\n  Afrikaans = 'af',\n  Amharic = 'am',\n  Arabic = 'ar',\n  Azerbaijani = 'az',\n  Belarusian = 'be',\n  Bulgarian = 'bg',\n  Bengali = 'bn',\n  Bosnian = 'bs',\n  Catalan = 'ca',\n  Cebuano = 'ceb',\n  Corsican = 'co',\n  Czech = 'cs',\n  Welsh = 'cy',\n  Danish = 'da',\n  German = 'de',\n  Greek = 'el',\n  English = 'en',\n  Esperanto = 'eo',\n  Spanish = 'es',\n  Estonian = 'et',\n  Basque = 'eu',\n  Persian = 'fa',\n  Finnish = 'fi',\n  French = 'fr',\n  Frisian = 'fy',\n  Irish = 'ga',\n  ScotsGaelic = 'gd',\n  Galician = 'gl',\n  Gujarati = 'gu',\n  Hausa = 'ha',\n  Hawaiian = 'haw',\n  Hindi = 'hi',\n  Hmong = 'hmn',\n  Croatian = 'hr',\n  HaitianCreole = 'ht',\n  Hungarian = 'hu',\n  Armenian = 'hy',\n  Indonesian = 'id',\n  Igbo = 'ig',\n  Icelandic = 'is',\n  Italian = 'it',\n  Hebrew = 'iw',\n  Japanese = 'ja',\n  Javanese = 'jw',\n  Georgian = 'ka',\n  Kazakh = 'kk',\n  Khmer = 'km',\n  Kannada = 'kn',\n  Korean = 'ko',\n  Kurdish = 'ku',\n  Kyrgyz = 'ky',\n  Latin = 'la',\n  Luxembourgish = 'lb',\n  Lao = 'lo',\n  Lithuanian = 'lt',\n  Latvian = 'lv',\n  Malagasy = 'mg',\n  Maori = 'mi',\n  Macedonian = 'mk',\n  Malayalam = 'ml',\n  Mongolian = 'mn',\n  Marathi = 'mr',\n  Malay = 'ms',\n  Maltese = 'mt',\n  Myanmar = 'my',\n  Nepali = 'ne',\n  Dutch = 'nl',\n  Norwegian = 'no',\n  Nyanja = 'ny',\n  Oriya = 'or',\n  Punjabi = 'pa',\n  Polish = 'pl',\n  Pashto = 'ps',\n  Portuguese = 'pt',\n  Romanian = 'ro',\n  Russian = 'ru',\n  Kinyarwanda = 'rw',\n  Sindhi = 'sd',\n  Sinhala = 'si',\n  Slovak = 'sk',\n  Slovenian = 'sl',\n  Samoan = 'sm',\n  Shona = 'sn',\n  Somali = 'so',\n  Albanian = 'sq',\n  Serbian = 'sr',\n  Sesotho = 'st',\n  Sundanese = 'su',\n  Swedish = 'sv',\n  Swahili = 'sw',\n  Tamil = 'ta',\n  Telugu = 'te',\n  Tajik = 'tg',\n  Thai = 'th',\n  Turkmen = 'tk',\n  Filipino = 'tl',\n  Turkish = 'tr',\n  Tatar = 'tt',\n  Uighur = 'ug',\n  Ukrainian = 'uk',\n  Urdu = 'ur',\n  Uzbek = 'uz',\n  Vietnamese = 'vi',\n  Xhosa = 'xh',\n  Yiddish = 'yi',\n  Yoruba = 'yo',\n  ChineseSimplified = 'zh',\n  ChineseTraditional = 'zh-TW',\n  Zulu = 'zu',\n}\n","export enum OrderBy {\n  LATEST = 'latest',\n  POPULAR = 'popular',\n  VIEWS = 'views',\n  DOWNLOADS = 'downloads',\n  OLDEST = 'oldest',\n}\nexport type Orientation = 'landscape' | 'portrait' | 'squarish';\nexport type OrientationParam = {\n  orientation?: Orientation;\n};\nexport type Plus = 'mixed' | 'only' | 'none';\n\nexport type PaginationParams = {\n  /**\n   * API defaults to `10` if no value is provided\n   */\n  perPage?: number;\n  /**\n   * API defaults to `1` if no value is provided\n   */\n  page?: number;\n  /**\n   * API defaults to `\"latest\"` if no value is provided\n   */\n  orderBy?: OrderBy;\n};\n","import * as ContentTypeHelpers from 'content-type';\nimport { DecodingError } from './errors';\nimport { AnyJson, isDefined } from './typescript';\n\nconst CONTENT_TYPE_RESPONSE_HEADER = 'content-type';\nconst CONTENT_TYPE_JSON = 'application/json';\nconst checkIsJsonResponse = (response: Response) => {\n  const contentTypeHeader = response.headers.get(CONTENT_TYPE_RESPONSE_HEADER);\n\n  return (\n    isDefined(contentTypeHeader) &&\n    ContentTypeHelpers.parse(contentTypeHeader).type === CONTENT_TYPE_JSON\n  );\n};\n\n/**\n * Note: restrict the type of JSON to `AnyJson` so that `any` doesn't leak downstream.\n */\nexport const getJsonResponse = (response: Response): Promise<AnyJson> => {\n  if (checkIsJsonResponse(response)) {\n    return response.json().catch(_err => {\n      throw new DecodingError('unable to parse JSON response.');\n    });\n  } else {\n    throw new DecodingError('expected JSON response from server.');\n  }\n};\n","import { Errors, ErrorSource, getErrorForBadStatusCode, DecodingError } from './errors';\nimport { getJsonResponse } from './json';\n\nexport type ApiResponse<T> =\n  | {\n      type: 'success';\n      response: T;\n      originalResponse: Response;\n      errors?: never;\n      status: number;\n    }\n  | {\n      type: 'error';\n      source: ErrorSource;\n      response?: never;\n      originalResponse: Response;\n      errors: Errors;\n      status: number;\n    };\n\nexport type HandleResponse<T> = (args: { response: Response }) => Promise<T>;\n\nexport const handleFetchResponse = <ResponseType>(handleResponse: HandleResponse<ResponseType>) => (\n  response: Response,\n): Promise<ApiResponse<ResponseType>> =>\n  (response.ok\n    ? handleResponse({ response }).then(\n        (handledResponse): ApiResponse<ResponseType> => ({\n          type: 'success',\n          status: response.status,\n          response: handledResponse,\n          originalResponse: response,\n        }),\n      )\n    : getJsonResponse(response).then(\n        (jsonResponse): ApiResponse<ResponseType> => ({\n          type: 'error',\n          status: response.status,\n          ...getErrorForBadStatusCode(jsonResponse),\n          originalResponse: response,\n        }),\n      )\n  ).catch(error => {\n    /**\n     * We want to separate expected decoding errors from unknown ones. We do so by throwing a custom\n     * `DecodingError` whenever we encounter one within `handleFetchResponse` and catch them all\n     * here. This allows us to easily handle all of these errors at once. Unexpected errors are not\n     * caught, so that they bubble up and fail loudly.\n     *\n     * Note: Ideally we'd use an Either type, but this does the job without introducing dependencies\n     * like `fp-ts`.\n     */\n    if (error instanceof DecodingError) {\n      return {\n        type: 'error',\n        source: 'decoding',\n        status: response.status,\n        originalResponse: response,\n        errors: [error.message],\n      };\n    } else {\n      throw error;\n    }\n  });\n\nexport const castResponse = <T>(): HandleResponse<T> => ({ response }) =>\n  (getJsonResponse(response) as unknown) as Promise<T>;\n","import { flow } from './fp';\nimport { ApiResponse, handleFetchResponse, HandleResponse } from './response';\nimport { isDefined, OmitStrict } from './typescript';\nimport { buildUrl, BuildUrlParams } from './url';\n\ntype FetchParams = Pick<RequestInit, 'method'>;\n/**\n * The params generated by the library\n */\ntype BaseRequestParams = BuildUrlParams &\n  FetchParams &\n  // `headers` is not part of FetchParams because we want to allow headers in the additional params as well\n  Pick<RequestInit, 'headers'>;\n\n/**\n * Additional fetch options provided by the user on a per-call basis\n */\nexport interface AdditionalFetchOptions extends OmitStrict<RequestInit, keyof FetchParams> {}\nexport type CompleteRequestParams = BaseRequestParams & AdditionalFetchOptions;\ntype HandleRequest<Args> = (\n  a: Args,\n  additionalFetchOptions?: AdditionalFetchOptions,\n) => CompleteRequestParams;\n\n/**\n * helper used to type-check the arguments, and add default params for all requests\n */\nexport const createRequestHandler = <Args>(\n  fn: (a: Args) => BaseRequestParams,\n): HandleRequest<Args> => (a, additionalFetchOptions = {}) => {\n  const { headers, query, ...baseReqParams } = fn(a);\n\n  return {\n    ...baseReqParams,\n    ...additionalFetchOptions,\n    query,\n    headers: {\n      ...headers,\n      ...additionalFetchOptions.headers,\n    },\n  };\n};\n\n/**\n * Initial parameters that apply to all calls\n */\nexport type InitParams = {\n  apiVersion?: string;\n  fetch?: typeof fetch;\n} & OmitStrict<RequestInit, 'method' | 'body'> &\n  ({ accessKey: string; apiUrl?: never } | { apiUrl: string; accessKey?: never });\n\ntype RequestGenerator<Args, ResponseType> = {\n  handleRequest: HandleRequest<Args>;\n  handleResponse: HandleResponse<ResponseType>;\n};\n\ntype Endpoint<PathnameParams, RequestArgs, ResponseType> = {\n  getPathname: (params: PathnameParams) => string;\n} & RequestGenerator<RequestArgs, ResponseType>;\nexport const makeEndpoint = <PathnameParams, RequestArgs, ResponseType>(\n  endpoint: Endpoint<PathnameParams, RequestArgs, ResponseType>,\n) => endpoint;\n\ntype GeneratedRequestFunction<Args, ResponseType> = (\n  ...a: Parameters<HandleRequest<Args>>\n) => Promise<ApiResponse<ResponseType>>;\n\ntype InitMakeRequest = (\n  args: InitParams,\n) => <Args, ResponseType>(\n  handlers: RequestGenerator<Args, ResponseType>,\n) => GeneratedRequestFunction<Args, ResponseType>;\n\nexport const initMakeRequest: InitMakeRequest = ({\n  accessKey,\n  apiVersion = 'v1',\n  apiUrl = 'https://api.unsplash.com',\n  headers: generalHeaders,\n  fetch: providedFetch,\n  ...generalFetchOptions\n}) => ({ handleResponse, handleRequest }) =>\n  flow(\n    handleRequest,\n    ({ pathname, query, method = 'GET', headers: endpointHeaders, body, signal }) => {\n      const url = buildUrl({ pathname, query })(apiUrl);\n\n      const fetchOptions: RequestInit = {\n        method,\n        headers: {\n          ...generalHeaders,\n          ...endpointHeaders,\n          'Accept-Version': apiVersion,\n          ...(isDefined(accessKey) ? { Authorization: `Client-ID ${accessKey}` } : {}),\n        },\n        body,\n        signal,\n        ...generalFetchOptions,\n      };\n\n      const fetchToUse = providedFetch ?? fetch;\n\n      return fetchToUse(url, fetchOptions).then(handleFetchResponse(handleResponse));\n    },\n  );\n","type Query = {\n  [index: string]: string | number | boolean;\n};\n\nexport type BuildUrlParams = {\n  pathname: string;\n  query: Query;\n};\n\nconst addQueryToUrl = (query: Query) => (url: URL) => {\n  Object.keys(query).forEach(queryKey =>\n    url.searchParams.set(queryKey, query[queryKey].toString()),\n  );\n};\n\nconst addPathnameToUrl = (pathname: string) => (url: URL) => {\n  // When there is no existing pathname, the value is `/`. Appending would give us a URL with two\n  // forward slashes. This is why we replace the value in that scenario.\n  if (url.pathname === '/') {\n    url.pathname = pathname;\n  } else {\n    url.pathname += pathname;\n  }\n};\n\nexport const buildUrl = ({ pathname, query }: BuildUrlParams) => (apiUrl: string) => {\n  const url = new URL(apiUrl);\n  addPathnameToUrl(pathname)(url);\n  addQueryToUrl(query)(url);\n  return url.toString();\n};\n\nconst getQueryFromSearchParams = (searchParams: URLSearchParams) => {\n  const query: Query = {};\n\n  searchParams.forEach((value, key) => {\n    query[key] = value;\n  });\n  return query;\n};\n\nexport const parseQueryAndPathname = (url: string) => {\n  const { pathname, searchParams } = new URL(url);\n\n  const query: Query = getQueryFromSearchParams(searchParams);\n\n  return { query, pathname: pathname === '/' ? undefined : pathname };\n};\n","import { DecodingError } from './errors';\nimport { HandleResponse, castResponse } from './response';\nimport { isDefined } from './typescript';\n\nconst TOTAL_RESPONSE_HEADER = 'x-total';\nconst getTotalFromApiFeedResponse = (response: Response) => {\n  const totalsStr = response.headers.get(TOTAL_RESPONSE_HEADER);\n  if (isDefined(totalsStr)) {\n    const total = parseInt(totalsStr);\n    if (Number.isInteger(total)) {\n      return total;\n    } else {\n      throw new DecodingError(`expected ${TOTAL_RESPONSE_HEADER} header to be valid integer.`);\n    }\n  } else {\n    throw new DecodingError(`expected ${TOTAL_RESPONSE_HEADER} header to exist.`);\n  }\n};\n\ntype FeedResponse<T> = {\n  results: T[];\n  total: number;\n};\n\nexport const handleFeedResponse = <T>(): HandleResponse<FeedResponse<T>> => ({ response }) =>\n  castResponse<T[]>()({ response }).then(results => ({\n    results,\n    total: getTotalFromApiFeedResponse(response),\n  }));\n","import { PaginationParams } from '../types/request';\nimport { compactDefined } from './fp';\nimport { isDefined } from './typescript';\n\nexport const getCollections = (collectionIds?: string[]) =>\n  isDefined(collectionIds) ? { collections: collectionIds.join() } : {};\n\nexport const getTopics = (topicIds?: string[]) =>\n  isDefined(topicIds) ? { topics: topicIds.join() } : {};\n\nexport const getFeedParams = ({ page, perPage, orderBy }: PaginationParams) =>\n  compactDefined({\n    per_page: perPage,\n    order_by: orderBy,\n    page,\n  });\n","import { handleFeedResponse } from '../../helpers/feed';\nimport { compactDefined } from '../../helpers/fp';\nimport * as Query from '../../helpers/query';\nimport { createRequestHandler, makeEndpoint } from '../../helpers/request';\nimport { castResponse } from '../../helpers/response';\nimport { OrientationParam, PaginationParams } from '../../types/request';\n\ntype CollectionId = {\n  collectionId: string;\n};\n\nconst COLLECTIONS_PATH_PREFIX = '/collections';\n\nexport const getPhotos = (() => {\n  const getPathname = ({ collectionId }: CollectionId) =>\n    `${COLLECTIONS_PATH_PREFIX}/${collectionId}/photos`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      ({\n        collectionId,\n        orientation,\n        ...paginationParams\n      }: CollectionId & PaginationParams & OrientationParam) => ({\n        pathname: getPathname({ collectionId }),\n        query: compactDefined({ ...Query.getFeedParams(paginationParams), orientation }),\n      }),\n    ),\n    handleResponse: handleFeedResponse<any>(),\n  });\n})();\n\nexport const get = (() => {\n  const getPathname = ({ collectionId }: CollectionId) =>\n    `${COLLECTIONS_PATH_PREFIX}/${collectionId}`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(({ collectionId }: CollectionId) => ({\n      pathname: getPathname({ collectionId }),\n      query: {},\n    })),\n    handleResponse: castResponse<any>(),\n  });\n})();\n\nexport const list = (() => {\n  const getPathname = () => COLLECTIONS_PATH_PREFIX;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      (paginationParams: Pick<PaginationParams, 'page' | 'perPage'> = {}) => ({\n        pathname: getPathname(),\n        query: Query.getFeedParams(paginationParams),\n      }),\n    ),\n    handleResponse: handleFeedResponse<any>(),\n  });\n})();\n\nexport const getRelated = (() => {\n  const getPathname = ({ collectionId }: CollectionId) =>\n    `${COLLECTIONS_PATH_PREFIX}/${collectionId}/related`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(({ collectionId }: CollectionId) => ({\n      pathname: getPathname({ collectionId }),\n      query: {},\n    })),\n    handleResponse: castResponse<any>(),\n  });\n})();\n","import { handleFeedResponse } from '../../helpers/feed';\nimport { compactDefined } from '../../helpers/fp';\nimport * as Query from '../../helpers/query';\nimport { createRequestHandler, makeEndpoint } from '../../helpers/request';\nimport { castResponse } from '../../helpers/response';\nimport { isDefined } from '../../helpers/typescript';\nimport { parseQueryAndPathname } from '../../helpers/url';\nimport { OrientationParam, PaginationParams } from '../../types/request';\nimport * as Photo from './types';\n\ntype PhotoId = {\n  photoId: string;\n};\n\nconst PHOTOS_PATH_PREFIX = '/photos';\n\nexport const list = (() => {\n  const getPathname = () => PHOTOS_PATH_PREFIX;\n  return makeEndpoint({\n    // Wrapper uses type trick to allow 0 args\n    getPathname: (_params?: void) => getPathname(),\n    handleRequest: createRequestHandler((feedParams: PaginationParams = {}) => ({\n      pathname: PHOTOS_PATH_PREFIX,\n      query: compactDefined(Query.getFeedParams(feedParams)),\n    })),\n    handleResponse: handleFeedResponse<Photo.Basic>(),\n  });\n})();\n\nexport const get = (() => {\n  const getPathname = ({ photoId }: PhotoId) => `${PHOTOS_PATH_PREFIX}/${photoId}`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(({ photoId }: PhotoId) => ({\n      pathname: getPathname({ photoId }),\n      query: {},\n    })),\n    handleResponse: castResponse<Photo.Full>(),\n  });\n})();\n\nexport const getStats = (() => {\n  const getPathname = ({ photoId }: PhotoId) => `${PHOTOS_PATH_PREFIX}/${photoId}/statistics`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(({ photoId }: PhotoId) => ({\n      pathname: getPathname({ photoId }),\n      query: {},\n    })),\n    handleResponse: castResponse<Photo.Stats>(),\n  });\n})();\n\nexport type RandomParams = {\n  collectionIds?: string[];\n  topicIds?: string[];\n  featured?: boolean;\n  username?: string;\n  query?: string;\n  contentFilter?: 'low' | 'high';\n  count?: number;\n} & OrientationParam;\n\nexport const getRandom = (() => {\n  const getPathname = () => `${PHOTOS_PATH_PREFIX}/random`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      ({ collectionIds, contentFilter, topicIds, ...queryParams }: RandomParams = {}) => ({\n        pathname: getPathname(),\n        query: compactDefined({\n          ...queryParams,\n          content_filter: contentFilter,\n          ...Query.getCollections(collectionIds),\n          ...Query.getTopics(topicIds),\n        }),\n        headers: {\n          /**\n           * Avoid response caching\n           */\n          'cache-control': 'no-cache',\n        },\n      }),\n    ),\n    handleResponse: castResponse<\n      // An array when the `count` query parameter is used.\n      Photo.Random | Photo.Random[]\n    >(),\n  });\n})();\n\nexport const trackDownload = {\n  handleRequest: createRequestHandler(({ downloadLocation }: { downloadLocation: string }) => {\n    const { pathname, query } = parseQueryAndPathname(downloadLocation);\n\n    if (!isDefined(pathname)) {\n      throw new Error('Could not parse pathname from url.');\n    }\n    return { pathname, query: compactDefined(query) };\n  }),\n  handleResponse: castResponse<{ url: string }>(),\n};\n","import { compactDefined } from '../../helpers/fp';\nimport * as Query from '../../helpers/query';\nimport { createRequestHandler, makeEndpoint } from '../../helpers/request';\nimport { castResponse } from '../../helpers/response';\nimport { OrientationParam, PaginationParams, Plus } from '../../types/request';\nimport { ColorId, ContentFilter, Language, SearchOrderBy } from './types/request';\nimport * as SearchResponse from './types/response';\n\nexport type SearchParams = {\n  query: string;\n} & Pick<PaginationParams, 'page' | 'perPage'>;\n\nconst SEARCH_PATH_PREFIX = `/search`;\n\ntype SearchPhotosParams = SearchParams &\n  OrientationParam & {\n    /**\n     * API defaults to `\"relevant\"` if no value is provided\n     */\n    orderBy?: SearchOrderBy;\n    color?: ColorId;\n    plus?: Plus;\n    /**\n     * API defaults to `en` (English) if no value is provided\n     */\n    lang?: Language;\n    /**\n     * API defaults to `\"low\"` if no value is provided\n     */\n    contentFilter?: ContentFilter;\n    collectionIds?: string[];\n  };\n\nexport const getPhotos = (() => {\n  const getPathname = () => `${SEARCH_PATH_PREFIX}/photos`;\n  return makeEndpoint({\n    // Wrapper uses type trick to allow 0 args\n    getPathname: (_params?: void) => getPathname(),\n    handleRequest: createRequestHandler(\n      ({\n        query,\n        page,\n        perPage,\n        orderBy,\n        collectionIds,\n        lang,\n        contentFilter,\n        ...filters\n      }: SearchPhotosParams) => ({\n        pathname: getPathname(),\n        query: compactDefined({\n          query,\n          content_filter: contentFilter,\n          lang,\n          order_by: orderBy,\n          ...Query.getFeedParams({ page, perPage }),\n          ...Query.getCollections(collectionIds),\n          ...filters,\n        }),\n      }),\n    ),\n    handleResponse: castResponse<SearchResponse.Photos>(),\n  });\n})();\n\nexport const getCollections = (() => {\n  const getPathname = () => `${SEARCH_PATH_PREFIX}/collections`;\n  return makeEndpoint({\n    // Wrapper uses type trick to allow 0 args\n    getPathname: (_params?: void) => getPathname(),\n    handleRequest: createRequestHandler(({ query, ...paginationParams }: SearchParams) => ({\n      pathname: getPathname(),\n      query: { query, ...Query.getFeedParams(paginationParams) },\n    })),\n    handleResponse: castResponse<SearchResponse.Collections>(),\n  });\n})();\n\nexport const getUsers = (() => {\n  const getPathname = () => `${SEARCH_PATH_PREFIX}/users`;\n  return makeEndpoint({\n    // Wrapper uses type trick to allow 0 args\n    getPathname: (_params?: void) => getPathname(),\n    handleRequest: createRequestHandler(({ query, ...paginationParams }: SearchParams) => ({\n      pathname: getPathname(),\n      query: { query, ...Query.getFeedParams(paginationParams) },\n    })),\n    handleResponse: castResponse<SearchResponse.Users>(),\n  });\n})();\n","import { handleFeedResponse } from '../../helpers/feed';\nimport { compactDefined } from '../../helpers/fp';\nimport * as Query from '../../helpers/query';\nimport { createRequestHandler, makeEndpoint } from '../../helpers/request';\nimport { castResponse } from '../../helpers/response';\nimport { OrientationParam, PaginationParams } from '../../types/request';\nimport * as User from './types';\nimport * as Photo from '../photos/types';\nimport * as Collection from '../collections/types';\n\ntype Username = {\n  username: string;\n};\n\nconst USERS_PATH_PREFIX = '/users';\n\nexport const get = (() => {\n  const getPathname = ({ username }: Username) => `${USERS_PATH_PREFIX}/${username}`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(({ username }: Username) => ({\n      pathname: getPathname({ username }),\n      query: {},\n    })),\n    handleResponse: castResponse<User.Full>(),\n  });\n})();\n\nexport const getPhotos = (() => {\n  const getPathname = ({ username }: Username) => `${USERS_PATH_PREFIX}/${username}/photos`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      ({\n        username,\n        stats,\n        orientation,\n        ...paginationParams\n      }: {\n        stats?: boolean;\n      } & OrientationParam &\n        Username &\n        PaginationParams) => ({\n        pathname: getPathname({ username }),\n        query: compactDefined({\n          ...Query.getFeedParams(paginationParams),\n          orientation,\n          stats,\n        }),\n      }),\n    ),\n    handleResponse: handleFeedResponse<Photo.Basic>(),\n  });\n})();\n\nexport const getLikes = (() => {\n  const getPathname = ({ username }: Username) => `${USERS_PATH_PREFIX}/${username}/likes`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      ({\n        username,\n        orientation,\n        ...paginationParams\n      }: OrientationParam & Username & PaginationParams) => ({\n        pathname: getPathname({ username }),\n        query: compactDefined({\n          ...Query.getFeedParams(paginationParams),\n          orientation,\n        }),\n      }),\n    ),\n    handleResponse: handleFeedResponse<Photo.Basic>(),\n  });\n})();\nexport const getCollections = (() => {\n  const getPathname = ({ username }: Username) => `${USERS_PATH_PREFIX}/${username}/collections`;\n  return makeEndpoint({\n    getPathname,\n    handleRequest: createRequestHandler(\n      ({ username, ...paginationParams }: Username & PaginationParams) => ({\n        pathname: getPathname({ username }),\n        query: Query.getFeedParams(paginationParams),\n      }),\n    ),\n    handleResponse: handleFeedResponse<Collection.Basic>(),\n  });\n})();\n","import { handleFeedResponse } from '../../helpers/feed';\nimport { compactDefined, flow } from '../../helpers/fp';\nimport * as Query from '../../helpers/query';\nimport { makeEndpoint } from '../../helpers/request';\nimport { castResponse } from '../../helpers/response';\nimport { OmitStrict } from '../../helpers/typescript';\nimport { OrientationParam, PaginationParams } from '../../types/request';\nimport * as Photo from '../photos/types';\nimport * as Topic from './types';\n\nexport type TopicIdOrSlug = {\n  topicIdOrSlug: string;\n};\n\nconst BASE_TOPIC_PATH = '/topics';\nconst getTopicPath = ({ topicIdOrSlug }: TopicIdOrSlug) => `${BASE_TOPIC_PATH}/${topicIdOrSlug}`;\n\nexport type TopicOrderBy = 'latest' | 'oldest' | 'position' | 'featured';\n\nexport const list = makeEndpoint({\n  getPathname: getTopicPath,\n  handleRequest: ({\n    page,\n    perPage,\n    orderBy,\n    topicIdsOrSlugs,\n  }: OmitStrict<PaginationParams, 'orderBy'> & {\n    /**\n     * default: `position`\n     */\n    orderBy?: TopicOrderBy;\n    topicIdsOrSlugs?: string[];\n  }) => ({\n    pathname: BASE_TOPIC_PATH,\n    query: compactDefined({\n      ...Query.getFeedParams({ page, perPage }),\n      ids: topicIdsOrSlugs?.join(','),\n      order_by: orderBy,\n    }),\n  }),\n  handleResponse: handleFeedResponse<Topic.Basic>(),\n});\n\nexport const get = makeEndpoint({\n  getPathname: getTopicPath,\n  handleRequest: ({ topicIdOrSlug }: TopicIdOrSlug) => ({\n    pathname: getTopicPath({ topicIdOrSlug }),\n    query: {},\n  }),\n  handleResponse: castResponse<Topic.Full>(),\n});\n\nexport const getPhotos = (() => {\n  const getPathname = flow(getTopicPath, topicPath => `${topicPath}/photos`);\n  return makeEndpoint({\n    getPathname,\n    handleRequest: ({\n      topicIdOrSlug,\n      orientation,\n      ...feedParams\n    }: TopicIdOrSlug & PaginationParams & OrientationParam) => ({\n      pathname: getPathname({ topicIdOrSlug }),\n      query: compactDefined({\n        ...Query.getFeedParams(feedParams),\n        orientation,\n      }),\n    }),\n    handleResponse: handleFeedResponse<Photo.Basic>(),\n  });\n})();\n","export const trackNonHotLinkedPhotoView = ({ appId }: { appId: string }) => ({\n  photoId,\n}: {\n  photoId: string | string[];\n}) => {\n  const ids = !Array.isArray(photoId) ? [photoId] : photoId;\n\n  if (ids.length > 20) {\n    throw new Error(\n      'You cannot track more than 20 photos at once. Please try again with fewer photos.',\n    );\n  }\n\n  return fetch(`views.unsplash.com/v?photo_id=${ids.join()}&app_id=${appId}`);\n};\n","import { flow } from './helpers/fp';\nimport { initMakeRequest } from './helpers/request';\nimport * as collections from './methods/collections';\nimport * as photos from './methods/photos';\nimport * as search from './methods/search';\nimport * as users from './methods/users';\nimport * as topics from './methods/topics';\n\nimport * as _internals from './internals';\n\nexport const createApi = flow(initMakeRequest, makeRequest => ({\n  photos: {\n    get: makeRequest(photos.get),\n    list: makeRequest(photos.list),\n    getStats: makeRequest(photos.getStats),\n    getRandom: makeRequest(photos.getRandom),\n    trackDownload: makeRequest(photos.trackDownload),\n  },\n  users: {\n    getPhotos: makeRequest(users.getPhotos),\n    getCollections: makeRequest(users.getCollections),\n    getLikes: makeRequest(users.getLikes),\n    get: makeRequest(users.get),\n  },\n  search: {\n    getCollections: makeRequest(search.getCollections),\n    getPhotos: makeRequest(search.getPhotos),\n    getUsers: makeRequest(search.getUsers),\n  },\n  collections: {\n    getPhotos: makeRequest(collections.getPhotos),\n    get: makeRequest(collections.get),\n    list: makeRequest(collections.list),\n    getRelated: makeRequest(collections.getRelated),\n  },\n  topics: {\n    list: makeRequest(topics.list),\n    get: makeRequest(topics.get),\n    getPhotos: makeRequest(topics.getPhotos),\n  },\n}));\n\nexport { Language, ColorId, ContentFilter, SearchOrderBy } from './methods/search/types/request';\nexport { OrderBy, Orientation, Plus } from './types/request';\nexport { _internals };\n"],"names":["checkIsString","getRefinement","value","isDefined","x","getB","a","compactDefined","obj","Object","keys","reduce","acc","key","flow","fns","len","length","y","apply","this","i","call","Language","OrderBy","checkIsObject","response","Array","isArray","checkIsErrors","errors","every","checkIsApiError","DecodingError","message","getJsonResponse","contentTypeHeader","headers","get","ContentTypeHelpers","type","checkIsJsonResponse","json","_err","castResponse","createRequestHandler","fn","additionalFetchOptions","query","makeEndpoint","endpoint","initMakeRequest","accessKey","apiVersion","apiUrl","generalHeaders","providedFetch","fetch","generalFetchOptions","handleResponse","handleRequest","method","endpointHeaders","body","signal","url","pathname","URL","addPathnameToUrl","forEach","queryKey","searchParams","set","toString","addQueryToUrl","buildUrl","fetchOptions","Authorization","then","ok","handledResponse","status","originalResponse","jsonResponse","source","getErrorForBadStatusCode","error","handleFetchResponse","getTotalFromApiFeedResponse","totalsStr","total","parseInt","Number","isInteger","handleFeedResponse","results","getCollections","collectionIds","collections","join","getTopics","topicIds","topics","getFeedParams","per_page","perPage","order_by","orderBy","page","getPhotos","getPathname","COLLECTIONS_PATH_PREFIX","collectionId","orientation","paginationParams","Query","list","getRelated","_params","feedParams","PHOTOS_PATH_PREFIX","photoId","getStats","getRandom","contentFilter","queryParams","content_filter","trackDownload","getQueryFromSearchParams","undefined","parseQueryAndPathname","downloadLocation","Error","SEARCH_PATH_PREFIX","lang","filters","getUsers","USERS_PATH_PREFIX","username","stats","getLikes","getTopicPath","BASE_TOPIC_PATH","topicIdOrSlug","topicIdsOrSlugs","ids","topicPath","appId","createApi","makeRequest","photos","users","search"],"mappings":"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"}