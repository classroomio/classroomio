var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { window } from '../../utils/globals';
import { errorToProperties, unhandledRejectionToProperties } from './error-conversion';
import { isPrimitive } from './type-checking';
import { _isArray, _isObject, _isUndefined } from '../../utils/type-utils';
import { logger } from '../../utils/logger';
var EXCEPTION_INGESTION_ENDPOINT = '/e/';
export var extendPostHog = function (instance, response) {
    var exceptionObserver = new ExceptionObserver(instance);
    exceptionObserver.afterDecideResponse(response);
    return exceptionObserver;
};
var ExceptionObserver = /** @class */ (function () {
    function ExceptionObserver(instance) {
        this.originalOnErrorHandler = undefined;
        this.originalOnUnhandledRejectionHandler = undefined;
        this.errorsToIgnore = [];
        this.instance = instance;
    }
    ExceptionObserver.prototype.startCapturing = function () {
        var _a;
        if (!window || !this.isEnabled() || ((_a = window.onerror) === null || _a === void 0 ? void 0 : _a.__POSTHOG_INSTRUMENTED__)) {
            return;
        }
        try {
            this.originalOnErrorHandler = window.onerror;
            window.onerror = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                this.captureException(args);
                if (this.originalOnErrorHandler) {
                    // eslint-disable-next-line prefer-rest-params
                    return this.originalOnErrorHandler.apply(this, args);
                }
                return false;
            }.bind(this);
            window.onerror.__POSTHOG_INSTRUMENTED__ = true;
            this.originalOnUnhandledRejectionHandler = window.onunhandledrejection;
            window.onunhandledrejection = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var errorProperties = unhandledRejectionToProperties(args);
                this.sendExceptionEvent(errorProperties);
                if (window && this.originalOnUnhandledRejectionHandler) {
                    // eslint-disable-next-line prefer-rest-params
                    return this.originalOnUnhandledRejectionHandler.apply(window, args);
                }
                return true;
            }.bind(this);
            window.onunhandledrejection.__POSTHOG_INSTRUMENTED__ = true;
        }
        catch (e) {
            logger.error('PostHog failed to start exception autocapture', e);
            this.stopCapturing();
        }
    };
    ExceptionObserver.prototype.stopCapturing = function () {
        var _a, _b;
        if (!window) {
            return;
        }
        if (!_isUndefined(this.originalOnErrorHandler)) {
            window.onerror = this.originalOnErrorHandler;
            this.originalOnErrorHandler = null;
        }
        (_a = window.onerror) === null || _a === void 0 ? true : delete _a.__POSTHOG_INSTRUMENTED__;
        if (!_isUndefined(this.originalOnUnhandledRejectionHandler)) {
            window.onunhandledrejection = this.originalOnUnhandledRejectionHandler;
            this.originalOnUnhandledRejectionHandler = null;
        }
        (_b = window.onunhandledrejection) === null || _b === void 0 ? true : delete _b.__POSTHOG_INSTRUMENTED__;
    };
    ExceptionObserver.prototype.isCapturing = function () {
        var _a;
        return !!((_a = window === null || window === void 0 ? void 0 : window.onerror) === null || _a === void 0 ? void 0 : _a.__POSTHOG_INSTRUMENTED__);
    };
    ExceptionObserver.prototype.isEnabled = function () {
        var _a;
        return (_a = this.remoteEnabled) !== null && _a !== void 0 ? _a : false;
    };
    ExceptionObserver.prototype.afterDecideResponse = function (response) {
        var autocaptureExceptionsResponse = response.autocaptureExceptions;
        this.remoteEnabled = !!autocaptureExceptionsResponse || false;
        if (!isPrimitive(autocaptureExceptionsResponse) &&
            'errors_to_ignore' in autocaptureExceptionsResponse &&
            _isArray(autocaptureExceptionsResponse.errors_to_ignore)) {
            var dropRules = autocaptureExceptionsResponse.errors_to_ignore;
            this.errorsToIgnore = dropRules.map(function (rule) {
                return new RegExp(rule);
            });
        }
        if (this.isEnabled()) {
            this.startCapturing();
            logger.info('[Exception Capture] Remote config for exception autocapture is enabled, starting with config: ', _isObject(autocaptureExceptionsResponse) ? autocaptureExceptionsResponse : {});
        }
    };
    ExceptionObserver.prototype.captureException = function (args, properties) {
        var errorProperties = errorToProperties(args);
        if (this.errorsToIgnore.some(function (regex) { return regex.test(errorProperties.$exception_message || ''); })) {
            logger.info('[Exception Capture] Ignoring exception based on remote config', errorProperties);
            return;
        }
        var propertiesToSend = __assign(__assign({}, properties), errorProperties);
        var posthogHost = this.instance.config.ui_host || this.instance.config.api_host;
        errorProperties.$exception_personURL = posthogHost + '/person/' + this.instance.get_distinct_id();
        this.sendExceptionEvent(propertiesToSend);
    };
    /**
     * :TRICKY: Make sure we batch these requests
     */
    ExceptionObserver.prototype.sendExceptionEvent = function (properties) {
        this.instance.capture('$exception', properties, {
            transport: 'XHR',
            method: 'POST',
            endpoint: EXCEPTION_INGESTION_ENDPOINT,
            _noTruncate: true,
            _batchKey: 'exceptionEvent',
        });
    };
    return ExceptionObserver;
}());
export { ExceptionObserver };
//# sourceMappingURL=index.js.map