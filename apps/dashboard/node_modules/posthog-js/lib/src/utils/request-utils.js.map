{"version":3,"file":"request-utils.js","sourceRoot":"","sources":["../../../src/utils/request-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { _each, _isValidRegex } from './'\n\nimport { _isArray, _isUndefined } from './type-utils'\nimport { logger } from './logger'\nimport { document } from './globals'\n\nconst localDomains = ['localhost', '127.0.0.1']\n\n/**\n * IE11 doesn't support `new URL`\n * so we can create an anchor element and use that to parse the URL\n * there's a lot of overlap between HTMLHyperlinkElementUtils and URL\n * meaning useful properties like `pathname` are available on both\n */\nexport const convertToURL = (url: string): HTMLAnchorElement | null => {\n    const location = document?.createElement('a')\n    if (_isUndefined(location)) {\n        return null\n    }\n\n    location.href = url\n    return location\n}\n\nexport const _isUrlMatchingRegex = function (url: string, pattern: string): boolean {\n    if (!_isValidRegex(pattern)) return false\n    return new RegExp(pattern).test(url)\n}\n\nexport const _HTTPBuildQuery = function (formdata: Record<string, any>, arg_separator = '&'): string {\n    let use_val: string\n    let use_key: string\n    const tph_arr: string[] = []\n\n    _each(formdata, function (val, key) {\n        // the key might be literally the string undefined for e.g. if {undefined: 'something'}\n        if (_isUndefined(val) || _isUndefined(key) || key === 'undefined') {\n            return\n        }\n\n        use_val = encodeURIComponent(val.toString())\n        use_key = encodeURIComponent(key)\n        tph_arr[tph_arr.length] = use_key + '=' + use_val\n    })\n\n    return tph_arr.join(arg_separator)\n}\n\nexport const _getQueryParam = function (url: string, param: string): string {\n    const withoutHash: string = url.split('#')[0] || ''\n    const queryParams: string = withoutHash.split('?')[1] || ''\n\n    const queryParts = queryParams.split('&')\n    let keyValuePair\n\n    for (let i = 0; i < queryParts.length; i++) {\n        const parts = queryParts[i].split('=')\n        if (parts[0] === param) {\n            keyValuePair = parts\n            break\n        }\n    }\n\n    if (!_isArray(keyValuePair) || keyValuePair.length < 2) {\n        return ''\n    } else {\n        let result = keyValuePair[1]\n        try {\n            result = decodeURIComponent(result)\n        } catch (err) {\n            logger.error('Skipping decoding for malformed query param: ' + result)\n        }\n        return result.replace(/\\+/g, ' ')\n    }\n}\n\nexport const _getHashParam = function (hash: string, param: string): string | null {\n    const matches = hash.match(new RegExp(param + '=([^&]*)'))\n    return matches ? matches[1] : null\n}\n\nexport const isLocalhost = (): boolean => {\n    return localDomains.includes(location.hostname)\n}\n"]}