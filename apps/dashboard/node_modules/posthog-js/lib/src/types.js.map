{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAuLA,MAAM,CAAN,IAAY,WAGX;AAHD,WAAY,WAAW;IACnB,iCAAkB,CAAA;IAClB,gCAAiB,CAAA;AACrB,CAAC,EAHW,WAAW,KAAX,WAAW,QAGtB","sourcesContent":["import type { MaskInputOptions, SlimDOMOptions } from 'rrweb-snapshot'\nimport { PostHog } from './posthog-core'\nimport { RetryQueue } from './retry-queue'\n\nexport type Property = any\nexport type Properties = Record<string, Property>\n\nexport interface CaptureResult {\n    uuid: string\n    event: string\n    properties: Properties\n    $set?: Properties\n    $set_once?: Properties\n    timestamp?: Date\n}\nexport type CaptureCallback = (response: any, data: any) => void\n\nexport type AutocaptureCompatibleElement = 'a' | 'button' | 'form' | 'input' | 'select' | 'textarea' | 'label'\nexport type DomAutocaptureEvents = 'click' | 'change' | 'submit'\n\n/**\n * If an array is passed for an allowlist, autocapture events will only be sent for elements matching\n * at least one of the elements in the array. Multiple allowlists can be used\n */\nexport interface AutocaptureConfig {\n    /**\n     * List of URLs to allow autocapture on, can be strings to match\n     * or regexes e.g. ['https://example.com', 'test.com/.*']\n     */\n    url_allowlist?: (string | RegExp)[]\n\n    /**\n     * List of DOM events to allow autocapture on  e.g. ['click', 'change', 'submit']\n     */\n    dom_event_allowlist?: DomAutocaptureEvents[]\n\n    /**\n     * List of DOM elements to allow autocapture on\n     * e.g. ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n     */\n    element_allowlist?: AutocaptureCompatibleElement[]\n\n    /**\n     * List of CSS selectors to allow autocapture on\n     * e.g. ['[ph-capture]']\n     */\n    css_selector_allowlist?: string[]\n\n    /**\n     * Exclude certain element attributes from autocapture\n     * E.g. ['aria-label'] or [data-attr-pii]\n     */\n    element_attribute_ignorelist?: string[]\n}\n\nexport type UUIDVersion = 'og' | 'v7'\n\nexport interface PostHogConfig {\n    api_host: string\n    api_method: string\n    api_transport: string\n    ui_host: string | null\n    token: string\n    autocapture: boolean | AutocaptureConfig\n    rageclick: boolean\n    cross_subdomain_cookie: boolean\n    persistence: 'localStorage' | 'cookie' | 'memory' | 'localStorage+cookie' | 'sessionStorage'\n    persistence_name: string\n    cookie_name: string\n    loaded: (posthog_instance: PostHog) => void\n    store_google: boolean\n    custom_campaign_params: string[]\n    // a list of strings to be tested against navigator.userAgent to determine if the source is a bot\n    // this is **added to** the default list of bots that we check\n    // defaults to the empty array\n    custom_blocked_useragents: string[]\n    save_referrer: boolean\n    verbose: boolean\n    capture_pageview: boolean\n    capture_pageleave: boolean\n    debug: boolean\n    cookie_expiration: number\n    upgrade: boolean\n    disable_session_recording: boolean\n    disable_persistence: boolean\n    /** @deprecated - use `disable_persistence` instead  */\n    disable_cookie: boolean\n    enable_recording_console_log?: boolean\n    secure_cookie: boolean\n    ip: boolean\n    opt_out_capturing_by_default: boolean\n    opt_out_persistence_by_default: boolean\n    opt_out_capturing_persistence_type: 'localStorage' | 'cookie'\n    opt_out_capturing_cookie_prefix: string | null\n    opt_in_site_apps: boolean\n    respect_dnt: boolean\n    property_blacklist: string[]\n    xhr_headers: { [header_name: string]: string }\n    on_xhr_error: (failedRequest: XMLHttpRequest) => void\n    inapp_protocol: string\n    inapp_link_new_window: boolean\n    request_batching: boolean\n    sanitize_properties: ((properties: Properties, event_name: string) => Properties) | null\n    properties_string_max_length: number\n    session_recording: SessionRecordingOptions\n    session_idle_timeout_seconds: number\n    mask_all_element_attributes: boolean\n    mask_all_text: boolean\n    advanced_disable_decide: boolean\n    advanced_disable_feature_flags: boolean\n    advanced_disable_feature_flags_on_first_load: boolean\n    advanced_disable_toolbar_metrics: boolean\n    get_device_id: (uuid: string) => string\n    name: string\n    callback_fn: string\n    _onCapture: (eventName: string, eventData: CaptureResult) => void\n    capture_performance?: boolean\n    // Should only be used for testing. Could negatively impact performance.\n    disable_compression: boolean\n    bootstrap: {\n        distinctID?: string\n        isIdentifiedID?: boolean\n        featureFlags?: Record<string, boolean | string>\n        featureFlagPayloads?: Record<string, JsonType>\n    }\n    segment?: any\n    __preview_measure_pageview_stats?: boolean\n    __preview_send_client_session_params?: boolean\n}\n\nexport interface OptInOutCapturingOptions {\n    capture: (event: string, properties: Properties, options: CaptureOptions) => void\n    capture_event_name: string\n    capture_properties: Properties\n    enable_persistence: boolean\n    clear_persistence: boolean\n    persistence_type: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    cookie_prefix: string\n    cookie_expiration: number\n    cross_subdomain_cookie: boolean\n    secure_cookie: boolean\n}\n\nexport interface isFeatureEnabledOptions {\n    send_event: boolean\n}\n\nexport interface SessionRecordingOptions {\n    blockClass?: string | RegExp\n    blockSelector?: string | null\n    ignoreClass?: string\n    maskTextClass?: string | RegExp\n    maskTextSelector?: string | null\n    maskTextFn?: ((text: string) => string) | null\n    maskAllInputs?: boolean\n    maskInputOptions?: MaskInputOptions\n    maskInputFn?: ((text: string, element?: HTMLElement) => string) | null\n    slimDOMOptions?: SlimDOMOptions | 'all' | true\n    collectFonts?: boolean\n    inlineStylesheet?: boolean\n    recorderVersion?: 'v1' | 'v2'\n    recordCrossOriginIframes?: boolean\n    /** @deprecated - use maskCapturedNetworkRequestFn instead  */\n    maskNetworkRequestFn?: ((data: NetworkRequest) => NetworkRequest | null | undefined) | null\n    /** Modify the network request before it is captured. Returning null or undefined stops it being captured */\n    maskCapturedNetworkRequestFn?: ((data: CapturedNetworkRequest) => CapturedNetworkRequest | null | undefined) | null\n    // properties below here are ALPHA, don't rely on them, they may change without notice\n    // TODO which of these do we actually expose?\n    // if this isn't provided a default will be used\n    // this only applies to the payload recorder\n    // TODO I guess it should apply to the other recorder to\n    initiatorTypes?: InitiatorType[]\n    recordHeaders?: boolean | { request: boolean; response: boolean }\n    // true means record all bodies\n    // false means record no bodies\n    // string[] means record bodies matching the provided content-type headers\n    recordBody?: boolean | string[] | { request: boolean | string[]; response: boolean | string[] }\n    // I can't think why you wouldn't want this... so\n    // recordInitialRequests?: boolean\n}\n\nexport type SessionIdChangedCallback = (sessionId: string, windowId: string | null | undefined) => void\n\nexport enum Compression {\n    GZipJS = 'gzip-js',\n    Base64 = 'base64',\n}\n\nexport interface XHROptions {\n    transport?: 'XHR' | 'sendBeacon'\n    method?: 'POST' | 'GET'\n    urlQueryArgs?: { compression: Compression }\n    verbose?: boolean\n    blob?: boolean\n    sendBeacon?: boolean\n}\n\nexport interface CaptureOptions extends XHROptions {\n    $set?: Properties /** used with $identify */\n    $set_once?: Properties /** used with $identify */\n    _batchKey?: string /** key of queue, e.g. 'sessionRecording' vs 'event' */\n    _metrics?: Properties\n    _noTruncate?: boolean /** if set, overrides and disables config.properties_string_max_length */\n    endpoint?: string /** defaults to '/e/' */\n    send_instantly?: boolean /** if set skips the batched queue */\n    timestamp?: Date\n}\n\nexport interface RetryQueueElement {\n    retryAt: Date\n    requestData: QueuedRequestData\n}\nexport interface QueuedRequestData {\n    url: string\n    data: Properties\n    options: CaptureOptions\n    headers?: Properties\n    callback?: RequestCallback\n    retriesPerformedSoFar?: number\n}\n\nexport interface XHRParams extends QueuedRequestData {\n    retryQueue: RetryQueue\n    onXHRError: (req: XMLHttpRequest) => void\n    timeout?: number\n    onResponse?: (req: XMLHttpRequest) => void\n}\n\nexport interface DecideResponse {\n    status: number\n    supportedCompression: Compression[]\n    config: {\n        enable_collect_everything: boolean\n    }\n    custom_properties: AutoCaptureCustomProperty[] // TODO: delete, not sent\n    featureFlags: Record<string, string | boolean>\n    featureFlagPayloads: Record<string, JsonType>\n    errorsWhileComputingFlags: boolean\n    autocapture_opt_out?: boolean\n    capturePerformance?: boolean\n    analytics?: {\n        endpoint?: string\n    }\n    elementsChainAsString?: boolean\n    // this is currently in development and may have breaking changes without a major version bump\n    autocaptureExceptions?:\n        | boolean\n        | {\n              endpoint?: string\n              errors_to_ignore: string[]\n          }\n    sessionRecording?: {\n        endpoint?: string\n        consoleLogRecordingEnabled?: boolean\n        recorderVersion?: 'v1' | 'v2'\n        // the API returns a decimal between 0 and 1 as a string\n        sampleRate?: string | null\n        minimumDurationMilliseconds?: number\n        linkedFlag?: string | null\n        networkPayloadCapture?: Pick<NetworkRecordOptions, 'recordBody' | 'recordHeaders'>\n    }\n    surveys?: boolean\n    toolbarParams: ToolbarParams\n    editorParams?: ToolbarParams /** @deprecated, renamed to toolbarParams, still present on older API responses */\n    toolbarVersion: 'toolbar' /** @deprecated, moved to toolbarParams */\n    isAuthenticated: boolean\n    siteApps: { id: number; url: string }[]\n}\n\nexport type FeatureFlagsCallback = (flags: string[], variants: Record<string, string | boolean>) => void\n\n// TODO: delete custom_properties after changeless typescript refactor\nexport interface AutoCaptureCustomProperty {\n    name: string\n    css_selector: string\n    event_selectors: string[]\n}\n\nexport interface CompressionData {\n    data: string\n    compression?: Compression\n}\n\nexport interface GDPROptions {\n    capture?: (\n        event: string,\n        properties: Properties,\n        options: CaptureOptions\n    ) => void /** function used for capturing a PostHog event to record the opt-in action */\n    captureEventName?: string /** event name to be used for capturing the opt-in action */\n    captureProperties?: Properties /** set of properties to be captured along with the opt-in action */\n    /** persistence mechanism used */\n    persistenceType?: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    persistencePrefix?: string /** [__ph_opt_in_out] - custom prefix to be used in the cookie/localstorage name */\n    cookieExpiration?: number /** number of days until the opt-in cookie expires */\n    crossSubdomainCookie?: boolean /** whether the opt-in cookie is set as cross-subdomain or not */\n    secureCookie?: boolean /** whether the opt-in cookie is set as secure or not */\n    respectDnt?: boolean\n    window?: Window\n}\n\nexport type RequestCallback = (response: Record<string, any>, data?: Properties) => void\n\nexport interface PersistentStore {\n    is_supported: () => boolean\n    error: (error: any) => void\n    parse: (name: string) => any\n    get: (name: string) => any\n    set: (name: string, value: any, expire_days?: number | null, cross_subdomain?: boolean, secure?: boolean) => void\n    remove: (name: string, cross_subdomain?: boolean) => void\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Breaker = {}\nexport type EventHandler = (event: Event) => boolean | void\n\nexport type ToolbarUserIntent = 'add-action' | 'edit-action'\nexport type ToolbarSource = 'url' | 'localstorage'\nexport type ToolbarVersion = 'toolbar'\n\n/* sync with posthog */\nexport interface ToolbarParams {\n    token?: string /** public posthog-js token */\n    temporaryToken?: string /** private temporary user token */\n    actionId?: number\n    userIntent?: ToolbarUserIntent\n    source?: ToolbarSource\n    toolbarVersion?: ToolbarVersion\n    instrument?: boolean\n    distinctId?: string\n    userEmail?: string\n    dataAttributes?: string[]\n    featureFlags?: Record<string, string | boolean>\n}\n\nexport interface PostData {\n    buffer?: BlobPart\n    compression?: Compression\n    data?: string\n}\n\nexport interface JSC {\n    (): void\n    [key: string]: (response: any) => void\n}\n\nexport type SnippetArrayItem = [method: string, ...args: any[]]\n\nexport type JsonType = string | number | boolean | null | { [key: string]: JsonType } | Array<JsonType>\n\n/** A feature that isn't publicly available yet.*/\nexport interface EarlyAccessFeature {\n    // Sync this with the backend's EarlyAccessFeatureSerializer!\n    name: string\n    description: string\n    stage: 'concept' | 'alpha' | 'beta'\n    documentationUrl: string | null\n    flagKey: string | null\n}\n\nexport type EarlyAccessFeatureCallback = (earlyAccessFeatures: EarlyAccessFeature[]) => void\n\nexport interface EarlyAccessFeatureResponse {\n    earlyAccessFeatures: EarlyAccessFeature[]\n}\n\nexport type Headers = Record<string, string>\n\nexport type Body =\n    | string\n    | Document\n    | Blob\n    | ArrayBufferView\n    | ArrayBuffer\n    | FormData\n    // rrweb uses URLSearchParams and ReadableStream<Uint8Array>\n    // as part of the union for this type\n    // because they don't support IE11\n    // but, we do ðŸ« \n    // what's going to happen here in IE11?\n    | URLSearchParams\n    | ReadableStream<Uint8Array>\n    | null\n\n/* for rrweb/network@1\n ** when that is released as part of rrweb this can be removed\n ** don't rely on this type, it may change without notice\n */\nexport type InitiatorType =\n    | 'audio'\n    | 'beacon'\n    | 'body'\n    | 'css'\n    | 'early-hint'\n    | 'embed'\n    | 'fetch'\n    | 'frame'\n    | 'iframe'\n    | 'icon'\n    | 'image'\n    | 'img'\n    | 'input'\n    | 'link'\n    | 'navigation'\n    | 'object'\n    | 'ping'\n    | 'script'\n    | 'track'\n    | 'video'\n    | 'xmlhttprequest'\n\nexport type NetworkRecordOptions = {\n    initiatorTypes?: InitiatorType[]\n    maskRequestFn?: (data: CapturedNetworkRequest) => CapturedNetworkRequest | undefined\n    recordHeaders?: boolean | { request: boolean; response: boolean }\n    recordBody?: boolean | string[] | { request: boolean | string[]; response: boolean | string[] }\n    recordInitialRequests?: boolean\n    // whether to record PerformanceEntry events for network requests\n    recordPerformance?: boolean\n    // the PerformanceObserver will only observe these entry types\n    performanceEntryTypeToObserve: string[]\n    // the maximum size of the request/response body to record\n    // NB this will be at most 1MB even if set larger\n    payloadSizeLimitBytes: number\n}\n\n/** @deprecated - use CapturedNetworkRequest instead  */\nexport type NetworkRequest = {\n    url: string\n}\n\n// In rrweb this is called NetworkRequest, but we already exposed that as having only URL\n// we also want to vary from the rrweb NetworkRequest because we want to include\n// all PerformanceEntry properties too.\n// that has 4 required properties\n//     readonly duration: DOMHighResTimeStamp;\n//     readonly entryType: string;\n//     readonly name: string;\n//     readonly startTime: DOMHighResTimeStamp;\n// NB: properties below here are ALPHA, don't rely on them, they may change without notice\nexport type CapturedNetworkRequest = Omit<PerformanceEntry, 'toJSON'> & {\n    // properties below here are ALPHA, don't rely on them, they may change without notice\n    method?: string\n    initiatorType?: InitiatorType\n    status?: number\n    timeOrigin?: number\n    timestamp?: number\n    startTime?: number\n    endTime?: number\n    requestHeaders?: Headers\n    requestBody?: Body\n    responseHeaders?: Headers\n    responseBody?: Body\n    // was this captured before fetch/xhr could have been wrapped\n    isInitial?: boolean\n}\n"]}