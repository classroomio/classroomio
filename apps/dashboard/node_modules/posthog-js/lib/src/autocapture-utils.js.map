{"version":3,"file":"autocapture-utils.js","sourceRoot":"","sources":["../../src/autocapture-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { AutocaptureConfig, Properties } from 'types'\nimport { _each, _entries, _includes, _trim } from './utils'\n\nimport { _isArray, _isNull, _isString, _isUndefined } from './utils/type-utils'\nimport { logger } from './utils/logger'\nimport { window } from './utils/globals'\n\nexport function splitClassString(s: string): string[] {\n    return s ? _trim(s).split(/\\s+/) : []\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n *\n * Because this is a string it can contain unexpected characters\n * So, this method safely splits the className and returns that array.\n */\nexport function getClassNames(el: Element): string[] {\n    let className = ''\n    switch (typeof el.className) {\n        case 'string':\n            className = el.className\n            break\n        // TODO: when is this ever used?\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            className =\n                ('baseVal' in el.className ? (el.className as any).baseVal : null) || el.getAttribute('class') || ''\n            break\n        default:\n            className = ''\n    }\n\n    return splitClassString(className)\n}\n\n/*\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @returns {string} the element's direct text content\n */\nexport function getSafeText(el: Element): string {\n    let elText = ''\n\n    if (shouldCaptureElement(el) && !isSensitiveElement(el) && el.childNodes && el.childNodes.length) {\n        _each(el.childNodes, function (child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _trim(child.textContent)\n                    // scrub potentially sensitive values\n                    .split(/(\\s+)/)\n                    .filter(shouldCaptureValue)\n                    .join('')\n                    // normalize whitespace\n                    .replace(/[\\r\\n]/g, ' ')\n                    .replace(/[ ]+/g, ' ')\n                    // truncate\n                    .substring(0, 255)\n            }\n        })\n    }\n\n    return _trim(elText)\n}\n\n/*\n * Check whether an element has nodeType Node.ELEMENT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isElementNode(el: Element | undefined | null): el is HTMLElement {\n    return !!el && el.nodeType === 1 // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nexport function isTag(el: Element | undefined | null, tag: string): el is HTMLElement {\n    return !!el && !!el.tagName && el.tagName.toLowerCase() === tag.toLowerCase()\n}\n\n/*\n * Check whether an element has nodeType Node.TEXT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isTextNode(el: Element | undefined | null): el is HTMLElement {\n    return !!el && el.nodeType === 3 // Node.TEXT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element has nodeType Node.DOCUMENT_FRAGMENT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isDocumentFragment(el: Element | ParentNode | undefined | null): el is DocumentFragment {\n    return !!el && el.nodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE - use integer constant for browser portability\n}\n\nexport const autocaptureCompatibleElements = ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n/*\n * Check whether a DOM event should be \"captured\" or if it may contain sentitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} event - event to check\n * @param {Object} autocaptureConfig - autocapture config\n * @returns {boolean} whether the event should be captured\n */\nexport function shouldCaptureDomEvent(\n    el: Element,\n    event: Event,\n    autocaptureConfig: AutocaptureConfig | undefined = undefined\n): boolean {\n    if (!window || !el || isTag(el, 'html') || !isElementNode(el)) {\n        return false\n    }\n\n    if (autocaptureConfig?.url_allowlist) {\n        const url = window.location.href\n        const allowlist = autocaptureConfig.url_allowlist\n        if (allowlist && !allowlist.some((regex) => url.match(regex))) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.dom_event_allowlist) {\n        const allowlist = autocaptureConfig.dom_event_allowlist\n        if (allowlist && !allowlist.some((eventType) => event.type === eventType)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.element_allowlist) {\n        const allowlist = autocaptureConfig.element_allowlist\n        if (allowlist && !allowlist.some((elementType) => el.tagName.toLowerCase() === elementType)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.css_selector_allowlist) {\n        const allowlist = autocaptureConfig.css_selector_allowlist\n        if (allowlist && !allowlist.some((selector) => el.matches(selector))) {\n            return false\n        }\n    }\n\n    let parentIsUsefulElement = false\n    const targetElementList: Element[] = [el] // TODO: remove this var, it's never queried\n    let parentNode: Element | boolean = true\n    let curEl: Element = el\n    while (curEl.parentNode && !isTag(curEl, 'body')) {\n        // If element is a shadow root, we skip it\n        if (isDocumentFragment(curEl.parentNode)) {\n            targetElementList.push((curEl.parentNode as any).host)\n            curEl = (curEl.parentNode as any).host\n            continue\n        }\n        parentNode = (curEl.parentNode as Element) || false\n        if (!parentNode) break\n        if (autocaptureCompatibleElements.indexOf(parentNode.tagName.toLowerCase()) > -1) {\n            parentIsUsefulElement = true\n        } else {\n            const compStyles = window.getComputedStyle(parentNode)\n            if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer') {\n                parentIsUsefulElement = true\n            }\n        }\n\n        targetElementList.push(parentNode)\n        curEl = parentNode\n    }\n\n    const compStyles = window.getComputedStyle(el)\n    if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer' && event.type === 'click') {\n        return true\n    }\n\n    const tag = el.tagName.toLowerCase()\n    switch (tag) {\n        case 'html':\n            return false\n        case 'form':\n            return event.type === 'submit'\n        case 'input':\n            return event.type === 'change' || event.type === 'click'\n        case 'select':\n        case 'textarea':\n            return event.type === 'change' || event.type === 'click'\n        default:\n            if (parentIsUsefulElement) return event.type === 'click'\n            return (\n                event.type === 'click' &&\n                (autocaptureCompatibleElements.indexOf(tag) > -1 || el.getAttribute('contenteditable') === 'true')\n            )\n    }\n}\n\n/*\n * Check whether a DOM element should be \"captured\" or if it may contain sentitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureElement(el: Element): boolean {\n    for (let curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode as Element) {\n        const classes = getClassNames(curEl)\n        if (_includes(classes, 'ph-sensitive') || _includes(classes, 'ph-no-capture')) {\n            return false\n        }\n    }\n\n    if (_includes(getClassNames(el), 'ph-include')) {\n        return true\n    }\n\n    // don't include hidden or password fields\n    const type = (el as HTMLInputElement).type || ''\n    if (_isString(type)) {\n        // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch (type.toLowerCase()) {\n            case 'hidden':\n                return false\n            case 'password':\n                return false\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    const name = (el as HTMLInputElement).name || el.id || ''\n    // See https://github.com/posthog/posthog-js/issues/165\n    // Under specific circumstances a bug caused .replace to be called on a DOM element\n    // instead of a string, removing the element from the page. Ensure this issue is mitigated.\n    if (_isString(name)) {\n        // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        const sensitiveNameRegex =\n            /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether a DOM element is 'sensitive' and we should only capture limited data\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function isSensitiveElement(el: Element): boolean {\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    const allowedInputTypes = ['button', 'checkbox', 'submit', 'reset']\n    if (\n        (isTag(el, 'input') && !allowedInputTypes.includes((el as HTMLInputElement).type)) ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return true\n    }\n    return false\n}\n\n/*\n * Check whether a string value should be \"captured\" or if it may contain sentitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureValue(value: string): boolean {\n    if (_isNull(value) || _isUndefined(value)) {\n        return false\n    }\n\n    if (_isString(value)) {\n        value = _trim(value)\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        const ccRegex =\n            /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false\n        }\n\n        // check to see if input value looks like a social security number\n        const ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/\n        if (ssnRegex.test(value)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether an attribute name is an Angular style attr (either _ngcontent or _nghost)\n * These update on each build and lead to noise in the element chain\n * More details on the attributes here: https://angular.io/guide/view-encapsulation\n * @param {string} attributeName - string value to check\n * @returns {boolean} whether the element is an angular tag\n */\nexport function isAngularStyleAttr(attributeName: string): boolean {\n    if (_isString(attributeName)) {\n        return attributeName.substring(0, 10) === '_ngcontent' || attributeName.substring(0, 7) === '_nghost'\n    }\n    return false\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces,\n * along with the direct text content of the target element\n * @param {Element} target - element to check\n * @returns {string} text content of the target element and its child span tags\n */\nexport function getDirectAndNestedSpanText(target: Element): string {\n    let text = getSafeText(target)\n    text = `${text} ${getNestedSpanText(target)}`.trim()\n    return shouldCaptureValue(text) ? text : ''\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces\n * @param {Element} target - element to check\n * @returns {string} text content of span tags\n */\nexport function getNestedSpanText(target: Element): string {\n    let text = ''\n    if (target && target.childNodes && target.childNodes.length) {\n        _each(target.childNodes, function (child) {\n            if (child && child.tagName?.toLowerCase() === 'span') {\n                try {\n                    const spanText = getSafeText(child)\n                    text = `${text} ${spanText}`.trim()\n\n                    if (child.childNodes && child.childNodes.length) {\n                        text = `${text} ${getNestedSpanText(child)}`.trim()\n                    }\n                } catch (e) {\n                    logger.error(e)\n                }\n            }\n        })\n    }\n    return text\n}\n\n/*\nBack in the day storing events in Postgres we use Elements for autocapture events.\nNow we're using elements_chain. We used to do this parsing/processing during ingestion.\nThis code is just copied over from ingestion, but we should optimize it\nto create elements_chain string directly.\n*/\nexport function getElementsChainString(elements: Properties[]): string {\n    return elementsToString(extractElements(elements))\n}\n\n// This interface is called 'Element' in plugin-scaffold https://github.com/PostHog/plugin-scaffold/blob/b07d3b879796ecc7e22deb71bf627694ba05386b/src/types.ts#L200\n// However 'Element' is a DOM Element when run in the browser, so we have to rename it\ninterface PHElement {\n    text?: string\n    tag_name?: string\n    href?: string\n    attr_id?: string\n    attr_class?: string[]\n    nth_child?: number\n    nth_of_type?: number\n    attributes?: Record<string, any>\n    event_id?: number\n    order?: number\n    group_id?: number\n}\n\nfunction escapeQuotes(input: string): string {\n    return input.replace(/\"|\\\\\"/g, '\\\\\"')\n}\n\nfunction elementsToString(elements: PHElement[]): string {\n    const ret = elements.map((element) => {\n        let el_string = ''\n        if (element.tag_name) {\n            el_string += element.tag_name\n        }\n        if (element.attr_class) {\n            element.attr_class.sort()\n            for (const single_class of element.attr_class) {\n                el_string += `.${single_class.replace(/\"/g, '')}`\n            }\n        }\n        const attributes: Record<string, any> = {\n            ...(element.text ? { text: element.text } : {}),\n            'nth-child': element.nth_child ?? 0,\n            'nth-of-type': element.nth_of_type ?? 0,\n            ...(element.href ? { href: element.href } : {}),\n            ...(element.attr_id ? { attr_id: element.attr_id } : {}),\n            ...element.attributes,\n        }\n        const sortedAttributes: Record<string, any> = {}\n        _entries(attributes)\n            .sort(([a], [b]) => a.localeCompare(b))\n            .forEach(\n                ([key, value]) => (sortedAttributes[escapeQuotes(key.toString())] = escapeQuotes(value.toString()))\n            )\n        el_string += ':'\n        el_string += _entries(attributes)\n            .map(([key, value]) => `${key}=\"${value}\"`)\n            .join('')\n        return el_string\n    })\n    return ret.join(';')\n}\n\nfunction extractElements(elements: Properties[]): PHElement[] {\n    return elements.map((el) => {\n        const response = {\n            text: el['$el_text']?.slice(0, 400),\n            tag_name: el['tag_name'],\n            href: el['attr__href']?.slice(0, 2048),\n            attr_class: extractAttrClass(el),\n            attr_id: el['attr__id'],\n            nth_child: el['nth_child'],\n            nth_of_type: el['nth_of_type'],\n            attributes: {} as { [id: string]: any },\n        }\n        _entries(el)\n            .filter(([key]) => key.indexOf('attr__') === 0)\n            .forEach(([key, value]) => (response.attributes[key] = value))\n        return response\n    })\n}\n\nfunction extractAttrClass(el: Properties): PHElement['attr_class'] {\n    const attr_class = el['attr__class']\n    if (!attr_class) {\n        return undefined\n    } else if (_isArray(attr_class)) {\n        return attr_class\n    } else {\n        return splitClassString(attr_class)\n    }\n}\n"]}