/// <reference types="svelte" />
import type { MeltActionReturn, TextDirection } from '../../internal/types.js';
import { type Writable } from 'svelte/store';
import type { MenuEvents } from './events.js';
import type { _CheckboxItemProps, _CreateRadioGroupProps, _CreateSubmenuProps, _MenuBuilderOptions, _RadioItemProps, Selector } from './types.js';
export declare const SUB_OPEN_KEYS: Record<TextDirection, string[]>;
export declare const SUB_CLOSE_KEYS: Record<TextDirection, string[]>;
export declare function createMenuBuilder(opts: _MenuBuilderOptions): {
    trigger: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[Writable<boolean>], (node: HTMLElement) => MeltActionReturn<MenuEvents['trigger']>, ([$rootOpen]: [boolean]) => {
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'data-state': "open" | "closed";
        readonly id: string;
        readonly tabindex: 0;
    }, string>;
    menu: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[import("svelte/store").Readable<boolean>, Writable<string | HTMLElement | null | undefined>], (node: HTMLElement) => MeltActionReturn<MenuEvents['menu']>, ([$isVisible, $portal]: [boolean, string | HTMLElement | null | undefined]) => {
        readonly role: "menu";
        readonly hidden: true | undefined;
        readonly style: string;
        readonly id: string;
        readonly 'aria-labelledby': string;
        readonly 'data-state': "open" | "closed";
        readonly 'data-portal': "" | undefined;
        readonly tabindex: -1;
    }, string>;
    open: Writable<boolean>;
    item: import("../../internal/helpers/index.js").ExplicitBuilderReturn<import("svelte/store").Stores | undefined, (node: HTMLElement) => MeltActionReturn<MenuEvents['item']>, () => {
        role: string;
        tabindex: number;
        'data-orientation': string;
    }, string>;
    group: import("../../internal/helpers/index.js").ExplicitBuilderReturn<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
        role: string;
        'aria-labelledby': string;
    }, string>;
    groupLabel: import("../../internal/helpers/index.js").ExplicitBuilderReturn<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
        id: string;
    }, string>;
    arrow: import("../../internal/helpers/index.js").ExplicitBuilderReturn<Writable<number | undefined>, import("svelte/action").Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
        'data-arrow': boolean;
        style: string;
    }, string>;
    options: {
        positioning: Writable<import("../../internal/actions/index.js").FloatingConfig>;
        arrowSize: Writable<number | undefined>;
        preventScroll: Writable<boolean | undefined>;
        loop: Writable<boolean | undefined>;
        dir: Writable<TextDirection>;
        closeOnEscape: Writable<boolean>;
        closeOnOutsideClick: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        forceVisible: Writable<boolean>;
        typeahead: Writable<boolean>;
    };
    createCheckboxItem: (props?: _CheckboxItemProps) => {
        elements: {
            checkboxItem: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[{
                update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                set: (this: void, value: boolean | "indeterminate") => void;
                subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
            }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<MenuEvents['checkboxItem']>, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
                readonly role: "menuitemcheckbox";
                readonly tabindex: -1;
                readonly 'data-orientation': "vertical";
                readonly 'aria-checked': "true" | "mixed" | "false";
                readonly 'data-disabled': "" | undefined;
                readonly 'data-state': "indeterminate" | "checked" | "unchecked";
            }, string>;
        };
        states: {
            checked: {
                update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                set: (this: void, value: boolean | "indeterminate") => void;
                subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
            };
        };
        options: {
            disabled: Writable<boolean>;
        };
    };
    createSubmenu: (args?: _CreateSubmenuProps) => {
        elements: {
            subTrigger: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<MenuEvents['subTrigger']>, ([$subOpen, $disabled]: [boolean, boolean]) => {
                readonly role: "menuitem";
                readonly id: string;
                readonly tabindex: -1;
                readonly 'aria-controls': string;
                readonly 'aria-expanded': boolean;
                readonly 'data-state': "open" | "closed";
                readonly 'data-disabled': "" | undefined;
                readonly 'aria-haspopop': "menu";
            }, string>;
            subMenu: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[import("svelte/store").Readable<boolean>], (node: HTMLElement) => MeltActionReturn<MenuEvents['submenu']>, ([$subIsVisible]: [boolean]) => {
                readonly role: "menu";
                readonly hidden: true | undefined;
                readonly style: string;
                readonly id: string;
                readonly 'aria-labelledby': string;
                readonly 'data-state': "open" | "closed";
                readonly tabindex: -1;
            }, string>;
            subArrow: import("../../internal/helpers/index.js").ExplicitBuilderReturn<Writable<number>, import("svelte/action").Action<any, any, Record<never, any>>, ($arrowSize: number) => {
                'data-arrow': boolean;
                style: string;
            }, string>;
        };
        states: {
            subOpen: Writable<boolean>;
        };
        options: {
            positioning: Writable<import("../../internal/actions/index.js").FloatingConfig | {
                placement: "right-start";
                gutter: number;
            }>;
            arrowSize: Writable<number>;
            disabled: Writable<boolean>;
            preventScroll: Writable<true>;
            closeOnEscape: Writable<true>;
            closeOnOutsideClick: Writable<true>;
            portal: Writable<string>;
            loop: Writable<false>;
            dir: Writable<"ltr">;
            defaultOpen: Writable<false>;
            typeahead: Writable<true>;
        };
    };
    createMenuRadioGroup: (args?: _CreateRadioGroupProps) => {
        elements: {
            radioGroup: import("../../internal/helpers/index.js").ExplicitBuilderReturn<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => {
                role: string;
            }, string>;
            radioItem: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[{
                update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                set: (this: void, value: string | null) => void;
                subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            }], (node: HTMLElement) => MeltActionReturn<MenuEvents['radioItem']>, ([$value]: [string | null]) => (itemProps: _RadioItemProps) => {
                disabled: boolean;
                role: string;
                'data-state': string;
                'aria-checked': boolean;
                'data-disabled': string | undefined;
                'data-value': string;
                'data-orientation': string;
                tabindex: number;
            }, string>;
        };
        states: {
            value: {
                update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                set: (this: void, value: string | null) => void;
                subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            };
        };
        helpers: {
            isChecked: import("svelte/store").Readable<(itemValue: string) => boolean>;
        };
    };
    separator: import("../../internal/helpers/index.js").ExplicitBuilderReturn<[Writable<import("../../internal/types.js").Orientation>, Writable<boolean>], import("svelte/action").Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [import("../../internal/types.js").Orientation, boolean]) => {
        role: string;
        'aria-orientation': "vertical" | undefined;
        'aria-hidden': boolean;
        'data-orientation': import("../../internal/types.js").Orientation;
    }, "separator">;
    rootIds: {
        menu: string;
        trigger: string;
    };
    handleTypeaheadSearch: (key: string, items: HTMLElement[]) => void;
};
export declare function handleTabNavigation(e: KeyboardEvent, nextFocusable: Writable<HTMLElement | null>, prevFocusable: Writable<HTMLElement | null>): void;
/**
 * Get the menu items for a given menu element.
 * This only selects menu items that are direct children of the menu element,
 * not menu items that are nested in submenus.
 * @param element The menu item element
 */
export declare function getMenuItems(menuElement: HTMLElement): HTMLElement[];
export declare function applyAttrsIfDisabled(element: HTMLElement | null): void;
/**
 * Given a timer store, clear the timeout and set the store to null
 * @param openTimer The timer store
 */
export declare function clearTimerStore(timerStore: Writable<number | null>): void;
/**
 * Set the `data-melt-menu-id` attribute on a menu item element.
 * @param element The menu item element
 */
export declare function setMeltMenuAttribute(element: HTMLElement | null, selector: Selector): void;
/**
 * Keyboard event handler for menu navigation
 * @param e The keyboard event
 */
export declare function handleMenuNavigation(e: KeyboardEvent): void;
export type Point = {
    x: number;
    y: number;
};
