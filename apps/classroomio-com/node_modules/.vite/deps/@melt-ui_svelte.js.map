{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/builder.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/dom.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/list.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/locale.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js", "../../../../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/non-secure/index.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/hull.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/index.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedWithUnsubscribe.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/debounceable.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/ignore.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/accordion/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/avatar/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/checkbox/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/collapsible/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js", "../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../../../node_modules/.pnpm/@floating-ui+core@1.5.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs", "../../../../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js", "../../../../../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/src/index.js", "../../../../../node_modules/.pnpm/focus-trap@7.5.4/node_modules/focus-trap/index.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/melt/index.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/label/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/combobox/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/menu/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/context-menu/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/dialog/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/link-preview/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/menubar/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pagination/helpers.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pagination/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pin-input/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/popover/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/progress/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/radio-group/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/select/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/separator/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/slider/helpers.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/slider/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/switch/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tabs/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/table-of-contents/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tags-input/helpers.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tags-input/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toast/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toggle/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toggle-group/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toolbar/create.js", "../../../../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tooltip/create.js"],
  "sourcesContent": ["var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nexport function toggle(item, array) {\n    const itemIdx = array.findIndex((i) => deepEqual(i, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n", "export function lightable(value) {\n    function subscribe(run) {\n        run(value);\n        return () => {\n            // don't need to unsub from anything\n        };\n    }\n    return { subscribe };\n}\n", "import { derived } from 'svelte/store';\nimport { isBrowser, isHTMLElement, noop } from './index.js';\nimport { lightable } from './store/lightable.js';\nexport function getElementByMeltId(id) {\n    if (!isBrowser)\n        return null;\n    const el = document.querySelector(`[data-melt-id=\"${id}\"]`);\n    return isHTMLElement(el) ? el : null;\n}\nexport const hiddenAction = (obj) => {\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            return Reflect.get(target, prop, receiver);\n        },\n        ownKeys(target) {\n            return Reflect.ownKeys(target).filter((key) => key !== 'action');\n        },\n    });\n};\nconst isFunctionWithParams = (fn) => {\n    return typeof fn === 'function';\n};\nexport function builder(name, args) {\n    const { stores, action, returned } = args ?? {};\n    const derivedStore = (() => {\n        if (stores && returned) {\n            // If stores are provided, create a derived store from them\n            return derived(stores, (values) => {\n                const result = returned(values);\n                if (isFunctionWithParams(result)) {\n                    const fn = (...args) => {\n                        return hiddenAction({\n                            ...result(...args),\n                            [`data-melt-${name}`]: '',\n                            action: action ?? noop,\n                        });\n                    };\n                    fn.action = action ?? noop;\n                    return fn;\n                }\n                return hiddenAction({\n                    ...result,\n                    [`data-melt-${name}`]: '',\n                    action: action ?? noop,\n                });\n            });\n        }\n        else {\n            // If stores are not provided, return a lightable store, for consistency\n            const returnedFn = returned;\n            const result = returnedFn?.();\n            if (isFunctionWithParams(result)) {\n                const resultFn = (...args) => {\n                    return hiddenAction({\n                        ...result(...args),\n                        [`data-melt-${name}`]: '',\n                        action: action ?? noop,\n                    });\n                };\n                resultFn.action = action ?? noop;\n                return lightable(resultFn);\n            }\n            return lightable(hiddenAction({\n                ...result,\n                [`data-melt-${name}`]: '',\n                action: action ?? noop,\n            }));\n        }\n    })();\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = derivedStore.subscribe;\n    return actionFn;\n}\nexport function createElHelpers(prefix) {\n    const name = (part) => (part ? `${prefix}-${part}` : prefix);\n    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;\n    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;\n    const getEl = (part) => document.querySelector(selector(part));\n    return {\n        name,\n        attribute,\n        selector,\n        getEl,\n    };\n}\n", "export const isBrowser = typeof document !== 'undefined';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (v) => typeof v === 'function';\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isHTMLInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isHTMLLabelElement(element) {\n    return element instanceof HTMLLabelElement;\n}\nexport function isElementDisabled(element) {\n    const ariaDisabled = element.getAttribute('aria-disabled');\n    const disabled = element.getAttribute('disabled');\n    const dataDisabled = element.hasAttribute('data-disabled');\n    if (ariaDisabled === 'true' || disabled !== null || dataDisabled) {\n        return true;\n    }\n    return false;\n}\nexport function isTouch(event) {\n    return event.pointerType === 'touch';\n}\nexport function isLeftClick(event) {\n    return event.button === 0 && event.ctrlKey === false && event.metaKey === false;\n}\nexport function isFocusVisible(element) {\n    return element.matches(':focus-visible');\n}\n", "import { isHTMLElement } from './is.js';\nexport function focus(element) {\n    if (isHTMLElement(element)) {\n        element.focus();\n    }\n    else if (typeof element === 'string') {\n        const el = document.querySelector(element);\n        if (!el)\n            return;\n        el.focus();\n    }\n}\n/**\n * Returns a list of nodes that can be in the tab sequence.\n * @see: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n */\nexport function getTabbableNodes(container) {\n    const nodes = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: (node) => {\n            // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n            // runtime's understanding of tabbability, so this automatically accounts\n            // for any kind of element that could be tabbed to.\n            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n        },\n    });\n    while (walker.nextNode()) {\n        nodes.push(walker.currentNode);\n    }\n    return nodes;\n}\n", "/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n/**\n * A no operation function (does nothing)\n */\nexport function noop() {\n    //\n}\n", "import { noop } from './callbacks.js';\nimport { isHTMLElement } from './is.js';\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\nexport function addMeltEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    if (typeof handler === 'function') {\n        const handlerWithMelt = withMelt((_event) => handler(_event));\n        // Add the event listener to each specified event for the target element(s).\n        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));\n        // Return a function that removes the event listener from the target element(s).\n        return () => {\n            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));\n        };\n    }\n    return () => noop();\n}\nexport function dispatchMeltEvent(originalEvent) {\n    const node = originalEvent.currentTarget;\n    if (!isHTMLElement(node))\n        return null;\n    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {\n        detail: {\n            originalEvent,\n        },\n        cancelable: true,\n    });\n    node.dispatchEvent(customMeltEvent);\n    return customMeltEvent;\n}\nexport function withMelt(handler) {\n    return (event) => {\n        const customEvent = dispatchMeltEvent(event);\n        if (customEvent?.defaultPrevented)\n            return;\n        return handler(event);\n    };\n}\n", "export function addHighlight(element) {\n    element.setAttribute('data-highlighted', '');\n}\nexport function removeHighlight(element) {\n    element.removeAttribute('data-highlighted');\n}\n", "import { isHTMLElement } from './is.js';\n/** Retrieves all option descendants of a given element. */\nexport function getOptions(el) {\n    return Array.from(el.querySelectorAll('[role=\"option\"]:not([data-disabled])')).filter((el) => isHTMLElement(el));\n}\n/** Retrieves the first option descendant of a given element. */\nexport function getFirstOption(el) {\n    const firstOption = el.querySelector('[role=\"option\"]:not([data-disabled])');\n    return isHTMLElement(firstOption) ? firstOption : null;\n}\n", "/**\n * Detects the text direction in the element.\n * @returns {TextDirection} The text direction ('ltr' for left-to-right or 'rtl' for right-to-left).\n */\nexport function getElemDirection(elem) {\n    const style = window.getComputedStyle(elem);\n    const direction = style.getPropertyValue('direction');\n    return direction;\n}\n", "export function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n", "export const overridable = (store, onChange) => {\n    const update = (updater, sideEffect) => {\n        store.update((curr) => {\n            const next = updater(curr);\n            let res = next;\n            if (onChange) {\n                res = onChange({ curr, next });\n            }\n            sideEffect?.(res);\n            return res;\n        });\n    };\n    const set = (curr) => {\n        update(() => curr);\n    };\n    return {\n        ...store,\n        update,\n        set,\n    };\n};\n", "export function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * A utility function that converts a style object to a string.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, '');\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n", "import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\n", "/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n", "export function debounce(fn, wait = 500) {\n    let timeout = null;\n    return function (...args) {\n        const later = () => {\n            timeout = null;\n            fn(...args);\n        };\n        timeout && clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n", "export const isDom = () => typeof window !== 'undefined';\nexport function getPlatform() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const agent = navigator.userAgentData;\n    return agent?.platform ?? navigator.platform;\n}\nconst pt = (v) => isDom() && v.test(getPlatform());\nconst ua = (v) => isDom() && v.test(navigator.userAgent);\nconst vn = (v) => isDom() && v.test(navigator.vendor);\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice();\nexport const isIPhone = () => pt(/^iPhone/);\nexport const isSafari = () => isApple() && vn(/apple/i);\nexport const isFirefox = () => ua(/firefox\\//i);\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i);\nexport const isIos = () => isApple() && !isMac();\n", "/*\n * Convex hull algorithm - Library (TypeScript)\n *\n * Copyright (c) 2021 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n// Returns a new array of points representing the convex hull of\n// the given set of points. The convex hull excludes collinear points.\n// This algorithm runs in O(n log n) time.\nexport function makeHull(points) {\n    const newPoints = points.slice();\n    newPoints.sort(POINT_COMPARATOR);\n    return makeHullPresorted(newPoints);\n}\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nexport function makeHullPresorted(points) {\n    if (points.length <= 1)\n        return points.slice();\n    // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n    // as per the mathematical convention, instead of \"down\" as per the computer\n    // graphics convention. This doesn't affect the correctness of the result.\n    const upperHull = [];\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        while (upperHull.length >= 2) {\n            const q = upperHull[upperHull.length - 1];\n            const r = upperHull[upperHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                upperHull.pop();\n            else\n                break;\n        }\n        upperHull.push(p);\n    }\n    upperHull.pop();\n    const lowerHull = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const p = points[i];\n        while (lowerHull.length >= 2) {\n            const q = lowerHull[lowerHull.length - 1];\n            const r = lowerHull[lowerHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                lowerHull.pop();\n            else\n                break;\n        }\n        lowerHull.push(p);\n    }\n    lowerHull.pop();\n    if (upperHull.length == 1 &&\n        lowerHull.length == 1 &&\n        upperHull[0].x == lowerHull[0].x &&\n        upperHull[0].y == lowerHull[0].y)\n        return upperHull;\n    else\n        return upperHull.concat(lowerHull);\n}\nexport function POINT_COMPARATOR(a, b) {\n    if (a.x < b.x)\n        return -1;\n    else if (a.x > b.x)\n        return +1;\n    else if (a.y < b.y)\n        return -1;\n    else if (a.y > b.y)\n        return +1;\n    else\n        return 0;\n}\n", "export * from './hull.js';\nimport { makeHull } from './hull.js';\nexport function getPointsFromEl(el) {\n    const rect = el.getBoundingClientRect();\n    return [\n        { x: rect.left, y: rect.top },\n        { x: rect.right, y: rect.top },\n        { x: rect.right, y: rect.bottom },\n        { x: rect.left, y: rect.bottom },\n    ];\n}\nexport function makeHullFromElements(els) {\n    const points = els.flatMap((el) => getPointsFromEl(el));\n    return makeHull(points);\n}\nexport function pointInPolygon(point, polygon) {\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        const intersect = yi > point.y !== yj > point.y && point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\n", "// Modified from @zag-js/remove-scroll v0.10.2 (2023-06-10)\n// Source: https://github.com/chakra-ui/zag\n// https://github.com/chakra-ui/zag/blob/main/packages/utilities/remove-scroll/src/index.ts\nimport { noop } from './callbacks.js';\nimport { isIos } from './platform.js';\nconst LOCK_CLASSNAME = 'data-melt-scroll-lock';\nfunction assignStyle(el, style) {\n    if (!el)\n        return;\n    const previousStyle = el.style.cssText;\n    Object.assign(el.style, style);\n    return () => {\n        el.style.cssText = previousStyle;\n    };\n}\nfunction setCSSProperty(el, property, value) {\n    if (!el)\n        return;\n    const previousValue = el.style.getPropertyValue(property);\n    el.style.setProperty(property, value);\n    return () => {\n        if (previousValue) {\n            el.style.setProperty(property, previousValue);\n        }\n        else {\n            el.style.removeProperty(property);\n        }\n    };\n}\nfunction getPaddingProperty(documentElement) {\n    // RTL <body> scrollbar\n    const documentLeft = documentElement.getBoundingClientRect().left;\n    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n    return scrollbarX ? 'paddingLeft' : 'paddingRight';\n}\nexport function removeScroll(_document) {\n    const doc = _document ?? document;\n    const win = doc.defaultView ?? window;\n    const { documentElement, body } = doc;\n    const locked = body.hasAttribute(LOCK_CLASSNAME);\n    if (locked)\n        return noop;\n    body.setAttribute(LOCK_CLASSNAME, '');\n    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n    const setScrollbarWidthProperty = () => setCSSProperty(documentElement, '--scrollbar-width', `${scrollbarWidth}px`);\n    const paddingProperty = getPaddingProperty(documentElement);\n    const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];\n    const setStyle = () => assignStyle(body, {\n        overflow: 'hidden',\n        [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n    });\n    // Only iOS doesn't respect `overflow: hidden` on document.body\n    const setIOSStyle = () => {\n        const { scrollX, scrollY, visualViewport } = win;\n        // iOS 12 does not support `visuaViewport`.\n        const offsetLeft = visualViewport?.offsetLeft ?? 0;\n        const offsetTop = visualViewport?.offsetTop ?? 0;\n        const restoreStyle = assignStyle(body, {\n            position: 'fixed',\n            overflow: 'hidden',\n            top: `${-(scrollY - Math.floor(offsetTop))}px`,\n            left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n            right: '0',\n            [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n        });\n        return () => {\n            restoreStyle?.();\n            win.scrollTo(scrollX, scrollY);\n        };\n    };\n    const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];\n    return () => {\n        cleanups.forEach((fn) => fn?.());\n        body.removeAttribute(LOCK_CLASSNAME);\n    };\n}\n", "import { derived } from 'svelte/store';\n/**\n * Helper function to standardize the way we derive a visible state for the\n * popper/floating elements.\n */\nexport function derivedVisible(obj) {\n    const { open, forceVisible, activeTrigger } = obj;\n    return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);\n}\n", "import { onDestroy } from 'svelte';\nimport { derived } from 'svelte/store';\n/**\n * A utility function that creates a derived store that automatically\n * unsubscribes from its dependencies.\n *\n * @template S - The type of the stores object\n * @template T - The type of the derived store\n * @param stores - The stores object to derive from\n * @param fn - The function to derive the store from\n * @returns A derived store that automatically unsubscribes from its dependencies\n */\nexport function derivedWithUnsubscribe(stores, fn) {\n    let unsubscribers = [];\n    const onUnsubscribe = (cb) => {\n        unsubscribers.push(cb);\n    };\n    const unsubscribe = () => {\n        // console.log('dfu unsubscribing');\n        // Call all of the unsubscribe functions from the previous run of the function\n        unsubscribers.forEach((fn) => fn());\n        // Clear the list of unsubscribe functions\n        unsubscribers = [];\n    };\n    const derivedStore = derived(stores, ($storeValues) => {\n        unsubscribe();\n        return fn($storeValues, onUnsubscribe);\n    });\n    onDestroy(unsubscribe);\n    const subscribe = (...args) => {\n        const unsub = derivedStore.subscribe(...args);\n        return () => {\n            unsub();\n            unsubscribe();\n        };\n    };\n    return {\n        ...derivedStore,\n        subscribe,\n    };\n}\n", "import { onDestroy } from 'svelte';\nimport { derivedWithUnsubscribe } from './derivedWithUnsubscribe';\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function effect(stores, fn) {\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const unsub = derivedWithUnsubscribe(stores, (stores, onUnsubscribe) => {\n        return {\n            stores,\n            onUnsubscribe,\n        };\n    }).subscribe(({ stores, onUnsubscribe }) => {\n        const returned = fn(stores);\n        // If the function returns a cleanup function, call it when the effect is unsubscribed\n        if (returned) {\n            onUnsubscribe(returned);\n        }\n    });\n    // Automatically unsubscribe the effect when the component is destroyed\n    onDestroy(unsub);\n    return unsub;\n}\n", "import { writable } from 'svelte/store';\nexport function debounceable(initialValue, wait = 0) {\n    const store = writable({ value: initialValue, debounced: initialValue });\n    let timeout;\n    function debouncedSet(value) {\n        store.update((state) => {\n            state.value = value;\n            return state;\n        });\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            store.update((state) => {\n                state.debounced = state.value;\n                return state;\n            });\n        }, wait);\n    }\n    function debouncedUpdate(fn) {\n        store.update((state) => {\n            state.value = fn(state.value);\n            return state;\n        });\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            store.update((state) => {\n                state.debounced = state.value;\n                return state;\n            });\n        }, wait);\n    }\n    function set(value) {\n        store.update((state) => {\n            state.value = value;\n            state.debounced = value;\n            return state;\n        });\n    }\n    function update(fn) {\n        store.update((state) => {\n            state.value = fn(state.value);\n            state.debounced = state.value;\n            return state;\n        });\n    }\n    return {\n        ...store,\n        debouncedSet,\n        debouncedUpdate,\n        set,\n        update,\n    };\n}\n", "import { writable } from 'svelte/store';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = writable(value);\n    });\n    return result;\n}\n", "import { isBrowser, isHTMLElement } from './is.js';\nimport { sleep } from './sleep.js';\n/**\n * Manage roving focus between elements. Sets the current active element to\n * tabindex -1 and the next element to tabindex 0.\n *\n * @param nextElement The element to focus on\n */\nexport function handleRovingFocus(nextElement) {\n    if (!isBrowser)\n        return;\n    const currentFocusedElement = document.activeElement;\n    if (!isHTMLElement(currentFocusedElement))\n        return;\n    if (currentFocusedElement === nextElement)\n        return;\n    currentFocusedElement.tabIndex = -1;\n    nextElement.tabIndex = 0;\n    sleep(1).then(() => nextElement.focus());\n}\nfunction getFocusableElements() {\n    return Array.from(document.querySelectorAll('a[href]:not([tabindex=\"-1\"]), button:not([disabled]):not([tabindex=\"-1\"]), input:not([disabled]):not([tabindex=\"-1\"]), select:not([disabled]):not([tabindex=\"-1\"]), textarea:not([disabled]):not([tabindex=\"-1\"]), [tabindex]:not([tabindex=\"-1\"])'));\n}\nexport function getNextFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const nextIndex = currentIndex + 1;\n    const nextElement = focusableElements[nextIndex];\n    if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {\n        return nextElement;\n    }\n    return null;\n}\nexport function getPreviousFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const previousIndex = currentIndex - 1;\n    const prevElement = focusableElements[previousIndex];\n    if (previousIndex >= 0 && isHTMLElement(prevElement)) {\n        return prevElement;\n    }\n    return null;\n}\n", "import { get, writable } from 'svelte/store';\nimport { debounce } from './debounce.js';\nimport { handleRovingFocus } from './rovingFocus.js';\nimport { isHTMLElement } from './is.js';\nimport { wrapArray } from './array.js';\n/**\n * Default options for the typeahead search.\n * We default to roving focus when a match is found, but\n * you can override this with the `onMatch` option.\n */\nconst defaults = {\n    onMatch: handleRovingFocus,\n};\nexport function createTypeaheadSearch(args = {}) {\n    const withDefaults = { ...defaults, ...args };\n    const typed = writable([]);\n    const resetTyped = debounce(() => {\n        typed.update(() => []);\n    });\n    const handleTypeaheadSearch = (key, items) => {\n        const currentItem = document.activeElement;\n        if (!isHTMLElement(currentItem))\n            return;\n        const $typed = get(typed);\n        if (!Array.isArray($typed)) {\n            return;\n        }\n        $typed.push(key.toLowerCase());\n        typed.update(() => $typed);\n        const candidateItems = items.filter((item) => {\n            if (item.getAttribute('disabled') === 'true' ||\n                item.getAttribute('aria-disabled') === 'true' ||\n                item.hasAttribute('data-disabled')) {\n                return false;\n            }\n            return true;\n        });\n        const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);\n        const normalizeSearch = isRepeated ? $typed[0] : $typed.join('');\n        const currentItemIndex = currentItem ? candidateItems.indexOf(currentItem) : -1;\n        let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));\n        const excludeCurrentItem = normalizeSearch.length === 1;\n        if (excludeCurrentItem) {\n            wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n        }\n        const nextItem = wrappedItems.find((item) => item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));\n        if (isHTMLElement(nextItem) && nextItem !== currentItem) {\n            withDefaults.onMatch(nextItem);\n        }\n        resetTyped();\n    };\n    return {\n        typed,\n        resetTyped,\n        handleTypeaheadSearch,\n    };\n}\n", "import { isHTMLElement } from './is.js';\n/**\n * Get an element's ancestor which has a `data-portal` attribute.\n * This is used to handle nested portals/overlays/dialogs/popovers.\n */\nfunction getPortalParent(node) {\n    let parent = node.parentElement;\n    while (isHTMLElement(parent) && !parent.hasAttribute('data-portal')) {\n        parent = parent.parentElement;\n    }\n    return parent || 'body';\n}\nexport function getPortalDestination(node, portalProp) {\n    const portalParent = getPortalParent(node);\n    if (portalProp !== undefined)\n        return portalProp;\n    if (portalParent === 'body')\n        return document.body;\n    return null;\n}\n", "import { getElementByMeltId, isElement, isHTMLLabelElement } from './';\nexport function createClickOutsideIgnore(meltId) {\n    return (e) => {\n        const target = e.target;\n        const triggerEl = getElementByMeltId(meltId);\n        if (!triggerEl || !isElement(target))\n            return false;\n        const id = triggerEl.id;\n        if (isHTMLLabelElement(target) && id === target.htmlFor) {\n            return true;\n        }\n        if (target.closest(`label[for=\"${id}\"]`)) {\n            return true;\n        }\n        return false;\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, executeCallbacks, generateId, getElementByMeltId, isHTMLElement, kbd, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nconst { name, selector } = createElHelpers('accordion');\nconst defaults = {\n    multiple: false,\n    disabled: false,\n    forceVisible: false,\n};\nexport const createAccordion = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value', 'onValueChange', 'defaultValue'));\n    const { disabled, forceVisible } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    const isSelected = (key, v) => {\n        if (v === undefined)\n            return false;\n        if (typeof v === 'string')\n            return v === key;\n        return v.includes(key);\n    };\n    const isSelectedStore = derived(value, ($value) => {\n        return (key) => isSelected(key, $value);\n    });\n    const ids = {\n        root: generateId(),\n    };\n    const root = builder(name(), {\n        returned: () => ({\n            'data-melt-id': ids.root,\n        }),\n    });\n    const parseItemProps = (props) => {\n        if (typeof props === 'string') {\n            return { value: props };\n        }\n        else {\n            return props;\n        }\n    };\n    const parseHeadingProps = (props) => {\n        if (typeof props === 'number') {\n            return { level: props };\n        }\n        else {\n            return props;\n        }\n    };\n    const item = builder(name('item'), {\n        stores: value,\n        returned: ($value) => {\n            return (props) => {\n                const { value: itemValue, disabled } = parseItemProps(props);\n                return {\n                    'data-state': isSelected(itemValue, $value) ? 'open' : 'closed',\n                    'data-disabled': disabled ? true : undefined,\n                };\n            };\n        },\n    });\n    const trigger = builder(name('trigger'), {\n        stores: [value, disabled],\n        returned: ([$value, $disabled]) => {\n            return (props) => {\n                const { value: itemValue, disabled } = parseItemProps(props);\n                // generate the content ID here so that we can grab it in the content\n                // builder action to ensure the values match.\n                return {\n                    disabled: $disabled || disabled,\n                    'aria-expanded': isSelected(itemValue, $value) ? true : false,\n                    'aria-disabled': disabled ? true : false,\n                    'data-disabled': disabled ? true : undefined,\n                    'data-value': itemValue,\n                    'data-state': isSelected(itemValue, $value) ? 'open' : 'closed',\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const disabled = node.dataset.disabled === 'true';\n                const itemValue = node.dataset.value;\n                if (disabled || !itemValue)\n                    return;\n                handleValueUpdate(itemValue);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (![kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.HOME, kbd.END].includes(e.key)) {\n                    return;\n                }\n                e.preventDefault();\n                if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n                    const disabled = node.dataset.disabled === 'true';\n                    const itemValue = node.dataset.value;\n                    if (disabled || !itemValue)\n                        return;\n                    handleValueUpdate(itemValue);\n                    return;\n                }\n                const el = e.target;\n                const rootEl = getElementByMeltId(ids.root);\n                if (!rootEl || !isHTMLElement(el))\n                    return;\n                const items = Array.from(rootEl.querySelectorAll(selector('trigger')));\n                const candidateItems = items.filter((item) => {\n                    if (!isHTMLElement(item))\n                        return false;\n                    return item.dataset.disabled !== 'true';\n                });\n                if (!candidateItems.length)\n                    return;\n                const elIdx = candidateItems.indexOf(el);\n                if (e.key === kbd.ARROW_DOWN) {\n                    candidateItems[(elIdx + 1) % candidateItems.length].focus();\n                }\n                if (e.key === kbd.ARROW_UP) {\n                    candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length].focus();\n                }\n                if (e.key === kbd.HOME) {\n                    candidateItems[0].focus();\n                }\n                if (e.key === kbd.END) {\n                    candidateItems[candidateItems.length - 1].focus();\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const content = builder(name('content'), {\n        stores: [value, disabled, forceVisible],\n        returned: ([$value, $disabled, $forceVisible]) => {\n            return (props) => {\n                const { value: itemValue } = parseItemProps(props);\n                const isVisible = isSelected(itemValue, $value) || $forceVisible;\n                return {\n                    'data-state': isVisible ? 'open' : 'closed',\n                    'data-disabled': $disabled ? true : undefined,\n                    'data-value': itemValue,\n                    hidden: isVisible ? undefined : true,\n                    style: styleToString({\n                        display: isVisible ? undefined : 'none',\n                    }),\n                };\n            };\n        },\n        action: (node) => {\n            tick().then(() => {\n                const contentId = generateId();\n                const triggerId = generateId();\n                const parentTrigger = document.querySelector(`${selector('trigger')}, [data-value=\"${node.dataset.value}\"]`);\n                if (!isHTMLElement(parentTrigger))\n                    return;\n                node.id = contentId;\n                parentTrigger.setAttribute('aria-controls', contentId);\n                parentTrigger.id = triggerId;\n            });\n        },\n    });\n    const heading = builder(name('heading'), {\n        returned: () => {\n            return (props) => {\n                const { level } = parseHeadingProps(props);\n                return {\n                    role: 'heading',\n                    'aria-level': level,\n                    'data-heading-level': level,\n                };\n            };\n        },\n    });\n    function handleValueUpdate(itemValue) {\n        value.update(($value) => {\n            if ($value === undefined) {\n                return withDefaults.multiple ? [itemValue] : itemValue;\n            }\n            if (Array.isArray($value)) {\n                if ($value.includes(itemValue)) {\n                    return $value.filter((v) => v !== itemValue);\n                }\n                $value.push(itemValue);\n                return $value;\n            }\n            return $value === itemValue ? undefined : itemValue;\n        });\n    }\n    return {\n        elements: {\n            root,\n            item,\n            trigger,\n            content,\n            heading,\n        },\n        states: {\n            value: value,\n        },\n        helpers: {\n            isSelected: isSelectedStore,\n        },\n        options,\n    };\n};\n", "import { builder, effect, isBrowser, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { writable } from 'svelte/store';\nconst defaults = {\n    src: '',\n    delayMs: 0,\n    onLoadingStatusChange: undefined,\n};\nexport const createAvatar = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'loadingStatus', 'onLoadingStatusChange'));\n    const { src, delayMs } = options;\n    const loadingStatusWritable = withDefaults.loadingStatus ?? writable('loading');\n    const loadingStatus = overridable(loadingStatusWritable, withDefaults?.onLoadingStatusChange);\n    effect([src, delayMs], ([$src, $delayMs]) => {\n        if (isBrowser) {\n            const image = new Image();\n            image.src = $src;\n            image.onload = () => {\n                if (delayMs !== undefined) {\n                    const timerId = window.setTimeout(() => {\n                        loadingStatus.set('loaded');\n                    }, $delayMs);\n                    return () => window.clearTimeout(timerId);\n                }\n                else {\n                    loadingStatus.set('loaded');\n                }\n            };\n            image.onerror = () => {\n                loadingStatus.set('error');\n            };\n        }\n    });\n    const image = builder('avatar-image', {\n        stores: [src, loadingStatus],\n        returned: ([$src, $loadingStatus]) => {\n            const imageStyles = styleToString({\n                display: $loadingStatus === 'loaded' ? 'block' : 'none',\n            });\n            return {\n                src: $src,\n                style: imageStyles,\n            };\n        },\n    });\n    const fallback = builder('avatar-fallback', {\n        stores: [loadingStatus],\n        returned: ([$loadingStatus]) => {\n            return {\n                style: $loadingStatus === 'loaded'\n                    ? styleToString({\n                        display: 'none',\n                    })\n                    : undefined,\n                hidden: $loadingStatus === 'loaded' ? true : undefined,\n            };\n        },\n    });\n    return {\n        elements: {\n            image,\n            fallback,\n        },\n        states: {\n            loadingStatus,\n        },\n        options,\n    };\n};\n", "import { addMeltEventListener, builder, executeCallbacks, kbd, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { derived, get, writable } from 'svelte/store';\nconst defaults = {\n    disabled: false,\n    required: false,\n    name: undefined,\n    value: 'on',\n    defaultChecked: false,\n};\nexport function createCheckbox(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'checked', 'defaultChecked'));\n    const { disabled, name, required, value } = options;\n    // States\n    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked);\n    const checked = overridable(checkedWritable, withDefaults?.onCheckedChange);\n    const root = builder('checkbox', {\n        stores: [checked, disabled, required],\n        returned: ([$checked, $disabled, $required]) => {\n            return {\n                'data-disabled': $disabled,\n                'data-state': $checked === 'indeterminate' ? 'indeterminate' : $checked ? 'checked' : 'unchecked',\n                type: 'button',\n                role: 'checkbox',\n                'aria-checked': $checked === 'indeterminate' ? 'mixed' : $checked,\n                'aria-required': $required,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                // According to WAI ARIA, Checkboxes don't activate on enter keypress\n                if (e.key === kbd.ENTER)\n                    e.preventDefault();\n            }), addMeltEventListener(node, 'click', () => {\n                if (get(disabled))\n                    return;\n                checked.update((value) => {\n                    if (value === 'indeterminate')\n                        return true;\n                    return !value;\n                });\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const input = builder('checkbox-input', {\n        stores: [checked, name, value, required, disabled],\n        returned: ([$checked, $name, $value, $required, $disabled]) => {\n            return {\n                type: 'checkbox',\n                'aria-hidden': true,\n                hidden: true,\n                tabindex: -1,\n                name: $name,\n                value: $value,\n                checked: $checked === 'indeterminate' ? false : $checked,\n                required: $required,\n                disabled: $disabled,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n    });\n    const isIndeterminate = derived(checked, ($checked) => $checked === 'indeterminate');\n    const isChecked = derived(checked, ($checked) => $checked === true);\n    return {\n        elements: {\n            root,\n            input,\n        },\n        states: {\n            checked,\n        },\n        helpers: {\n            isIndeterminate,\n            isChecked,\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { derived, writable } from 'svelte/store';\nconst defaults = {\n    defaultOpen: false,\n    disabled: false,\n    forceVisible: false,\n};\nconst { name } = createElHelpers('collapsible');\nexport function createCollapsible(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'open', 'defaultOpen', 'onOpenChange'));\n    const { disabled, forceVisible } = options;\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const root = builder(name(), {\n        stores: [open, disabled],\n        returned: ([$open, $disabled]) => ({\n            'data-state': $open ? 'open' : 'closed',\n            'data-disabled': $disabled ? '' : 'undefined',\n        }),\n    });\n    const trigger = builder(name('trigger'), {\n        stores: [open, disabled],\n        returned: ([$open, $disabled]) => ({\n            'data-state': $open ? 'open' : 'closed',\n            'data-disabled': $disabled ? '' : undefined,\n            disabled: $disabled,\n        }),\n        action: (node) => {\n            const unsub = addMeltEventListener(node, 'click', () => {\n                const disabled = node.dataset.disabled !== undefined;\n                if (disabled)\n                    return;\n                open.update(($open) => !$open);\n            });\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => $open || $forceVisible);\n    const content = builder(name('content'), {\n        stores: [isVisible, disabled],\n        returned: ([$isVisible, $disabled]) => ({\n            'data-state': $isVisible ? 'open' : 'closed',\n            'data-disabled': $disabled ? '' : undefined,\n            hidden: $isVisible ? undefined : true,\n            style: styleToString({\n                display: $isVisible ? undefined : 'none',\n            }),\n        }),\n    });\n    return {\n        elements: {\n            root,\n            trigger,\n            content,\n        },\n        states: {\n            open,\n        },\n        options,\n    };\n}\n", "// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts\nimport { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction } from '../../helpers/is.js';\n/**\n * Creates a readable store that tracks the latest PointerEvent that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking pointer events.\n */\nconst documentClickStore = readable(undefined, (set) => {\n    /**\n     * Event handler for pointerdown events on the document.\n     * Updates the store's value with the latest PointerEvent and then resets it to undefined.\n     */\n    function clicked(event) {\n        set(event);\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.\n    const unsubscribe = addEventListener(document, 'pointerdown', clicked, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.\n    return unsubscribe;\n});\nexport const useClickOutside = (node, config = {}) => {\n    let options = { enabled: true, ...config };\n    // Returns true if the click outside handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle document clicks\n    const unsubscribe = documentClickStore.subscribe((e) => {\n        // If the click outside handler is disabled, or if the event is null or the node itself, return early\n        if (!isEnabled() || !e || e.target === node) {\n            return;\n        }\n        const composedPath = e.composedPath();\n        // If the target is in the node, return early\n        if (composedPath.includes(node))\n            return;\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n", "import { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction, isHTMLElement } from '../../helpers/is.js';\nimport { kbd } from '../../helpers/index.js';\n/**\n * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking keydown events.\n */\nconst documentEscapeKeyStore = readable(undefined, (set) => {\n    /**\n     * Event handler for keydown events on the document.\n     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.\n     */\n    function keydown(event) {\n        if (event && event.key === kbd.ESCAPE) {\n            set(event);\n        }\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a keydown event listener to the document, calling the keydown function when triggered.\n    const unsubscribe = addEventListener(document, 'keydown', keydown, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.\n    return unsubscribe;\n});\nexport const useEscapeKeydown = (node, config = {}) => {\n    node.dataset.escapee = '';\n    let options = { enabled: true, ...config };\n    // Returns true if the escape keydown handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle escape keydowns\n    const unsubscribe = documentEscapeKeyStore.subscribe((e) => {\n        if (!e || !isEnabled())\n            return;\n        const target = e.target;\n        if (!isHTMLElement(target) || target.closest('[data-escapee]') !== node) {\n            return;\n        }\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && target === ignoreEl;\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            node.removeAttribute('data-escapee');\n            unsubscribe();\n        },\n    };\n};\n", "const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n", "// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/floating/placement.ts\nimport { flip, offset, arrow, shift, size, computePosition, autoUpdate, } from '@floating-ui/dom';\nimport { isHTMLElement, noop } from '../../helpers/index.js';\nconst defaultConfig = {\n    strategy: 'absolute',\n    placement: 'top',\n    gutter: 5,\n    flip: true,\n    sameWidth: false,\n    overflowPadding: 8,\n};\nconst ARROW_TRANSFORM = {\n    bottom: 'rotate(45deg)',\n    left: 'rotate(135deg)',\n    top: 'rotate(225deg)',\n    right: 'rotate(315deg)',\n};\nexport function useFloating(reference, floating, opts = {}) {\n    if (!floating || !reference)\n        return {\n            destroy: noop,\n        };\n    const options = { ...defaultConfig, ...opts };\n    const arrowEl = floating.querySelector('[data-arrow=true]');\n    const middleware = [];\n    if (options.flip) {\n        middleware.push(flip({\n            boundary: options.boundary,\n            padding: options.overflowPadding,\n        }));\n    }\n    const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n    if (options.gutter || options.offset) {\n        const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n        if (data?.mainAxis != null) {\n            data.mainAxis += arrowOffset;\n        }\n        middleware.push(offset(data));\n    }\n    middleware.push(shift({\n        boundary: options.boundary,\n        crossAxis: options.overlap,\n        padding: options.overflowPadding,\n    }));\n    if (arrowEl) {\n        middleware.push(arrow({ element: arrowEl, padding: 8 }));\n    }\n    middleware.push(size({\n        padding: options.overflowPadding,\n        apply({ rects, availableHeight, availableWidth }) {\n            if (options.sameWidth) {\n                Object.assign(floating.style, {\n                    width: `${Math.round(rects.reference.width)}px`,\n                    minWidth: 'unset',\n                });\n            }\n            if (options.fitViewport) {\n                Object.assign(floating.style, {\n                    maxWidth: `${availableWidth}px`,\n                    maxHeight: `${availableHeight}px`,\n                });\n            }\n        },\n    }));\n    function compute() {\n        if (!reference || !floating)\n            return;\n        const { placement, strategy } = options;\n        computePosition(reference, floating, {\n            placement,\n            middleware,\n            strategy,\n        }).then((data) => {\n            const x = Math.round(data.x);\n            const y = Math.round(data.y);\n            Object.assign(floating.style, {\n                position: options.strategy,\n                top: `${y}px`,\n                left: `${x}px`,\n            });\n            if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {\n                const { x, y } = data.middlewareData.arrow;\n                const dir = data.placement.split('-')[0];\n                Object.assign(arrowEl.style, {\n                    position: 'absolute',\n                    left: x != null ? `${x}px` : '',\n                    top: y != null ? `${y}px` : '',\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: 'inherit',\n                    zIndex: 'inherit',\n                });\n            }\n            return data;\n        });\n    }\n    // Apply `position` to floating element prior to the computePosition() call.\n    Object.assign(floating.style, {\n        position: options.strategy,\n    });\n    return {\n        destroy: autoUpdate(reference, floating, compute),\n    };\n}\n", "// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nconst candidateSelectors = [\n  'input:not([inert])',\n  'select:not([inert])',\n  'textarea:not([inert])',\n  'a[href]:not([inert])',\n  'button:not([inert])',\n  '[tabindex]:not(slot):not([inert])',\n  'audio[controls]:not([inert])',\n  'video[controls]:not([inert])',\n  '[contenteditable]:not([contenteditable=\"false\"]):not([inert])',\n  'details>summary:first-of-type:not([inert])',\n  'details:not([inert])',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element?.getRootNode?.()\n    : (element) => element?.ownerDocument;\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nconst isInert = function (node, lookUp = true) {\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  const inertAtt = node?.getAttribute?.('inert');\n  const inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  const result = inert || (lookUp && node && isInert(node.parentNode)); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nconst isContentEditable = function (node) {\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  const attValue = node?.getAttribute?.('contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      const validShadowRoot =\n        !isInert(shadowRoot, false) &&\n        (!options.shadowRootFilter || options.shadowRootFilter(element));\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nconst hasTabIndex = function (node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nconst getTabIndex = function (node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if (\n      (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        isContentEditable(node)) &&\n      !hasTabIndex(node)\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nconst getSortOrderTabIndex = function (node, isScope) {\n  const tabIndex = getTabIndex(node);\n\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n\n  return tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nconst isNodeAttached = function (node) {\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  let nodeRoot = node && getRootNode(node);\n  let nodeRootHost = nodeRoot?.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  let attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    attached = !!(\n      nodeRootHost?.ownerDocument?.contains(nodeRootHost) ||\n      node?.ownerDocument?.contains(node)\n    );\n\n    while (!attached && nodeRootHost) {\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = nodeRoot?.host;\n      attached = !!nodeRootHost?.ownerDocument?.contains(nodeRootHost);\n    }\n  }\n\n  return attached;\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (\n    !displayCheck ||\n    displayCheck === 'full' ||\n    displayCheck === 'legacy-full'\n  ) {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    // we must do an inert look up to filter out any elements inside an inert ancestor\n    //  because we're limited in the type of selectors we can use in JSDom (see related\n    //  note related to `candidateSelectors`)\n    isInert(node) ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabIndex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scopeParent;\n    const element = isScope ? item.scopeParent : item;\n    const candidateTabindex = getSortOrderTabIndex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorTabbable.bind(null, options),\n        flatten: false,\n        getShadowRoot: options.getShadowRoot,\n        shadowRootFilter: isValidShadowRootTabbable,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorFocusable.bind(null, options),\n        flatten: true,\n        getShadowRoot: options.getShadowRoot,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable, getTabIndex };\n", "import {\n  tabbable,\n  focusable,\n  isFocusable,\n  isTabbable,\n  getTabIndex,\n} from 'tabbable';\n\nconst activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  },\n};\n\nconst isSelectableInput = function (node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\nconst isEscapeEvent = function (e) {\n  return e?.key === 'Escape' || e?.key === 'Esc' || e?.keyCode === 27;\n};\n\nconst isTabEvent = function (e) {\n  return e?.key === 'Tab' || e?.keyCode === 9;\n};\n\n// checks for TAB by default\nconst isKeyForward = function (e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nconst isKeyBackward = function (e) {\n  return isTabEvent(e) && e.shiftKey;\n};\n\nconst delay = function (fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nconst findIndex = function (arr, fn) {\n  let idx = -1;\n\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nconst valueOrHandler = function (value, ...params) {\n  return typeof value === 'function' ? value(...params) : value;\n};\n\nconst getActualTarget = function (event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function'\n    ? event.composedPath()[0]\n    : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nconst internalTrapStack = [];\n\nconst createFocusTrap = function (elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  const doc = userOptions?.document || document;\n\n  const trapStack = userOptions?.trapStack || internalTrapStack;\n\n  const config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward,\n    isKeyBackward,\n    ...userOptions,\n  };\n\n  const state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [], // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined,\n  };\n\n  let trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  const getOption = (configOverrideOptions, optionName, configOptionName) => {\n    return configOverrideOptions &&\n      configOverrideOptions[optionName] !== undefined\n      ? configOverrideOptions[optionName]\n      : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  const findContainerIndex = function (element, event) {\n    const composedPath =\n      typeof event?.composedPath === 'function'\n        ? event.composedPath()\n        : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) =>\n        container.contains(element) ||\n        // fall back to explicit tabbable search which will take into consideration any\n        //  web components if the `tabbableOptions.getShadowRoot` option was used for\n        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n        //  look inside web components even if open)\n        composedPath?.includes(container) ||\n        tabbableNodes.find((node) => node === element)\n    );\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  const getNodeForOption = function (optionName, ...params) {\n    let optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue(...params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\n        `\\`${optionName}\\` was specified but was not a node, or did not return a node`\n      );\n    }\n\n    let node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\n          `\\`${optionName}\\` as selector refers to no known node`\n        );\n      }\n    }\n\n    return node;\n  };\n\n  const getInitialFocusNode = function () {\n    let node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        const firstTabbableGroup = state.tabbableGroups[0];\n        const firstTabbableNode =\n          firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  };\n\n  const updateTabbableNodes = function () {\n    state.containerGroups = state.containers.map((container) => {\n      const tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      const focusableNodes = focusable(container, config.tabbableOptions);\n\n      const firstTabbableNode =\n        tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      const lastTabbableNode =\n        tabbableNodes.length > 0\n          ? tabbableNodes[tabbableNodes.length - 1]\n          : undefined;\n\n      const firstDomTabbableNode = focusableNodes.find((node) =>\n        isTabbable(node)\n      );\n      const lastDomTabbableNode = focusableNodes\n        .slice()\n        .reverse()\n        .find((node) => isTabbable(node));\n\n      const posTabIndexesFound = !!tabbableNodes.find(\n        (node) => getTabIndex(node) > 0\n      );\n\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound,\n\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode,\n\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode(node, forward = true) {\n          const nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes\n                .slice(focusableNodes.indexOf(node) + 1)\n                .find((el) => isTabbable(el));\n            }\n\n            return focusableNodes\n              .slice(0, focusableNodes.indexOf(node))\n              .reverse()\n              .find((el) => isTabbable(el));\n          }\n\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        },\n      };\n    });\n\n    state.tabbableGroups = state.containerGroups.filter(\n      (group) => group.tabbableNodes.length > 0\n    );\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (\n      state.tabbableGroups.length <= 0 &&\n      !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error(\n        'Your focus-trap must have at least one container with at least one tabbable node in it at all times'\n      );\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (\n      state.containerGroups.find((g) => g.posTabIndexesFound) &&\n      state.containerGroups.length > 1\n    ) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  const getActiveElement = function (el) {\n    const activeElement = el.activeElement;\n\n    if (!activeElement) {\n      return;\n    }\n\n    if (\n      activeElement.shadowRoot &&\n      activeElement.shadowRoot.activeElement !== null\n    ) {\n      return getActiveElement(activeElement.shadowRoot);\n    }\n\n    return activeElement;\n  };\n\n  const tryFocus = function (node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === getActiveElement(document)) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({ preventScroll: !!config.preventScroll });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  const getReturnFocusNode = function (previousActiveElement) {\n    const node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  const findNextNavNode = function ({ target, event, isBackward = false }) {\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n\n    let destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      const containerIndex = findContainerIndex(target, event);\n      const containerGroup =\n        containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode =\n            state.tabbableGroups[state.tabbableGroups.length - 1]\n              .lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        let startOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ firstTabbableNode }) => target === firstTabbableNode\n        );\n\n        if (\n          startOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target, config.tabbableOptions) &&\n              !isTabbable(target, config.tabbableOptions) &&\n              !containerGroup.nextTabbableNode(target, false)))\n        ) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          const destinationGroupIndex =\n            startOfGroupIndex === 0\n              ? state.tabbableGroups.length - 1\n              : startOfGroupIndex - 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n\n          destinationNode =\n            getTabIndex(target) >= 0\n              ? destinationGroup.lastTabbableNode\n              : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        let lastOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ lastTabbableNode }) => target === lastTabbableNode\n        );\n\n        if (\n          lastOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target, config.tabbableOptions) &&\n              !isTabbable(target, config.tabbableOptions) &&\n              !containerGroup.nextTabbableNode(target)))\n        ) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          const destinationGroupIndex =\n            lastOfGroupIndex === state.tabbableGroups.length - 1\n              ? 0\n              : lastOfGroupIndex + 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n\n          destinationNode =\n            getTabIndex(target) >= 0\n              ? destinationGroup.firstTabbableNode\n              : destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  const checkPointerDown = function (e) {\n    const target = getActualTarget(e);\n\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate,\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  const checkFocusIn = function (event) {\n    const target = getActualTarget(event);\n    const targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      let nextNode; // next node to focus, if we find one\n      let navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          const mruContainerIdx = findContainerIndex(\n            state.mostRecentlyFocusedNode\n          );\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          const { tabbableNodes } = state.containerGroups[mruContainerIdx];\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            const mruTabIdx = tabbableNodes.findIndex(\n              (node) => node === state.mostRecentlyFocusedNode\n            );\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (\n            !state.containerGroups.some((g) =>\n              g.tabbableNodes.some((n) => getTabIndex(n) > 0)\n            )\n          ) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent),\n        });\n      }\n\n      if (nextNode) {\n        tryFocus(nextNode);\n      } else {\n        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  const checkKeyNav = function (event, isBackward = false) {\n    state.recentNavEvent = event;\n\n    const destinationNode = findNextNavNode({ event, isBackward });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  const checkKey = function (event) {\n    if (\n      isEscapeEvent(event) &&\n      valueOrHandler(config.escapeDeactivates, event) !== false\n    ) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  const checkClick = function (e) {\n    const target = getActualTarget(e);\n\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  const addListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  };\n\n  const removeListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  const checkDomRemoval = function (mutations) {\n    const isFocusedNodeRemoved = mutations.some(function (mutation) {\n      const removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  const mutationObserver =\n    typeof window !== 'undefined' && 'MutationObserver' in window\n      ? new MutationObserver(checkDomRemoval)\n      : undefined;\n\n  const updateObservedNodes = function () {\n    if (!mutationObserver) {\n      return;\n    }\n\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true,\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      const onActivate = getOption(activateOptions, 'onActivate');\n      const onPostActivate = getOption(activateOptions, 'onPostActivate');\n      const checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      onActivate?.();\n\n      const finishActivation = () => {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate?.();\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(\n          finishActivation,\n          finishActivation\n        );\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n\n    deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      const options = {\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus,\n        ...deactivateOptions,\n      };\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n\n      const onDeactivate = getOption(options, 'onDeactivate');\n      const onPostDeactivate = getOption(options, 'onPostDeactivate');\n      const checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      const returnFocus = getOption(\n        options,\n        'returnFocus',\n        'returnFocusOnDeactivate'\n      );\n\n      onDeactivate?.();\n\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate?.();\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(\n          getReturnFocusNode(state.nodeFocusedBeforeActivation)\n        ).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n\n    pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      const onPause = getOption(pauseOptions, 'onPause');\n      const onPostPause = getOption(pauseOptions, 'onPostPause');\n\n      state.paused = true;\n      onPause?.();\n\n      removeListeners();\n      updateObservedNodes();\n\n      onPostPause?.();\n      return this;\n    },\n\n    unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      const onUnpause = getOption(unpauseOptions, 'onUnpause');\n      const onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n\n      state.paused = false;\n      onUnpause?.();\n\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n\n      onPostUnpause?.();\n      return this;\n    },\n\n    updateContainerElements(containerElements) {\n      const elementsAsArray = [].concat(containerElements).filter(Boolean);\n\n      state.containers = elementsAsArray.map((element) =>\n        typeof element === 'string' ? doc.querySelector(element) : element\n      );\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      updateObservedNodes();\n\n      return this;\n    },\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n\n  return trap;\n};\n\nexport { createFocusTrap };\n", "// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/focusTrap/focusTrap.ts\nimport { writable, readonly } from 'svelte/store';\nimport { createFocusTrap as _createFocusTrap } from 'focus-trap';\nexport function createFocusTrap(config = {}) {\n    let trap;\n    const { immediate, ...focusTrapOptions } = config;\n    const hasFocus = writable(false);\n    const isPaused = writable(false);\n    const activate = (opts) => trap?.activate(opts);\n    const deactivate = (opts) => {\n        trap?.deactivate(opts);\n    };\n    const pause = () => {\n        if (trap) {\n            trap.pause();\n            isPaused.set(true);\n        }\n    };\n    const unpause = () => {\n        if (trap) {\n            trap.unpause();\n            isPaused.set(false);\n        }\n    };\n    const useFocusTrap = (node) => {\n        trap = _createFocusTrap(node, {\n            ...focusTrapOptions,\n            onActivate() {\n                hasFocus.set(true);\n                config.onActivate?.();\n            },\n            onDeactivate() {\n                hasFocus.set(false);\n                config.onDeactivate?.();\n            },\n        });\n        if (immediate) {\n            activate();\n        }\n        return {\n            destroy() {\n                deactivate();\n                trap = undefined;\n            },\n        };\n    };\n    return {\n        useFocusTrap,\n        hasFocus: readonly(hasFocus),\n        isPaused: readonly(isPaused),\n        activate,\n        deactivate,\n        pause,\n        unpause,\n    };\n}\n", "/**\n * A special action for Melt UI's preprocessor `@melt-ui/pp`.\n *\n * @see https://www.melt-ui.com/docs/preprocessor\n *\n * @example\n * ```svelte\n * <script>\n * \tconst { builder, melt } = createBuilder();\n * </script>\n *\n * <div use:melt={$builder} />\n * ```\n */\nexport function melt(node, params) {\n    // @ts-expect-error calls the action for debugging purposes\n    return params.action(node);\n}\n", "import { createFocusTrap, useClickOutside, useEscapeKeydown, useFloating, usePortal, } from '../index.js';\nimport { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';\nconst defaultConfig = {\n    floating: {},\n    focusTrap: {},\n    clickOutside: {},\n    escapeKeydown: {},\n    portal: 'body',\n};\nexport const usePopper = (popperElement, args) => {\n    popperElement.dataset.escapee = '';\n    const { anchorElement, open, options } = args;\n    if (!anchorElement || !open || !options) {\n        return { destroy: noop };\n    }\n    const opts = { ...defaultConfig, ...options };\n    const callbacks = [];\n    if (opts.portal !== null) {\n        const portal = usePortal(popperElement, opts.portal);\n        if (portal?.destroy) {\n            callbacks.push(portal.destroy);\n        }\n    }\n    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);\n    if (opts.focusTrap !== null) {\n        const { useFocusTrap } = createFocusTrap({\n            immediate: true,\n            escapeDeactivates: false,\n            allowOutsideClick: true,\n            returnFocusOnDeactivate: false,\n            fallbackFocus: popperElement,\n            ...opts.focusTrap,\n        });\n        const usedFocusTrap = useFocusTrap(popperElement);\n        if (usedFocusTrap?.destroy) {\n            callbacks.push(usedFocusTrap.destroy);\n        }\n    }\n    if (opts.clickOutside !== null) {\n        callbacks.push(useClickOutside(popperElement, {\n            enabled: open,\n            handler: (e) => {\n                if (e.defaultPrevented)\n                    return;\n                if (isHTMLElement(anchorElement) && !anchorElement.contains(e.target)) {\n                    open.set(false);\n                    anchorElement.focus();\n                }\n            },\n            ...opts.clickOutside,\n        }).destroy);\n    }\n    if (opts.escapeKeydown !== null) {\n        callbacks.push(useEscapeKeydown(popperElement, {\n            enabled: open,\n            handler: (e) => {\n                if (e.defaultPrevented)\n                    return;\n                open.set(false);\n            },\n            ...opts.escapeKeydown,\n        }).destroy);\n    }\n    const unsubscribe = executeCallbacks(...callbacks);\n    return {\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n", "import { tick } from 'svelte';\nimport { isHTMLElement, noop } from '../helpers/index.js';\nexport const usePortal = (el, target = 'body') => {\n    let targetEl;\n    if (!isHTMLElement(target) && typeof target !== 'string') {\n        return {\n            destroy: noop,\n        };\n    }\n    async function update(newTarget) {\n        target = newTarget;\n        if (typeof target === 'string') {\n            targetEl = document.querySelector(target);\n            if (targetEl === null) {\n                await tick();\n                targetEl = document.querySelector(target);\n            }\n            if (targetEl === null) {\n                throw new Error(`No element found matching css selector: \"${target}\"`);\n            }\n        }\n        else if (target instanceof HTMLElement) {\n            targetEl = target;\n        }\n        else {\n            throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);\n        }\n        el.dataset.portal = '';\n        targetEl.appendChild(el);\n        el.hidden = false;\n    }\n    function destroy() {\n        el.remove();\n    }\n    update(target);\n    return {\n        update,\n        destroy,\n    };\n};\n", "import { addMeltEventListener, builder } from '../../internal/helpers/index.js';\nexport function createLabel() {\n    const root = builder('label', {\n        action: (node) => {\n            const mouseDown = addMeltEventListener(node, 'mousedown', (e) => {\n                if (!e.defaultPrevented && e.detail > 1) {\n                    e.preventDefault();\n                }\n            });\n            return {\n                destroy: mouseDown,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n    };\n}\n", "import { useEscapeKeydown, usePopper } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, addHighlight, addMeltEventListener, back, builder, createClickOutsideIgnore, createElHelpers, derivedVisible, effect, executeCallbacks, forward, generateId, getElementByMeltId, getOptions, getPortalDestination, isBrowser, isElementDisabled, isHTMLElement, isHTMLInputElement, kbd, last, next, noop, omit, overridable, prev, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { debounceable } from '../../internal/helpers/store/index.js';\nimport { dequal as deepEqual } from 'dequal';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, readonly, writable } from 'svelte/store';\nimport { createLabel } from '../label/create.js';\n// prettier-ignore\nexport const INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];\nconst defaults = {\n    positioning: {\n        placement: 'bottom',\n        sameWidth: true,\n    },\n    scrollAlignment: 'nearest',\n    loop: true,\n    defaultOpen: false,\n    closeOnOutsideClick: true,\n    preventScroll: true,\n    closeOnEscape: true,\n    forceVisible: false,\n    portal: undefined,\n    filterFunction: () => true,\n    debounce: 0,\n};\nconst { name, selector } = createElHelpers('combobox');\n/**\n * Creates an ARIA-1.2-compliant combobox.\n *\n * @TODO expose a nice mechanism for clearing the input.\n * @TODO would it be useful to have a callback for when an item is selected?\n * @TODO multi-select using `tags-input` builder?\n */\nexport function createCombobox(props) {\n    const withDefaults = { ...defaults, ...props };\n    // Trigger element for the popper portal. This will be our input element.\n    const activeTrigger = writable(null);\n    // The currently highlighted menu item.\n    const highlightedItem = writable(null);\n    const selectedWritable = withDefaults.selected ??\n        writable(withDefaults.defaultSelected);\n    const selected = overridable(selectedWritable, withDefaults?.onSelectedChange);\n    const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : undefined);\n    // The current value of the input element.\n    const inputValue = debounceable(withDefaults.defaultSelected?.label ?? '', withDefaults.debounce);\n    // Either the provided open store or a store with the default open value\n    const openWritable = withDefaults.open ?? writable(false);\n    // The overridable open store which is the source of truth for the open state.\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const isEmpty = writable(false);\n    const options = toWritableStores(omit(withDefaults, 'open', 'defaultOpen', 'debounce'));\n    const { scrollAlignment, loop, filterFunction, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning, } = options;\n    const touchedInput = debounceable(false, withDefaults.debounce);\n    const ids = {\n        input: generateId(),\n        menu: generateId(),\n        label: generateId(),\n    };\n    /** ------- */\n    /** HELPERS */\n    /** ------- */\n    function getOptionProps(el) {\n        const value = el.getAttribute('data-value');\n        const label = el.getAttribute('data-label');\n        const disabled = el.hasAttribute('data-disabled');\n        return {\n            value: value ? JSON.parse(value) : value,\n            label: label ?? el.textContent ?? undefined,\n            disabled: disabled ? true : false,\n        };\n    }\n    /** Resets the combobox inputValue and filteredItems back to the selectedItem */\n    function reset() {\n        const $selectedItem = get(selected);\n        // If no item is selected the input should be cleared and the filter reset.\n        if (!$selectedItem) {\n            inputValue.set('');\n        }\n        else {\n            inputValue.set(get(selected)?.label ?? '');\n        }\n        touchedInput.set(false);\n    }\n    /**\n     * Selects an item from the menu and updates the input value.\n     * @param index array index of the item to select.\n     */\n    function selectItem(item) {\n        const props = getOptionProps(item);\n        selected.set(props);\n        const activeTrigger = getElementByMeltId(ids.input);\n        if (activeTrigger) {\n            activeTrigger.focus();\n        }\n    }\n    async function handleIsEmpty() {\n        if (!isBrowser)\n            return;\n        await tick();\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        const options = getOptions(menuElement);\n        const visibleOptions = options.filter((opt) => {\n            const isHidden = opt.dataset.hidden !== undefined;\n            return !isHidden;\n        });\n        if (!visibleOptions.length) {\n            isEmpty.set(true);\n        }\n        else {\n            isEmpty.set(false);\n        }\n    }\n    /**\n     * Opens the menu, sets the active trigger, and highlights\n     * the selected item (if one exists). It also optionally accepts the current\n     * open state to prevent unnecessary updates if we know the menu is already open.\n     */\n    async function openMenu(currentOpenState = false) {\n        /**\n         * We're checking the open state here because the menu may have\n         * been programatically opened by the user using a controlled store.\n         * In that case we don't want to update the open state, but we do\n         * want to update the active trigger and highlighted item as normal.\n         */\n        if (!currentOpenState) {\n            open.set(true);\n        }\n        const triggerEl = getElementByMeltId(ids.input);\n        if (!triggerEl)\n            return;\n        // The active trigger is used to anchor the menu to the input element.\n        activeTrigger.set(triggerEl);\n        // Wait a tick for the menu to open then highlight the selected item.\n        await tick();\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        const selectedItem = menuElement.querySelector('[aria-selected=true]');\n        if (!isHTMLElement(selectedItem))\n            return;\n        highlightedItem.set(selectedItem);\n    }\n    /** Closes the menu & clears the active trigger */\n    function closeMenu() {\n        open.set(false);\n        touchedInput.set(false);\n    }\n    /**\n     * To properly anchor the popper to the input/trigger, we need to ensure both\n     * the open state is true and the activeTrigger is not null. This helper store's\n     * value is true when both of these conditions are met and keeps the code tidy.\n     */\n    const isVisible = derivedVisible({ open, forceVisible, activeTrigger });\n    /**\n     * Determines if a given item is selected.\n     * This is useful for displaying additional markup on the selected item.\n     */\n    const isSelected = derived([selected], ([$value]) => {\n        return (item) => deepEqual($value?.value, item);\n    });\n    /**\n     * Determines if a given item is highlighted.\n     * This is useful for displaying additional markup on the highlighted item.\n     */\n    const isHighlighted = derived([highlighted], ([$value]) => {\n        return (item) => {\n            return deepEqual($value?.value, item);\n        };\n    });\n    /** -------- */\n    /** ELEMENTS */\n    /** -------- */\n    /** Action and attributes for the text input. */\n    const input = builder(name('input'), {\n        stores: [open, highlightedItem, inputValue],\n        returned: ([$open, $highlightedItem, $inputValue]) => {\n            return {\n                'aria-activedescendant': $highlightedItem?.id,\n                'aria-autocomplete': 'list',\n                'aria-controls': ids.menu,\n                'aria-expanded': $open,\n                'aria-labelledby': ids.label,\n                'data-melt-id': ids.input,\n                autocomplete: 'off',\n                id: ids.input,\n                role: 'combobox',\n                value: $inputValue.value,\n            };\n        },\n        action: (node) => {\n            const unsubscribe = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const $open = get(open);\n                if ($open) {\n                    return;\n                }\n                openMenu($open);\n            }), \n            // Handle all input key events including typing, meta, and navigation.\n            addMeltEventListener(node, 'keydown', (e) => {\n                const $open = get(open);\n                /**\n                 * When the menu is closed...\n                 */\n                if (!$open) {\n                    // Pressing one of the interaction keys shouldn't open the menu.\n                    if (INTERACTION_KEYS.includes(e.key)) {\n                        return;\n                    }\n                    // Tab should not open the menu.\n                    if (e.key === kbd.TAB) {\n                        return;\n                    }\n                    // Pressing backspace when the input is blank shouldn't open the menu.\n                    if (e.key === kbd.BACKSPACE && node.value === '') {\n                        return;\n                    }\n                    // All other events should open the menu.\n                    openMenu($open);\n                    tick().then(() => {\n                        const $selectedItem = get(selected);\n                        if ($selectedItem)\n                            return;\n                        const menuEl = document.getElementById(ids.menu);\n                        if (!isHTMLElement(menuEl))\n                            return;\n                        const enabledItems = Array.from(menuEl.querySelectorAll(`${selector('item')}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));\n                        if (!enabledItems.length)\n                            return;\n                        if (e.key === kbd.ARROW_DOWN) {\n                            highlightedItem.set(enabledItems[0]);\n                        }\n                        else if (e.key === kbd.ARROW_UP) {\n                            highlightedItem.set(last(enabledItems));\n                        }\n                    });\n                }\n                /**\n                 * When the menu is open...\n                 */\n                // Pressing `esc` should close the menu.\n                if (e.key === kbd.TAB || e.key === kbd.ESCAPE) {\n                    closeMenu();\n                    reset();\n                    return;\n                }\n                // Pressing enter with a highlighted item should select it.\n                if (e.key === kbd.ENTER) {\n                    const $highlightedItem = get(highlightedItem);\n                    if ($highlightedItem) {\n                        selectItem($highlightedItem);\n                    }\n                    closeMenu();\n                }\n                // Pressing Alt + Up should close the menu.\n                if (e.key === kbd.ARROW_UP && e.altKey) {\n                    closeMenu();\n                    reset();\n                }\n                // Navigation (up, down, etc.) should change the highlighted item.\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    e.preventDefault();\n                    // Get all the menu items.\n                    const menuElement = document.getElementById(ids.menu);\n                    if (!isHTMLElement(menuElement))\n                        return;\n                    const itemElements = getOptions(menuElement);\n                    if (!itemElements.length)\n                        return;\n                    // Disabled items can't be highlighted. Skip them.\n                    const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === undefined);\n                    // Get the index of the currently highlighted item.\n                    const $currentItem = get(highlightedItem);\n                    const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;\n                    // Find the next menu item to highlight.\n                    const $loop = get(loop);\n                    const $scrollAlignment = get(scrollAlignment);\n                    let nextItem;\n                    switch (e.key) {\n                        case kbd.ARROW_DOWN:\n                            nextItem = next(candidateNodes, currentIndex, $loop);\n                            break;\n                        case kbd.ARROW_UP:\n                            nextItem = prev(candidateNodes, currentIndex, $loop);\n                            break;\n                        case kbd.PAGE_DOWN:\n                            nextItem = forward(candidateNodes, currentIndex, 10, $loop);\n                            break;\n                        case kbd.PAGE_UP:\n                            nextItem = back(candidateNodes, currentIndex, 10, $loop);\n                            break;\n                        case kbd.HOME:\n                            nextItem = candidateNodes[0];\n                            break;\n                        case kbd.END:\n                            nextItem = last(candidateNodes);\n                            break;\n                        default:\n                            return;\n                    }\n                    // Highlight the new item and scroll it into view.\n                    highlightedItem.set(nextItem);\n                    nextItem.scrollIntoView({ block: $scrollAlignment });\n                }\n            }), \n            // Listens to the input value and filters the items accordingly.\n            addMeltEventListener(node, 'input', (e) => {\n                if (!isHTMLInputElement(e.target))\n                    return;\n                const value = e.target.value;\n                inputValue.debouncedSet(value);\n                touchedInput.debouncedSet(true);\n                tick().then(() => {\n                    const $highlightedItem = get(highlightedItem);\n                    if ($highlightedItem?.dataset.hidden) {\n                        // Find next visible item\n                        const menuElement = document.getElementById(ids.menu);\n                        if (!isHTMLElement(menuElement))\n                            return;\n                        const itemElements = getOptions(menuElement);\n                        const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && !opt.dataset.hidden);\n                        highlightedItem.set(candidateNodes[0] ?? null);\n                    }\n                });\n            }));\n            let unsubEscapeKeydown = noop;\n            const escape = useEscapeKeydown(node, {\n                handler: () => {\n                    closeMenu();\n                    reset();\n                },\n            });\n            if (escape && escape.destroy) {\n                unsubEscapeKeydown = escape.destroy;\n            }\n            return {\n                destroy() {\n                    unsubscribe();\n                    unsubEscapeKeydown();\n                },\n            };\n        },\n    });\n    /**\n     * Action and attributes for the menu element.\n     */\n    const menu = builder(name('menu'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                id: ids.menu,\n                role: 'listbox',\n                style: styleToString({ display: $isVisible ? undefined : 'none' }),\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            let unsubScroll = noop;\n            const unsubscribe = executeCallbacks(\n            //  Bind the popper portal to the input element.\n            effect([\n                isVisible,\n                preventScroll,\n                closeOnEscape,\n                portal,\n                closeOnOutsideClick,\n                positioning,\n                activeTrigger,\n            ], ([$isVisible, $preventScroll, $closeOnEscape, $portal, $closeOnOutsideClick, $positioning, $activeTrigger,]) => {\n                unsubPopper();\n                unsubScroll();\n                if (!$isVisible || !$activeTrigger)\n                    return;\n                if ($preventScroll) {\n                    unsubScroll = removeScroll();\n                }\n                const ignoreHandler = createClickOutsideIgnore(ids.input);\n                const popper = usePopper(node, {\n                    anchorElement: $activeTrigger,\n                    open,\n                    options: {\n                        floating: $positioning,\n                        focusTrap: null,\n                        clickOutside: $closeOnOutsideClick\n                            ? {\n                                handler: (e) => {\n                                    const target = e.target;\n                                    if (target === $activeTrigger)\n                                        return;\n                                    closeMenu();\n                                    reset();\n                                },\n                                ignore: ignoreHandler,\n                            }\n                            : null,\n                        escapeKeydown: $closeOnEscape\n                            ? {\n                                handler: () => {\n                                    closeMenu();\n                                    reset();\n                                },\n                            }\n                            : null,\n                        portal: getPortalDestination(node, $portal),\n                    },\n                });\n                if (popper && popper.destroy) {\n                    unsubPopper = popper.destroy;\n                }\n            }), \n            // Remove highlight when the pointer leaves the menu.\n            addMeltEventListener(node, 'pointerleave', () => {\n                highlightedItem.set(null);\n            }));\n            return {\n                destroy: () => {\n                    unsubscribe();\n                    unsubPopper();\n                    unsubScroll();\n                },\n            };\n        },\n    });\n    // Use our existing label builder to create a label for the combobox input.\n    const { elements: { root: labelBuilder }, } = createLabel();\n    const { action: labelAction } = get(labelBuilder);\n    const label = builder(name('label'), {\n        returned: () => {\n            return {\n                id: ids.label,\n                for: ids.input,\n            };\n        },\n        action: labelAction,\n    });\n    const option = builder(name('option'), {\n        stores: [selected, filterFunction, inputValue, touchedInput],\n        returned: ([$value, $filterFunction, $inputValue, $touchedInput]) => (props) => {\n            let hidden = false;\n            if ($touchedInput.debounced &&\n                $filterFunction?.({ input: $inputValue.debounced, itemValue: props.value }) === false) {\n                hidden = true;\n            }\n            const selected = deepEqual(props.value, $value);\n            return {\n                'data-value': JSON.stringify(props.value),\n                'data-label': props.label,\n                'data-disabled': props.disabled ? '' : undefined,\n                'aria-disabled': props.disabled ? true : undefined,\n                'aria-selected': selected,\n                'data-selected': selected ? '' : undefined,\n                hidden: hidden ? true : undefined,\n                'data-hidden': hidden ? '' : undefined,\n                id: generateId(),\n                role: 'option',\n                style: styleToString({ cursor: props.disabled ? 'default' : 'pointer' }),\n            };\n        },\n        action: (node) => {\n            const unsubscribe = executeCallbacks(\n            // Handle highlighting items when the pointer moves over them.\n            addMeltEventListener(node, 'pointermove', () => {\n                // If the item is disabled, clear the highlight.\n                if (isElementDisabled(node)) {\n                    highlightedItem.set(null);\n                    return;\n                }\n                // Otherwise, proceed.\n                highlightedItem.set(node);\n            }), addMeltEventListener(node, 'click', (e) => {\n                // If the item is disabled, `preventDefault` to stop the input losing focus.\n                if (isElementDisabled(node)) {\n                    e.preventDefault();\n                    return;\n                }\n                // Otherwise, select the item and close the menu.\n                selectItem(node);\n                closeMenu();\n            }));\n            return { destroy: unsubscribe };\n        },\n    });\n    /** ------------------- */\n    /** LIFECYCLE & EFFECTS */\n    /** ------------------- */\n    onMount(() => {\n        open.set(withDefaults.defaultOpen);\n        if (!isBrowser)\n            return;\n        const menuEl = document.getElementById(ids.menu);\n        if (!menuEl)\n            return;\n        const triggerEl = getElementByMeltId(ids.input);\n        if (triggerEl) {\n            activeTrigger.set(triggerEl);\n        }\n        const selectedEl = menuEl.querySelector('[data-selected]');\n        if (!isHTMLElement(selectedEl))\n            return;\n        const dataLabel = selectedEl.getAttribute('data-label');\n        inputValue.debouncedSet(dataLabel ?? selectedEl.textContent ?? '');\n    });\n    effect(selected, function setInputValue($selected) {\n        inputValue.debouncedSet($selected?.label ?? '');\n    });\n    /**\n     * Handles moving the `data-highlighted` attribute between items when\n     * the user moves their pointer or navigates with their keyboard.\n     */\n    effect([highlightedItem, scrollAlignment], ([$highlightedItem, $scrollAlignment]) => {\n        if (!isBrowser)\n            return;\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        getOptions(menuElement).forEach((node) => {\n            if (node === $highlightedItem) {\n                addHighlight(node);\n            }\n            else {\n                removeHighlight(node);\n            }\n        });\n        if ($highlightedItem) {\n            sleep(1).then(() => $highlightedItem.scrollIntoView({ block: $scrollAlignment }));\n        }\n    });\n    effect([inputValue, touchedInput], () => {\n        handleIsEmpty();\n    });\n    return {\n        elements: {\n            input,\n            option,\n            menu,\n            label,\n        },\n        states: {\n            open,\n            selected,\n            highlighted,\n            inputValue,\n            isEmpty: readonly(isEmpty),\n        },\n        helpers: {\n            isSelected,\n            isHighlighted,\n        },\n        options,\n    };\n}\n", "import { createSeparator } from '../index.js';\nimport { usePopper } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, SELECTION_KEYS, addEventListener, addHighlight, addMeltEventListener, builder, createElHelpers, createTypeaheadSearch, derivedVisible, derivedWithUnsubscribe, effect, executeCallbacks, generateId, getNextFocusable, getPortalDestination, getPreviousFocusable, handleRovingFocus, isBrowser, isElementDisabled, isHTMLElement, kbd, noop, overridable, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nexport const SUB_OPEN_KEYS = {\n    ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],\n    rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT],\n};\nexport const SUB_CLOSE_KEYS = {\n    ltr: [kbd.ARROW_LEFT],\n    rtl: [kbd.ARROW_RIGHT],\n};\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: 'body',\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    typeahead: true,\n};\nexport function createMenuBuilder(opts) {\n    const { name, selector } = createElHelpers(opts.selector);\n    const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, } = opts.rootOptions;\n    const rootOpen = opts.rootOpen;\n    const rootActiveTrigger = opts.rootActiveTrigger;\n    /**\n     * Keeps track of the next/previous focusable element when the menu closes.\n     * This is because we are portaling the menu to the body and we need\n     * to be able to focus the next element in the DOM when the menu closes.\n     *\n     * Without keeping track of this, the focus would be reset to the top of\n     * the page (or the first focusable element in the body).\n     */\n    const nextFocusable = opts.nextFocusable;\n    const prevFocusable = opts.prevFocusable;\n    /**\n     * Keeps track of if the user is using the keyboard to navigate the menu.\n     * This is used to determine how we handle focus on open behavior differently\n     * than when the user is using the mouse.\n     */\n    const isUsingKeyboard = writable(false);\n    /**\n     * Stores used to manage the grace area for submenus. This prevents us\n     * from closing a submenu when the user is moving their mouse from the\n     * trigger to the submenu.\n     */\n    const lastPointerX = writable(0);\n    const pointerGraceIntent = writable(null);\n    const pointerDir = writable('right');\n    /**\n     * Track currently focused item in the menu.\n     */\n    const currentFocusedItem = writable(null);\n    const pointerMovingToSubmenu = derivedWithUnsubscribe([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {\n        return (e) => {\n            const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;\n            return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent?.area);\n        };\n    });\n    const { typed, handleTypeaheadSearch } = createTypeaheadSearch();\n    const rootIds = {\n        menu: generateId(),\n        trigger: generateId(),\n    };\n    const isVisible = derivedVisible({\n        open: rootOpen,\n        forceVisible,\n        activeTrigger: rootActiveTrigger,\n    });\n    const rootMenu = builder(name(), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            return {\n                role: 'menu',\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: rootIds.menu,\n                'aria-labelledby': rootIds.trigger,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': $portal ? '' : undefined,\n                tabindex: -1,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape,]) => {\n                unsubPopper();\n                if (!$isVisible || !$rootActiveTrigger)\n                    return;\n                tick().then(() => {\n                    setMeltMenuAttribute(node, selector);\n                    const popper = usePopper(node, {\n                        anchorElement: $rootActiveTrigger,\n                        open: rootOpen,\n                        options: {\n                            floating: $positioning,\n                            clickOutside: $closeOnOutsideClick ? undefined : null,\n                            portal: getPortalDestination(node, $portal),\n                            escapeKeydown: $closeOnEscape ? undefined : null,\n                        },\n                    });\n                    if (popper && popper.destroy) {\n                        unsubPopper = popper.destroy;\n                    }\n                });\n            });\n            const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const target = e.target;\n                const menuEl = e.currentTarget;\n                if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                    return;\n                /**\n                 * Submenu key events bubble through portals and\n                 * we only care about key events that happen inside this menu.\n                 */\n                const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                if (!isKeyDownInside)\n                    return;\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    handleMenuNavigation(e);\n                }\n                /**\n                 * Menus should not be navigated using tab\n                 * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                 */\n                if (e.key === kbd.TAB) {\n                    e.preventDefault();\n                    rootOpen.set(false);\n                    handleTabNavigation(e, nextFocusable, prevFocusable);\n                    return;\n                }\n                /**\n                 * Check for typeahead search and handle it.\n                 */\n                const isCharacterKey = e.key.length === 1;\n                const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                if (!isModifierKey && isCharacterKey && get(typeahead) === true) {\n                    handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                }\n            }));\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubEvents();\n                    unsubPopper();\n                },\n            };\n        },\n    });\n    const rootTrigger = builder(name('trigger'), {\n        stores: [rootOpen],\n        returned: ([$rootOpen]) => {\n            return {\n                'aria-controls': rootIds.menu,\n                'aria-expanded': $rootOpen,\n                'data-state': $rootOpen ? 'open' : 'closed',\n                id: rootIds.trigger,\n                tabindex: 0,\n            };\n        },\n        action: (node) => {\n            applyAttrsIfDisabled(node);\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                const $rootOpen = get(rootOpen);\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                handleOpen(triggerEl);\n                if (!$rootOpen)\n                    e.preventDefault();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))\n                    return;\n                e.preventDefault();\n                handleOpen(triggerEl);\n                const menuId = triggerEl.getAttribute('aria-controls');\n                if (!menuId)\n                    return;\n                const menu = document.getElementById(menuId);\n                if (!menu)\n                    return;\n                const menuItems = getMenuItems(menu);\n                if (!menuItems.length)\n                    return;\n                handleRovingFocus(menuItems[0]);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const rootArrow = builder(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    const item = builder(name('item'), {\n        returned: () => {\n            return {\n                role: 'menuitem',\n                tabindex: -1,\n                'data-orientation': 'vertical',\n            };\n        },\n        action: (node) => {\n            setMeltMenuAttribute(node, selector);\n            applyAttrsIfDisabled(node);\n            const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n            }), addMeltEventListener(node, 'click', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n                if (e.defaultPrevented) {\n                    handleRovingFocus(itemEl);\n                    return;\n                }\n                // Allows forms to submit before the menu is removed from the DOM\n                sleep(1).then(() => {\n                    rootOpen.set(false);\n                });\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                onItemKeyDown(e);\n            }), addMeltEventListener(node, 'pointermove', (e) => {\n                onMenuItemPointerMove(e);\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                onMenuItemPointerLeave(e);\n            }), addMeltEventListener(node, 'focusin', (e) => {\n                onItemFocusIn(e);\n            }), addMeltEventListener(node, 'focusout', (e) => {\n                onItemFocusOut(e);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const group = builder(name('group'), {\n        returned: () => {\n            return (groupId) => ({\n                role: 'group',\n                'aria-labelledby': groupId,\n            });\n        },\n    });\n    const groupLabel = builder(name('group-label'), {\n        returned: () => {\n            return (groupId) => ({\n                id: groupId,\n            });\n        },\n    });\n    const checkboxItemDefaults = {\n        defaultChecked: false,\n        disabled: false,\n    };\n    const createCheckboxItem = (props) => {\n        const withDefaults = { ...checkboxItemDefaults, ...props };\n        const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);\n        const checked = overridable(checkedWritable, withDefaults.onCheckedChange);\n        const disabled = writable(withDefaults.disabled);\n        const checkboxItem = builder(name('checkbox-item'), {\n            stores: [checked, disabled],\n            returned: ([$checked, $disabled]) => {\n                return {\n                    role: 'menuitemcheckbox',\n                    tabindex: -1,\n                    'data-orientation': 'vertical',\n                    'aria-checked': isIndeterminate($checked) ? 'mixed' : $checked ? 'true' : 'false',\n                    'data-disabled': $disabled ? '' : undefined,\n                    'data-state': getCheckedState($checked),\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    checked.update((prev) => {\n                        if (isIndeterminate(prev))\n                            return true;\n                        return !prev;\n                    });\n                    // We're waiting for a tick to let the checked store update\n                    // before closing the menu. If we don't, and the user was to hit\n                    // spacebar or enter twice really fast, the menu would close and\n                    // reopen without the checked state being updated.\n                    tick().then(() => {\n                        rootOpen.set(false);\n                    });\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        return {\n            elements: {\n                checkboxItem,\n            },\n            states: {\n                checked,\n            },\n            options: {\n                disabled,\n            },\n        };\n    };\n    const createMenuRadioGroup = (args = {}) => {\n        const valueWritable = args.value ?? writable(args.defaultValue ?? null);\n        const value = overridable(valueWritable, args.onValueChange);\n        const radioGroup = builder(name('radio-group'), {\n            returned: () => ({\n                role: 'group',\n            }),\n        });\n        const radioItemDefaults = {\n            disabled: false,\n        };\n        const radioItem = builder(name('radio-item'), {\n            stores: [value],\n            returned: ([$value]) => {\n                return (itemProps) => {\n                    const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };\n                    const checked = $value === itemValue;\n                    return {\n                        disabled,\n                        role: 'menuitemradio',\n                        'data-state': checked ? 'checked' : 'unchecked',\n                        'aria-checked': checked,\n                        'data-disabled': disabled ? '' : undefined,\n                        'data-value': itemValue,\n                        'data-orientation': 'vertical',\n                        tabindex: -1,\n                    };\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        if (!isHTMLElement(itemEl))\n                            return;\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    value.set(itemValue);\n                    // We're waiting for a tick to let the checked store update\n                    // before closing the menu. If we don't, and the user was to hit\n                    // spacebar or enter twice really fast, the menu would close and\n                    // reopen without the checked state being updated.\n                    tick().then(() => {\n                        rootOpen.set(false);\n                    });\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isChecked = derived(value, ($value) => {\n            return (itemValue) => {\n                return $value === itemValue;\n            };\n        });\n        return {\n            elements: {\n                radioGroup,\n                radioItem,\n            },\n            states: {\n                value,\n            },\n            helpers: {\n                isChecked,\n            },\n        };\n    };\n    const { elements: { root: separator }, } = createSeparator({\n        orientation: 'horizontal',\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * SUBMENU\n     * -----------------------------------------------------------------------------------------------*/\n    const subMenuDefaults = {\n        ...defaults,\n        disabled: false,\n        positioning: {\n            placement: 'right-start',\n            gutter: 8,\n        },\n    };\n    const createSubmenu = (args) => {\n        const withDefaults = { ...subMenuDefaults, ...args };\n        const subOpen = writable(false);\n        // options\n        const options = toWritableStores(withDefaults);\n        const { positioning, arrowSize, disabled } = options;\n        const subActiveTrigger = writable(null);\n        const subOpenTimer = writable(null);\n        const pointerGraceTimer = writable(0);\n        const subIds = {\n            menu: generateId(),\n            trigger: generateId(),\n        };\n        onMount(() => {\n            /**\n             * Set active trigger on mount to handle controlled/forceVisible\n             * state.\n             */\n            const subTrigger = document.getElementById(subIds.trigger);\n            if (subTrigger) {\n                subActiveTrigger.set(subTrigger);\n            }\n        });\n        const subIsVisible = derivedVisible({\n            open: subOpen,\n            forceVisible,\n            activeTrigger: subActiveTrigger,\n        });\n        const subMenu = builder(name('submenu'), {\n            stores: [subIsVisible],\n            returned: ([$subIsVisible]) => {\n                return {\n                    role: 'menu',\n                    hidden: $subIsVisible ? undefined : true,\n                    style: styleToString({\n                        display: $subIsVisible ? undefined : 'none',\n                    }),\n                    id: subIds.menu,\n                    'aria-labelledby': subIds.trigger,\n                    'data-state': $subIsVisible ? 'open' : 'closed',\n                    tabindex: -1,\n                };\n            },\n            action: (node) => {\n                let unsubPopper = noop;\n                const unsubDerived = effect([subIsVisible, positioning], ([$subIsVisible, $positioning]) => {\n                    unsubPopper();\n                    if (!$subIsVisible)\n                        return;\n                    const activeTrigger = get(subActiveTrigger);\n                    if (!activeTrigger)\n                        return;\n                    tick().then(() => {\n                        const parentMenuEl = getParentMenu(activeTrigger);\n                        const popper = usePopper(node, {\n                            anchorElement: activeTrigger,\n                            open: subOpen,\n                            options: {\n                                floating: $positioning,\n                                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : undefined,\n                                clickOutside: null,\n                                focusTrap: null,\n                            },\n                        });\n                        if (popper && popper.destroy) {\n                            unsubPopper = popper.destroy;\n                        }\n                    });\n                });\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                    if (e.key === kbd.ESCAPE) {\n                        return;\n                    }\n                    // Submenu key events bubble through portals.\n                    // We only want the keys in this menu.\n                    const target = e.target;\n                    const menuEl = e.currentTarget;\n                    if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                        return;\n                    const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                    if (!isKeyDownInside)\n                        return;\n                    if (FIRST_LAST_KEYS.includes(e.key)) {\n                        // prevent events from bubbling\n                        e.stopImmediatePropagation();\n                        handleMenuNavigation(e);\n                        return;\n                    }\n                    const isCloseKey = SUB_CLOSE_KEYS['ltr'].includes(e.key);\n                    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                    const isCharacterKey = e.key.length === 1;\n                    // close the submenu if the user presses a close key\n                    if (isCloseKey) {\n                        const $subActiveTrigger = get(subActiveTrigger);\n                        e.preventDefault();\n                        subOpen.update(() => {\n                            if ($subActiveTrigger) {\n                                handleRovingFocus($subActiveTrigger);\n                            }\n                            return false;\n                        });\n                        return;\n                    }\n                    /**\n                     * Menus should not be navigated using tab, so we prevent it.\n                     * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                     */\n                    if (e.key === kbd.TAB) {\n                        e.preventDefault();\n                        rootOpen.set(false);\n                        handleTabNavigation(e, nextFocusable, prevFocusable);\n                        return;\n                    }\n                    if (!isModifierKey && isCharacterKey && get(typeahead) === true) {\n                        // typeahead logic\n                        handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    onMenuPointerMove(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const $subActiveTrigger = get(subActiveTrigger);\n                    if (get(isUsingKeyboard)) {\n                        const target = e.target;\n                        const submenuEl = document.getElementById(subIds.menu);\n                        if (!isHTMLElement(submenuEl) || !isHTMLElement(target))\n                            return;\n                        if (!submenuEl.contains(target) && target !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                    else {\n                        const menuEl = e.currentTarget;\n                        const relatedTarget = e.relatedTarget;\n                        if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))\n                            return;\n                        if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                }));\n                return {\n                    destroy() {\n                        unsubDerived();\n                        unsubPopper();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subTrigger = builder(name('subtrigger'), {\n            stores: [subOpen, disabled],\n            returned: ([$subOpen, $disabled]) => {\n                return {\n                    role: 'menuitem',\n                    id: subIds.trigger,\n                    tabindex: -1,\n                    'aria-controls': subIds.menu,\n                    'aria-expanded': $subOpen,\n                    'data-state': $subOpen ? 'open' : 'closed',\n                    'data-disabled': $disabled ? '' : undefined,\n                    'aria-haspopop': 'menu',\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                const unsubTimer = () => {\n                    clearTimerStore(subOpenTimer);\n                    window.clearTimeout(get(pointerGraceTimer));\n                    pointerGraceIntent.set(null);\n                };\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    // Manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n                    handleRovingFocus(triggerEl);\n                    if (!get(subOpen)) {\n                        subOpen.update((prev) => {\n                            const isAlreadyOpen = prev;\n                            if (!isAlreadyOpen) {\n                                subActiveTrigger.set(triggerEl);\n                                return !prev;\n                            }\n                            return prev;\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    const $typed = get(typed);\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    const isTypingAhead = $typed.length > 0;\n                    if (isTypingAhead && e.key === kbd.SPACE)\n                        return;\n                    if (SUB_OPEN_KEYS['ltr'].includes(e.key)) {\n                        if (!get(subOpen)) {\n                            triggerEl.click();\n                            e.preventDefault();\n                            return;\n                        }\n                        const menuId = triggerEl.getAttribute('aria-controls');\n                        if (!menuId)\n                            return;\n                        const menuEl = document.getElementById(menuId);\n                        if (!isHTMLElement(menuEl))\n                            return;\n                        const firstItem = getMenuItems(menuEl)[0];\n                        handleRovingFocus(firstItem);\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    onItemEnter(e);\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    handleRovingFocus(triggerEl);\n                    const openTimer = get(subOpenTimer);\n                    if (!get(subOpen) && !openTimer && !isElementDisabled(triggerEl)) {\n                        subOpenTimer.set(window.setTimeout(() => {\n                            subOpen.update(() => {\n                                subActiveTrigger.set(triggerEl);\n                                return true;\n                            });\n                            clearTimerStore(subOpenTimer);\n                        }, 100));\n                    }\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    clearTimerStore(subOpenTimer);\n                    const submenuEl = document.getElementById(subIds.menu);\n                    const contentRect = submenuEl?.getBoundingClientRect();\n                    if (contentRect) {\n                        const side = submenuEl?.dataset.side;\n                        const rightSide = side === 'right';\n                        const bleed = rightSide ? -5 : +5;\n                        const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                        const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n                        pointerGraceIntent.set({\n                            area: [\n                                // Apply a bleed on clientX to ensure that our exit point is\n                                // consistently within polygon bounds\n                                { x: e.clientX + bleed, y: e.clientY },\n                                { x: contentNearEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.bottom },\n                                { x: contentNearEdge, y: contentRect.bottom },\n                            ],\n                            side,\n                        });\n                        window.clearTimeout(get(pointerGraceTimer));\n                        pointerGraceTimer.set(window.setTimeout(() => {\n                            pointerGraceIntent.set(null);\n                        }, 300));\n                    }\n                    else {\n                        onTriggerLeave(e);\n                        if (e.defaultPrevented)\n                            return;\n                        // There's 100ms where the user may leave an item before the submenu was opened.\n                        pointerGraceIntent.set(null);\n                    }\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    removeHighlight(triggerEl);\n                    const relatedTarget = e.relatedTarget;\n                    if (!isHTMLElement(relatedTarget))\n                        return;\n                    const menuId = triggerEl.getAttribute('aria-controls');\n                    if (!menuId)\n                        return;\n                    const menu = document.getElementById(menuId);\n                    if (menu && !menu.contains(relatedTarget)) {\n                        subOpen.set(false);\n                    }\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }));\n                return {\n                    destroy() {\n                        unsubTimer();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subArrow = builder(name('subarrow'), {\n            stores: arrowSize,\n            returned: ($arrowSize) => ({\n                'data-arrow': true,\n                style: styleToString({\n                    position: 'absolute',\n                    width: `var(--arrow-size, ${$arrowSize}px)`,\n                    height: `var(--arrow-size, ${$arrowSize}px)`,\n                }),\n            }),\n        });\n        /* -------------------------------------------------------------------------------------------------\n         * Sub Menu Effects\n         * -----------------------------------------------------------------------------------------------*/\n        effect([rootOpen], ([$rootOpen]) => {\n            if (!$rootOpen) {\n                subActiveTrigger.set(null);\n                subOpen.set(false);\n            }\n        });\n        effect([pointerGraceIntent], ([$pointerGraceIntent]) => {\n            if (!isBrowser || $pointerGraceIntent)\n                return;\n            window.clearTimeout(get(pointerGraceTimer));\n        });\n        effect([subOpen], ([$subOpen]) => {\n            if (!isBrowser)\n                return;\n            sleep(1).then(() => {\n                const menuEl = document.getElementById(subIds.menu);\n                if (!menuEl)\n                    return;\n                if ($subOpen && get(isUsingKeyboard)) {\n                    // Selector to get menu items belonging to menu\n                    const menuItems = getMenuItems(menuEl);\n                    if (!menuItems.length)\n                        return;\n                    handleRovingFocus(menuItems[0]);\n                }\n                if (!$subOpen) {\n                    const focusedItem = get(currentFocusedItem);\n                    if (focusedItem && menuEl.contains(focusedItem)) {\n                        removeHighlight(focusedItem);\n                    }\n                }\n                if (menuEl && !$subOpen) {\n                    const subTriggerEl = document.getElementById(subIds.trigger);\n                    if (!subTriggerEl || document.activeElement === subTriggerEl)\n                        return;\n                    removeHighlight(subTriggerEl);\n                }\n            });\n        });\n        return {\n            elements: {\n                subTrigger,\n                subMenu,\n                subArrow,\n            },\n            states: {\n                subOpen,\n            },\n            options,\n        };\n    };\n    onMount(() => {\n        /**\n         * We need to set the active trigger on mount to cover the\n         * case where the user sets the `open` store to `true` without\n         * clicking on the trigger.\n         */\n        const triggerEl = document.getElementById(rootIds.trigger);\n        if (isHTMLElement(triggerEl) && get(rootOpen)) {\n            rootActiveTrigger.set(triggerEl);\n        }\n        const unsubs = [];\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = () => {\n            isUsingKeyboard.set(true);\n            unsubs.push(executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true })));\n        };\n        const keydownListener = (e) => {\n            if (e.key === kbd.ESCAPE && get(closeOnEscape)) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        unsubs.push(addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n        unsubs.push(addEventListener(document, 'keydown', keydownListener));\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * Root Effects\n     * -----------------------------------------------------------------------------------------------*/\n    effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {\n        if (!$rootOpen && $currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n    });\n    effect([rootOpen, rootActiveTrigger, preventScroll], ([$rootOpen, $rootActiveTrigger, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        const unsubs = [];\n        if (opts.removeScroll && $rootOpen && $preventScroll) {\n            unsubs.push(removeScroll());\n        }\n        if (!$rootOpen && $rootActiveTrigger) {\n            handleRovingFocus($rootActiveTrigger);\n        }\n        sleep(1).then(() => {\n            const menuEl = document.getElementById(rootIds.menu);\n            if (menuEl && $rootOpen && get(isUsingKeyboard)) {\n                if (opts.disableFocusFirstItem) {\n                    handleRovingFocus(menuEl);\n                    return;\n                }\n                // Get menu items belonging to the root menu\n                const menuItems = getMenuItems(menuEl);\n                if (!menuItems.length)\n                    return;\n                // Focus on first menu item\n                handleRovingFocus(menuItems[0]);\n            }\n            else if ($rootActiveTrigger) {\n                // Focus on active trigger trigger\n                handleRovingFocus($rootActiveTrigger);\n            }\n            else {\n                if (opts.disableTriggerRefocus) {\n                    return;\n                }\n                const triggerEl = document.getElementById(rootIds.trigger);\n                if (!triggerEl)\n                    return;\n                handleRovingFocus(triggerEl);\n            }\n        });\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    effect(rootOpen, ($rootOpen) => {\n        if (!isBrowser)\n            return;\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = (e) => {\n            isUsingKeyboard.set(true);\n            if (e.key === kbd.ESCAPE && $rootOpen) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        return executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true }), addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n    });\n    function handleOpen(triggerEl) {\n        rootOpen.update((prev) => {\n            const isOpen = !prev;\n            if (isOpen) {\n                nextFocusable.set(getNextFocusable(triggerEl));\n                prevFocusable.set(getPreviousFocusable(triggerEl));\n                rootActiveTrigger.set(triggerEl);\n            }\n            return isOpen;\n        });\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Pointer Event Effects\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemFocusIn(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        const $currentFocusedItem = get(currentFocusedItem);\n        if ($currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n        addHighlight(itemEl);\n        /**\n         * Accomodates for Firefox focus event behavior, which differs\n         * from other browsers. We're setting the current focused item\n         * so when we close the menu, we can remove the data-highlighted\n         * attribute from the item, since a blur nor focusout event will be fired\n         * when the menu is closed via `clickOutside` or the ESC key.\n         */\n        currentFocusedItem.set(itemEl);\n    }\n    /**\n     * Each of the menu items share the same focusout event handler.\n     */\n    function onItemFocusOut(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        removeHighlight(itemEl);\n    }\n    function onItemEnter(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onItemLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            return;\n        }\n        const target = e.target;\n        if (!isHTMLElement(target))\n            return;\n        const parentMenuEl = getParentMenu(target);\n        if (!parentMenuEl)\n            return;\n        handleRovingFocus(parentMenuEl);\n    }\n    function onTriggerLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onMenuPointerMove(e) {\n        if (!isMouse(e))\n            return;\n        const target = e.target;\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget) || !isHTMLElement(target))\n            return;\n        const $lastPointerX = get(lastPointerX);\n        const pointerXHasChanged = $lastPointerX !== e.clientX;\n        // We don't use `e.movementX` for this check because Safari will\n        // always return `0` on a pointer e.\n        if (currentTarget.contains(target) && pointerXHasChanged) {\n            const newDir = e.clientX > $lastPointerX ? 'right' : 'left';\n            pointerDir.set(newDir);\n            lastPointerX.set(e.clientX);\n        }\n    }\n    function onMenuItemPointerMove(e, currTarget = null) {\n        if (!isMouse(e))\n            return;\n        onItemEnter(e);\n        if (e.defaultPrevented)\n            return;\n        // if we've already checked the current target, we don't need to again\n        if (currTarget) {\n            handleRovingFocus(currTarget);\n            return;\n        }\n        // otherwise we will\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget))\n            return;\n        // focus on the current menu item\n        handleRovingFocus(currentTarget);\n    }\n    function onMenuItemPointerLeave(e) {\n        if (!isMouse(e))\n            return;\n        onItemLeave(e);\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Helper Functions\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemKeyDown(e) {\n        const $typed = get(typed);\n        const isTypingAhead = $typed.length > 0;\n        if (isTypingAhead && e.key === kbd.SPACE) {\n            e.preventDefault();\n            return;\n        }\n        if (SELECTION_KEYS.includes(e.key)) {\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            e.preventDefault();\n            const itemEl = e.currentTarget;\n            if (!isHTMLElement(itemEl))\n                return;\n            itemEl.click();\n        }\n    }\n    function isIndeterminate(checked) {\n        return checked === 'indeterminate';\n    }\n    function getCheckedState(checked) {\n        return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n    }\n    function isPointerMovingToSubmenu(e) {\n        return get(pointerMovingToSubmenu)(e);\n    }\n    /**\n     * Get the parent menu element for a menu item.\n     * @param element The menu item element\n     */\n    function getParentMenu(element) {\n        const parentMenuEl = element.closest('[role=\"menu\"]');\n        if (!isHTMLElement(parentMenuEl))\n            return null;\n        return parentMenuEl;\n    }\n    return {\n        trigger: rootTrigger,\n        menu: rootMenu,\n        open: rootOpen,\n        item,\n        group,\n        groupLabel,\n        arrow: rootArrow,\n        options: opts.rootOptions,\n        createCheckboxItem,\n        createSubmenu,\n        createMenuRadioGroup,\n        separator,\n        rootIds,\n        handleTypeaheadSearch,\n    };\n}\nexport function handleTabNavigation(e, nextFocusable, prevFocusable) {\n    if (e.shiftKey) {\n        const $prevFocusable = get(prevFocusable);\n        if ($prevFocusable) {\n            e.preventDefault();\n            $prevFocusable.focus();\n            prevFocusable.set(null);\n        }\n    }\n    else {\n        const $nextFocusable = get(nextFocusable);\n        if ($nextFocusable) {\n            e.preventDefault();\n            $nextFocusable.focus();\n            nextFocusable.set(null);\n        }\n    }\n}\n/**\n * Get the menu items for a given menu element.\n * This only selects menu items that are direct children of the menu element,\n * not menu items that are nested in submenus.\n * @param element The menu item element\n */\nexport function getMenuItems(menuElement) {\n    return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id=\"${menuElement.id}\"]`)).filter((item) => isHTMLElement(item));\n}\nexport function applyAttrsIfDisabled(element) {\n    if (!element || !isElementDisabled(element))\n        return;\n    element.setAttribute('data-disabled', '');\n    element.setAttribute('aria-disabled', 'true');\n}\n/**\n * Given a timer store, clear the timeout and set the store to null\n * @param openTimer The timer store\n */\nexport function clearTimerStore(timerStore) {\n    if (!isBrowser)\n        return;\n    const timer = get(timerStore);\n    if (timer) {\n        window.clearTimeout(timer);\n        timerStore.set(null);\n    }\n}\n/**\n * Check if the event is a mouse event\n * @param e The pointer event\n */\nfunction isMouse(e) {\n    return e.pointerType === 'mouse';\n}\n/**\n * Set the `data-melt-menu-id` attribute on a menu item element.\n * @param element The menu item element\n */\nexport function setMeltMenuAttribute(element, selector) {\n    if (!element)\n        return;\n    const menuEl = element.closest(`${selector()}, ${selector('submenu')}`);\n    if (!isHTMLElement(menuEl))\n        return;\n    element.setAttribute('data-melt-menu-id', menuEl.id);\n}\n/**\n * Keyboard event handler for menu navigation\n * @param e The keyboard event\n */\nexport function handleMenuNavigation(e) {\n    e.preventDefault();\n    // currently focused menu item\n    const currentFocusedItem = document.activeElement;\n    // menu element being navigated\n    const currentTarget = e.currentTarget;\n    if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))\n        return;\n    // menu items of the current menu\n    const menuItems = getMenuItems(currentTarget);\n    if (!menuItems.length)\n        return;\n    const candidateNodes = menuItems.filter((item) => {\n        if (item.hasAttribute('data-disabled') || item.getAttribute('disabled') === 'true') {\n            return false;\n        }\n        return true;\n    });\n    // Index of the currently focused item in the candidate nodes array\n    const currentIndex = candidateNodes.indexOf(currentFocusedItem);\n    // Calculate the index of the next menu item\n    let nextIndex;\n    switch (e.key) {\n        case kbd.ARROW_DOWN:\n            nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;\n            break;\n        case kbd.ARROW_UP:\n            nextIndex = currentIndex > 0 ? currentIndex - 1 : 0;\n            break;\n        case kbd.HOME:\n            nextIndex = 0;\n            break;\n        case kbd.END:\n            nextIndex = candidateNodes.length - 1;\n            break;\n        default:\n            return;\n    }\n    handleRovingFocus(candidateNodes[nextIndex]);\n}\nfunction isPointerInGraceArea(e, area) {\n    if (!area)\n        return false;\n    const cursorPos = { x: e.clientX, y: e.clientY };\n    return isPointInPolygon(cursorPos, area);\n}\n/**\n * Determine if a point is inside of a polygon.\n *\n * @see https://github.com/substack/point-in-polygon\n */\nfunction isPointInPolygon(point, polygon) {\n    const { x, y } = point;\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        // prettier-ignore\n        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\n", "import { usePopper } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, addMeltEventListener, builder, createElHelpers, derivedVisible, derivedWithUnsubscribe, effect, executeCallbacks, getNextFocusable, getPortalDestination, getPreviousFocusable, isHTMLElement, isLeftClick, kbd, noop, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { tick } from 'svelte';\nimport { get, writable } from 'svelte/store';\nimport { applyAttrsIfDisabled, clearTimerStore, createMenuBuilder, getMenuItems, handleMenuNavigation, handleTabNavigation, setMeltMenuAttribute, } from '../menu/index.js';\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom-start',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    forceVisible: false,\n    typeahead: true,\n};\nconst { name, selector } = createElHelpers('context-menu');\nexport function createContextMenu(props) {\n    const withDefaults = { ...defaults, ...props };\n    const rootOptions = toWritableStores(withDefaults);\n    const { positioning, closeOnOutsideClick, portal, forceVisible, closeOnEscape } = rootOptions;\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);\n    const rootActiveTrigger = writable(null);\n    const nextFocusable = writable(null);\n    const prevFocusable = writable(null);\n    const { item, createCheckboxItem, arrow, createSubmenu, createMenuRadioGroup, rootIds, separator, handleTypeaheadSearch, group, groupLabel, } = createMenuBuilder({\n        rootOpen,\n        rootActiveTrigger,\n        rootOptions,\n        nextFocusable,\n        prevFocusable,\n        disableFocusFirstItem: true,\n        disableTriggerRefocus: true,\n        selector: 'context-menu',\n        removeScroll: true,\n    });\n    const point = writable(null);\n    const virtual = derivedWithUnsubscribe([point], ([$point]) => {\n        if ($point === null)\n            return null;\n        return {\n            getBoundingClientRect: () => DOMRect.fromRect({\n                width: 0,\n                height: 0,\n                ...$point,\n            }),\n        };\n    });\n    const longPressTimer = writable(0);\n    function handleClickOutside(e) {\n        if (e.defaultPrevented)\n            return;\n        const target = e.target;\n        if (!(target instanceof Element))\n            return;\n        if (target.id === rootIds.trigger && isLeftClick(e)) {\n            rootOpen.set(false);\n            return;\n        }\n        if (target.id !== rootIds.trigger && !target.closest(selector())) {\n            rootOpen.set(false);\n        }\n    }\n    const isVisible = derivedVisible({\n        open: rootOpen,\n        forceVisible,\n        activeTrigger: rootActiveTrigger,\n    });\n    const menu = builder(name(), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            // We only want to render the menu when it's open and has an active trigger.\n            return {\n                role: 'menu',\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: rootIds.menu,\n                'aria-labelledby': rootIds.trigger,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': $portal ? '' : undefined,\n                tabindex: -1,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape,]) => {\n                unsubPopper();\n                if (!$isVisible || !$rootActiveTrigger)\n                    return;\n                tick().then(() => {\n                    setMeltMenuAttribute(node, selector);\n                    const $virtual = get(virtual);\n                    const popper = usePopper(node, {\n                        anchorElement: $virtual ? $virtual : $rootActiveTrigger,\n                        open: rootOpen,\n                        options: {\n                            floating: $positioning,\n                            clickOutside: $closeOnOutsideClick\n                                ? {\n                                    handler: handleClickOutside,\n                                }\n                                : null,\n                            portal: getPortalDestination(node, $portal),\n                            escapeKeydown: $closeOnEscape ? undefined : null,\n                        },\n                    });\n                    if (!popper || !popper.destroy)\n                        return;\n                    unsubPopper = popper.destroy;\n                });\n            });\n            const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const target = e.target;\n                const menuEl = e.currentTarget;\n                if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                    return;\n                /**\n                 * Submenu key events bubble through portals and\n                 * we only care about key events that happen inside this menu.\n                 */\n                const isKeyDownInside = target.closest(\"[role='menu']\") === menuEl;\n                if (!isKeyDownInside)\n                    return;\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    handleMenuNavigation(e);\n                }\n                /**\n                 * Menus should not be navigated using tab, so we prevent it.\n                 * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                 */\n                if (e.key === kbd.TAB) {\n                    e.preventDefault();\n                    rootOpen.set(false);\n                    handleTabNavigation(e, nextFocusable, prevFocusable);\n                    return;\n                }\n                /**\n                 * Check for typeahead search and handle it.\n                 */\n                const isCharacterKey = e.key.length === 1;\n                const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                if (!isModifierKey && isCharacterKey) {\n                    handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                }\n            }));\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubEvents();\n                    unsubPopper();\n                },\n            };\n        },\n    });\n    const trigger = builder(name('trigger'), {\n        stores: rootOpen,\n        returned: ($rootOpen) => {\n            return {\n                'aria-controls': rootIds.menu,\n                'aria-expanded': $rootOpen,\n                'data-state': $rootOpen ? 'open' : 'closed',\n                id: rootIds.trigger,\n                style: styleToString({\n                    WebkitTouchCallout: 'none',\n                }),\n            };\n        },\n        action: (node) => {\n            applyAttrsIfDisabled(node);\n            const handleOpen = (e) => {\n                point.set({\n                    x: e.clientX,\n                    y: e.clientY,\n                });\n                nextFocusable.set(getNextFocusable(node));\n                prevFocusable.set(getPreviousFocusable(node));\n                rootActiveTrigger.set(node);\n                rootOpen.set(true);\n            };\n            const unsubTimer = () => {\n                clearTimerStore(longPressTimer);\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'contextmenu', (e) => {\n                /**\n                 * Clear the long press because some platforms already\n                 * fire a contextmenu event on long press.\n                 */\n                clearTimerStore(longPressTimer);\n                handleOpen(e);\n                e.preventDefault();\n            }), addMeltEventListener(node, 'pointerdown', (e) => {\n                if (!isTouchOrPen(e))\n                    return;\n                // Clear the long press in case there's multiple touchpoints\n                clearTimerStore(longPressTimer);\n                longPressTimer.set(window.setTimeout(() => handleOpen(e), 700));\n            }), addMeltEventListener(node, 'pointermove', (e) => {\n                if (!isTouchOrPen(e))\n                    return;\n                clearTimerStore(longPressTimer);\n            }), addMeltEventListener(node, 'pointercancel', (e) => {\n                if (!isTouchOrPen(e))\n                    return;\n                clearTimerStore(longPressTimer);\n            }), addMeltEventListener(node, 'pointerup', (e) => {\n                if (!isTouchOrPen(e))\n                    return;\n                clearTimerStore(longPressTimer);\n            }));\n            return {\n                destroy() {\n                    unsubTimer();\n                    unsub();\n                },\n            };\n        },\n    });\n    return {\n        elements: {\n            menu,\n            trigger,\n            item,\n            arrow,\n            separator,\n            group,\n            groupLabel,\n        },\n        states: {\n            open: rootOpen,\n        },\n        builders: {\n            createSubmenu,\n            createCheckboxItem,\n            createMenuRadioGroup,\n        },\n        options: rootOptions,\n    };\n}\n/**\n * Check if the event is a touch or pen event\n * @param e The pointer event\n */\nfunction isTouchOrPen(e) {\n    return e.pointerType !== 'mouse';\n}\n", "import { createFocusTrap, useClickOutside, useEscapeKeydown, usePortal, } from '../../internal/actions/index.js';\nimport { addMeltEventListener, builder, createElHelpers, effect, executeCallbacks, generateId, getPortalDestination, isBrowser, isHTMLElement, kbd, last, noop, overridable, removeScroll, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nconst { name } = createElHelpers('dialog');\nconst defaults = {\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    role: 'dialog',\n    defaultOpen: false,\n    portal: 'body',\n    forceVisible: false,\n};\nconst openDialogIds = writable([]);\nexport function createDialog(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible } = options;\n    const activeTrigger = writable(null);\n    const ids = {\n        content: generateId(),\n        title: generateId(),\n        description: generateId(),\n        trigger: generateId(),\n    };\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {\n        return $open || $forceVisible;\n    });\n    function handleOpen(e) {\n        const el = e.currentTarget;\n        const triggerEl = e.currentTarget;\n        if (!isHTMLElement(el) || !isHTMLElement(triggerEl))\n            return;\n        open.set(true);\n        activeTrigger.set(triggerEl);\n    }\n    function handleClose() {\n        open.set(false);\n        const triggerEl = document.getElementById(ids.trigger);\n        if (triggerEl) {\n            tick().then(() => {\n                triggerEl.focus();\n            });\n        }\n    }\n    onMount(() => {\n        activeTrigger.set(document.getElementById(ids.trigger));\n    });\n    effect([open], ([$open]) => {\n        // Prevent double clicks from closing multiple dialogs\n        sleep(100).then(() => {\n            if ($open) {\n                openDialogIds.update((prev) => {\n                    prev.push(ids.content);\n                    return prev;\n                });\n            }\n            else {\n                openDialogIds.update((prev) => prev.filter((id) => id !== ids.content));\n            }\n        });\n    });\n    const trigger = builder(name('trigger'), {\n        stores: open,\n        returned: ($open) => {\n            return {\n                id: ids.trigger,\n                'aria-haspopup': 'dialog',\n                'aria-expanded': $open,\n                'aria-controls': ids.content,\n                type: 'button',\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                handleOpen(e);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                handleOpen(e);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const overlay = builder(name('overlay'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                'aria-hidden': true,\n                'data-state': $isVisible ? 'open' : 'closed',\n            };\n        },\n        action: (node) => {\n            let unsubEscapeKeydown = noop;\n            if (get(closeOnEscape)) {\n                const escapeKeydown = useEscapeKeydown(node, {\n                    handler: () => {\n                        handleClose();\n                    },\n                });\n                if (escapeKeydown && escapeKeydown.destroy) {\n                    unsubEscapeKeydown = escapeKeydown.destroy;\n                }\n            }\n            return {\n                destroy() {\n                    unsubEscapeKeydown();\n                },\n            };\n        },\n    });\n    const content = builder(name('content'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                id: ids.content,\n                role: get(role),\n                'aria-describedby': ids.description,\n                'aria-labelledby': ids.title,\n                'data-state': $isVisible ? 'open' : 'closed',\n                tabindex: -1,\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n            };\n        },\n        action: (node) => {\n            let activate = noop;\n            let deactivate = noop;\n            const destroy = executeCallbacks(effect([open], ([$open]) => {\n                if (!$open)\n                    return;\n                const focusTrap = createFocusTrap({\n                    immediate: false,\n                    escapeDeactivates: false,\n                    returnFocusOnDeactivate: false,\n                    fallbackFocus: node,\n                });\n                activate = focusTrap.activate;\n                deactivate = focusTrap.deactivate;\n                const ac = focusTrap.useFocusTrap(node);\n                if (ac && ac.destroy) {\n                    return ac.destroy;\n                }\n                else {\n                    return focusTrap.deactivate;\n                }\n            }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {\n                return useClickOutside(node, {\n                    enabled: $open,\n                    handler: (e) => {\n                        if (e.defaultPrevented)\n                            return;\n                        const $openDialogIds = get(openDialogIds);\n                        const isLast = last($openDialogIds) === ids.content;\n                        if ($closeOnOutsideClick && isLast) {\n                            handleClose();\n                        }\n                    },\n                }).destroy;\n            }), effect([closeOnEscape], ([$closeOnEscape]) => {\n                if (!$closeOnEscape)\n                    return noop;\n                const escapeKeydown = useEscapeKeydown(node, {\n                    handler: () => {\n                        handleClose();\n                    },\n                });\n                if (escapeKeydown && escapeKeydown.destroy) {\n                    return escapeKeydown.destroy;\n                }\n                return noop;\n            }), effect([isVisible], ([$isVisible]) => {\n                tick().then(() => {\n                    if (!$isVisible) {\n                        deactivate();\n                    }\n                    else {\n                        activate();\n                    }\n                });\n            }));\n            return {\n                destroy,\n            };\n        },\n    });\n    const portalled = builder(name('portalled'), {\n        stores: portal,\n        returned: ($portal) => ({\n            'data-portal': $portal ? '' : undefined,\n        }),\n        action: (node) => {\n            const unsubPortal = effect([portal], ([$portal]) => {\n                if (!$portal)\n                    return noop;\n                const portalDestination = getPortalDestination(node, $portal);\n                if (portalDestination === null)\n                    return noop;\n                const portalAction = usePortal(node, portalDestination);\n                if (portalAction && portalAction.destroy) {\n                    return portalAction.destroy;\n                }\n                else {\n                    return noop;\n                }\n            });\n            return {\n                destroy() {\n                    unsubPortal();\n                },\n            };\n        },\n    });\n    const title = builder(name('title'), {\n        returned: () => ({\n            id: ids.title,\n        }),\n    });\n    const description = builder(name('description'), {\n        returned: () => ({\n            id: ids.description,\n        }),\n    });\n    const close = builder(name('close'), {\n        returned: () => ({\n            type: 'button',\n        }),\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleClose();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)\n                    return;\n                e.preventDefault();\n                handleClose();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    effect([open, preventScroll], ([$open, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        const unsubs = [];\n        if ($preventScroll && $open)\n            unsubs.push(removeScroll());\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    return {\n        elements: {\n            content,\n            trigger,\n            title,\n            description,\n            overlay,\n            close,\n            portalled,\n        },\n        states: {\n            open,\n        },\n        options,\n    };\n}\n", "import { overridable, toWritableStores } from '../../internal/helpers/index.js';\nimport { writable } from 'svelte/store';\nimport { createMenuBuilder } from '../menu/index.js';\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    forceVisible: false,\n    typeahead: true,\n};\nexport function createDropdownMenu(props) {\n    const withDefaults = { ...defaults, ...props };\n    const rootOptions = toWritableStores(withDefaults);\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);\n    const rootActiveTrigger = writable(null);\n    const nextFocusable = writable(null);\n    const prevFocusable = writable(null);\n    const { trigger, menu, item, arrow, createSubmenu, createCheckboxItem, createMenuRadioGroup, separator, group, groupLabel, } = createMenuBuilder({\n        rootOptions,\n        rootOpen,\n        rootActiveTrigger,\n        nextFocusable,\n        prevFocusable,\n        disableTriggerRefocus: true,\n        selector: 'dropdown-menu',\n        removeScroll: true,\n    });\n    return {\n        elements: {\n            trigger,\n            menu,\n            item,\n            arrow,\n            separator,\n            group,\n            groupLabel,\n        },\n        states: {\n            open: rootOpen,\n        },\n        builders: {\n            createCheckboxItem,\n            createSubmenu,\n            createMenuRadioGroup,\n        },\n        options: rootOptions,\n    };\n}\n", "import { usePopper } from '../../internal/actions/index.js';\nimport { addMeltEventListener, builder, createElHelpers, derivedVisible, effect, executeCallbacks, generateId, getPortalDestination, getTabbableNodes, isBrowser, isElement, isFocusVisible, isHTMLElement, isTouch, noop, overridable, sleep, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nconst { name } = createElHelpers('hover-card');\nconst defaults = {\n    defaultOpen: false,\n    openDelay: 700,\n    closeDelay: 300,\n    positioning: {\n        placement: 'bottom',\n    },\n    arrowSize: 8,\n    closeOnOutsideClick: true,\n    forceVisible: false,\n    portal: 'body',\n    closeOnEscape: true,\n};\nexport function createLinkPreview(props = {}) {\n    const withDefaults = { ...defaults, ...props };\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const hasSelection = writable(false);\n    const isPointerDownOnContent = writable(false);\n    const containSelection = writable(false);\n    const activeTrigger = writable(null);\n    const options = toWritableStores(withDefaults);\n    const { openDelay, closeDelay, positioning, arrowSize, closeOnOutsideClick, forceVisible, portal, closeOnEscape, } = options;\n    const ids = {\n        content: generateId(),\n        trigger: generateId(),\n    };\n    let timeout = null;\n    let originalBodyUserSelect;\n    const handleOpen = derived(openDelay, ($openDelay) => {\n        return () => {\n            if (timeout) {\n                window.clearTimeout(timeout);\n                timeout = null;\n            }\n            timeout = window.setTimeout(() => {\n                open.set(true);\n            }, $openDelay);\n        };\n    });\n    const handleClose = derived([closeDelay, isPointerDownOnContent, hasSelection], ([$closeDelay, $isPointerDownOnContent, $hasSelection]) => {\n        return () => {\n            if (timeout) {\n                window.clearTimeout(timeout);\n                timeout = null;\n            }\n            if (!$isPointerDownOnContent && !$hasSelection) {\n                timeout = window.setTimeout(() => {\n                    open.set(false);\n                }, $closeDelay);\n            }\n        };\n    });\n    const trigger = builder(name('trigger'), {\n        stores: [open],\n        returned: ([$open]) => {\n            return {\n                role: 'button',\n                'aria-haspopup': 'dialog',\n                'aria-expanded': $open,\n                'data-state': $open ? 'open' : 'closed',\n                'aria-controls': ids.content,\n                id: ids.trigger,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'pointerenter', (e) => {\n                if (isTouch(e))\n                    return;\n                get(handleOpen)();\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                if (isTouch(e))\n                    return;\n                get(handleClose)();\n            }), addMeltEventListener(node, 'focus', (e) => {\n                if (!isElement(e.currentTarget) || !isFocusVisible(e.currentTarget))\n                    return;\n                get(handleOpen)();\n            }), addMeltEventListener(node, 'blur', () => get(handleClose)()));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const isVisible = derivedVisible({ open, forceVisible, activeTrigger });\n    const content = builder(name('content'), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    'pointer-events': $isVisible ? undefined : 'none',\n                    opacity: $isVisible ? 1 : 0,\n                    userSelect: 'text',\n                    WebkitUserSelect: 'text',\n                }),\n                id: ids.content,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': $portal ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            let unsub = noop;\n            const unsubTimers = () => {\n                if (timeout) {\n                    window.clearTimeout(timeout);\n                }\n            };\n            let unsubPopper = noop;\n            const unsubDerived = effect([isVisible, activeTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $activeTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape,]) => {\n                unsubPopper();\n                if (!$isVisible || !$activeTrigger)\n                    return;\n                const popper = usePopper(node, {\n                    anchorElement: $activeTrigger,\n                    open: open,\n                    options: {\n                        floating: $positioning,\n                        clickOutside: $closeOnOutsideClick ? undefined : null,\n                        portal: getPortalDestination(node, $portal),\n                        focusTrap: null,\n                        escapeKeydown: $closeOnEscape ? undefined : null,\n                    },\n                });\n                if (popper && popper.destroy) {\n                    unsubPopper = popper.destroy;\n                }\n            });\n            unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                const currentTarget = e.currentTarget;\n                const target = e.target;\n                if (!isHTMLElement(currentTarget) || !isHTMLElement(target))\n                    return;\n                if (currentTarget.contains(target)) {\n                    containSelection.set(true);\n                }\n                hasSelection.set(false);\n                isPointerDownOnContent.set(true);\n            }), addMeltEventListener(node, 'pointerenter', (e) => {\n                if (isTouch(e))\n                    return;\n                get(handleOpen)();\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                if (isTouch(e))\n                    return;\n                get(handleClose)();\n            }), addMeltEventListener(node, 'focusout', (e) => {\n                e.preventDefault();\n            }));\n            return {\n                destroy() {\n                    unsub();\n                    unsubPopper();\n                    unsubTimers();\n                    unsubDerived();\n                },\n            };\n        },\n    });\n    const arrow = builder(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    effect([containSelection], ([$containSelection]) => {\n        if (!isBrowser || !$containSelection)\n            return;\n        const body = document.body;\n        const contentElement = document.getElementById(ids.content);\n        if (!contentElement)\n            return;\n        // prefix for safari\n        originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;\n        const originalContentUserSelect = contentElement.style.userSelect || contentElement.style.webkitUserSelect;\n        body.style.userSelect = 'none';\n        body.style.webkitUserSelect = 'none';\n        contentElement.style.userSelect = 'text';\n        contentElement.style.webkitUserSelect = 'text';\n        return () => {\n            body.style.userSelect = originalBodyUserSelect;\n            body.style.webkitUserSelect = originalBodyUserSelect;\n            contentElement.style.userSelect = originalContentUserSelect;\n            contentElement.style.webkitUserSelect = originalContentUserSelect;\n        };\n    });\n    onMount(() => {\n        const triggerEl = document.getElementById(ids.trigger);\n        if (!triggerEl)\n            return;\n        activeTrigger.set(triggerEl);\n    });\n    effect([open], ([$open]) => {\n        if (!isBrowser || !$open)\n            return;\n        const handlePointerUp = () => {\n            containSelection.set(false);\n            isPointerDownOnContent.set(false);\n            sleep(1).then(() => {\n                const isSelection = document.getSelection()?.toString() !== '';\n                if (isSelection) {\n                    hasSelection.set(true);\n                }\n            });\n        };\n        document.addEventListener('pointerup', handlePointerUp);\n        const contentElement = document.getElementById(ids.content);\n        if (!contentElement)\n            return;\n        const tabbables = getTabbableNodes(contentElement);\n        tabbables.forEach((tabbable) => tabbable.setAttribute('tabindex', '-1'));\n        return () => {\n            document.removeEventListener('pointerup', handlePointerUp);\n            hasSelection.set(false);\n            isPointerDownOnContent.set(false);\n        };\n    });\n    return {\n        elements: {\n            trigger,\n            content,\n            arrow,\n        },\n        states: {\n            open,\n        },\n        options,\n    };\n}\n", "import { get, writable } from 'svelte/store';\nimport { applyAttrsIfDisabled, createMenuBuilder, getMenuItems, handleMenuNavigation, handleTabNavigation, } from '../menu/index.js';\nimport { executeCallbacks, isHTMLElement, addEventListener, kbd, SELECTION_KEYS, FIRST_LAST_KEYS, handleRovingFocus, effect, styleToString, noop, generateId, isBrowser, getNextFocusable, getPreviousFocusable, builder, createElHelpers, toWritableStores, removeHighlight, addHighlight, derivedVisible, addMeltEventListener, getPortalDestination, removeScroll, isElement, } from '../../internal/helpers/index.js';\nimport { onDestroy, onMount, tick } from 'svelte';\nimport { usePopper } from '../../internal/actions/index.js';\nconst MENUBAR_NAV_KEYS = [kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.HOME, kbd.END];\nconst { name } = createElHelpers('menubar');\nconst defaults = {\n    loop: true,\n    closeOnEscape: true,\n};\nexport function createMenubar(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { loop, closeOnEscape } = options;\n    const activeMenu = writable('');\n    const nextFocusable = writable(null);\n    const prevFocusable = writable(null);\n    const lastFocusedMenuTrigger = writable(null);\n    const closeTimer = writable(0);\n    let scrollRemoved = false;\n    const rootIds = {\n        menubar: generateId(),\n    };\n    const menubar = builder(name(), {\n        returned() {\n            return {\n                role: 'menubar',\n                'data-melt-menubar': '',\n                'data-orientation': 'horizontal',\n                id: rootIds.menubar,\n            };\n        },\n        action: (node) => {\n            const menuTriggers = Array.from(node.querySelectorAll('[data-melt-menubar-trigger]'));\n            if (!isHTMLElement(menuTriggers[0]))\n                return {};\n            menuTriggers[0].tabIndex = 0;\n            return {\n                destroy: noop,\n            };\n        },\n    });\n    const menuDefaults = {\n        positioning: {\n            placement: 'bottom-start',\n        },\n        preventScroll: true,\n        arrowSize: 8,\n        dir: 'ltr',\n        loop: false,\n        closeOnEscape: true,\n        closeOnOutsideClick: true,\n        portal: undefined,\n        forceVisible: false,\n        defaultOpen: false,\n        typeahead: true,\n    };\n    const createMenu = (props) => {\n        const withDefaults = { ...menuDefaults, ...props };\n        const rootOpen = writable(false);\n        const rootActiveTrigger = writable(null);\n        // options\n        const options = toWritableStores(withDefaults);\n        const { positioning, portal, forceVisible } = options;\n        const m = createMenuBuilder({\n            rootOptions: options,\n            rootOpen,\n            rootActiveTrigger,\n            disableTriggerRefocus: true,\n            disableFocusFirstItem: true,\n            nextFocusable,\n            prevFocusable,\n            selector: 'menubar-menu',\n            removeScroll: false,\n        });\n        const isVisible = derivedVisible({\n            open: rootOpen,\n            forceVisible,\n            activeTrigger: rootActiveTrigger,\n        });\n        const menu = builder(name('menu'), {\n            stores: [isVisible, portal],\n            returned: ([$isVisible, $portal]) => {\n                return {\n                    role: 'menu',\n                    hidden: $isVisible ? undefined : true,\n                    style: styleToString({\n                        display: $isVisible ? undefined : 'none',\n                    }),\n                    id: m.rootIds.menu,\n                    'aria-labelledby': m.rootIds.trigger,\n                    'data-state': $isVisible ? 'open' : 'closed',\n                    'data-melt-scope': rootIds.menubar,\n                    'data-portal': $portal ? '' : undefined,\n                    tabindex: -1,\n                };\n            },\n            action: (node) => {\n                let unsubPopper = noop;\n                const unsubDerived = effect([rootOpen, rootActiveTrigger, positioning, portal], ([$rootOpen, $rootActiveTrigger, $positioning, $portal]) => {\n                    unsubPopper();\n                    if (!($rootOpen && $rootActiveTrigger))\n                        return;\n                    tick().then(() => {\n                        const popper = usePopper(node, {\n                            anchorElement: $rootActiveTrigger,\n                            open: rootOpen,\n                            options: {\n                                floating: $positioning,\n                                portal: getPortalDestination(node, $portal),\n                                clickOutside: {\n                                    ignore: (e) => {\n                                        const target = e.target;\n                                        const menubarEl = document.getElementById(rootIds.menubar);\n                                        if (!menubarEl || !isElement(target))\n                                            return false;\n                                        return menubarEl.contains(target);\n                                    },\n                                    handler: () => {\n                                        activeMenu.set('');\n                                    },\n                                },\n                            },\n                        });\n                        if (popper && popper.destroy) {\n                            unsubPopper = popper.destroy;\n                        }\n                    });\n                });\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                    const target = e.target;\n                    const menuEl = e.currentTarget;\n                    if (!isHTMLElement(menuEl) || !isHTMLElement(target))\n                        return;\n                    if (MENUBAR_NAV_KEYS.includes(e.key)) {\n                        handleCrossMenuNavigation(e);\n                    }\n                    /**\n                     * Submenu key events bubble through portals and\n                     * we only care about key events that happen inside this menu.\n                     */\n                    const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                    if (!isKeyDownInside)\n                        return;\n                    if (FIRST_LAST_KEYS.includes(e.key)) {\n                        handleMenuNavigation(e);\n                    }\n                    /**\n                     * Menus should not be navigated using tab, so we prevent it.\n                     * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                     */\n                    if (e.key === kbd.TAB) {\n                        e.preventDefault();\n                        rootActiveTrigger.set(null);\n                        rootOpen.set(false);\n                        handleTabNavigation(e, nextFocusable, prevFocusable);\n                    }\n                    /**\n                     * Check for typeahead search and handle it.\n                     */\n                    const isCharacterKey = e.key.length === 1;\n                    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                    if (!isModifierKey && isCharacterKey) {\n                        m.handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                    }\n                }));\n                return {\n                    destroy() {\n                        unsubDerived();\n                        unsubEvents();\n                        unsubPopper();\n                    },\n                };\n            },\n        });\n        const trigger = builder(name('trigger'), {\n            stores: [rootOpen],\n            returned: ([$rootOpen]) => {\n                return {\n                    'aria-controls': m.rootIds.menu,\n                    'aria-expanded': $rootOpen,\n                    'data-state': $rootOpen ? 'open' : 'closed',\n                    id: m.rootIds.trigger,\n                    'aria-haspopup': 'menu',\n                    'data-orientation': 'horizontal',\n                    role: 'menuitem',\n                };\n            },\n            action: (node) => {\n                applyAttrsIfDisabled(node);\n                const menubarEl = document.getElementById(rootIds.menubar);\n                if (!menubarEl)\n                    return {};\n                const menubarTriggers = Array.from(menubarEl.querySelectorAll('[data-melt-menubar-trigger]'));\n                if (!menubarTriggers.length)\n                    return {};\n                const unsubEffect = effect([lastFocusedMenuTrigger], ([$lastFocusedMenuTrigger]) => {\n                    if (!$lastFocusedMenuTrigger && menubarTriggers[0] === node) {\n                        node.tabIndex = 0;\n                    }\n                    else if ($lastFocusedMenuTrigger === node) {\n                        node.tabIndex = 0;\n                    }\n                    else {\n                        node.tabIndex = -1;\n                    }\n                });\n                if (menubarTriggers[0] === node) {\n                    node.tabIndex = 0;\n                }\n                else {\n                    node.tabIndex = -1;\n                }\n                const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                    const $rootOpen = get(rootOpen);\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    handleOpen(triggerEl);\n                    if (!$rootOpen)\n                        e.preventDefault();\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    if (SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN) {\n                        e.preventDefault();\n                        handleOpen(triggerEl);\n                        const menuId = triggerEl.getAttribute('aria-controls');\n                        if (!menuId)\n                            return;\n                        const menu = document.getElementById(menuId);\n                        if (!menu)\n                            return;\n                        const menuItems = getMenuItems(menu);\n                        if (!menuItems.length)\n                            return;\n                        handleRovingFocus(menuItems[0]);\n                    }\n                }), addMeltEventListener(node, 'pointerenter', (e) => {\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    const $activeMenu = get(activeMenu);\n                    const $rootOpen = get(rootOpen);\n                    if ($activeMenu && !$rootOpen) {\n                        rootOpen.set(true);\n                        activeMenu.set(m.rootIds.menu);\n                        rootActiveTrigger.set(triggerEl);\n                    }\n                }));\n                return {\n                    destroy() {\n                        unsub();\n                        unsubEffect();\n                    },\n                };\n            },\n        });\n        function handleOpen(triggerEl) {\n            rootOpen.update((prev) => {\n                const isOpen = !prev;\n                if (isOpen) {\n                    nextFocusable.set(getNextFocusable(triggerEl));\n                    prevFocusable.set(getPreviousFocusable(triggerEl));\n                    rootActiveTrigger.set(triggerEl);\n                    activeMenu.set(m.rootIds.menu);\n                }\n                else {\n                    rootActiveTrigger.set(null);\n                }\n                return isOpen;\n            });\n        }\n        effect([activeMenu], ([$activeMenu]) => {\n            if (!isBrowser)\n                return;\n            if ($activeMenu === m.rootIds.menu) {\n                if (get(rootOpen))\n                    return;\n                const triggerEl = document.getElementById(m.rootIds.trigger);\n                if (!triggerEl)\n                    return;\n                rootActiveTrigger.set(triggerEl);\n                addHighlight(triggerEl);\n                rootOpen.set(true);\n                return;\n            }\n            if ($activeMenu !== m.rootIds.menu) {\n                if (!isBrowser)\n                    return;\n                if (get(rootOpen)) {\n                    const triggerEl = document.getElementById(m.rootIds.trigger);\n                    if (!triggerEl)\n                        return;\n                    rootActiveTrigger.set(null);\n                    rootOpen.set(false);\n                    removeHighlight(triggerEl);\n                }\n                return;\n            }\n        });\n        effect([rootOpen], ([$rootOpen]) => {\n            if (!isBrowser)\n                return;\n            const triggerEl = document.getElementById(m.rootIds.trigger);\n            if (!triggerEl)\n                return;\n            if (!$rootOpen && get(activeMenu) === m.rootIds.menu) {\n                rootActiveTrigger.set(null);\n                activeMenu.set('');\n                removeHighlight(triggerEl);\n                return;\n            }\n            if ($rootOpen) {\n                lastFocusedMenuTrigger.set(triggerEl);\n                addHighlight(triggerEl);\n            }\n        });\n        onMount(() => {\n            if (!isBrowser)\n                return;\n            const triggerEl = document.getElementById(m.rootIds.trigger);\n            if (isHTMLElement(triggerEl) && get(rootOpen)) {\n                rootActiveTrigger.set(triggerEl);\n            }\n        });\n        return {\n            elements: {\n                menu,\n                trigger,\n                item: m.item,\n                arrow: m.arrow,\n                separator: m.separator,\n                group: m.group,\n                groupLabel: m.groupLabel,\n            },\n            builders: {\n                createCheckboxItem: m.createCheckboxItem,\n                createSubmenu: m.createSubmenu,\n                createMenuRadioGroup: m.createMenuRadioGroup,\n            },\n            states: {\n                open: rootOpen,\n            },\n            options,\n        };\n    };\n    /* -------- */\n    /* Helpers */\n    /* -------- */\n    /**\n     * KBD Navigation handler for moving between menus in the menu bar.\n     */\n    function handleCrossMenuNavigation(e) {\n        if (!isBrowser)\n            return;\n        e.preventDefault();\n        // menu element being navigated\n        const currentTarget = e.currentTarget;\n        const target = e.target;\n        if (!isHTMLElement(target) || !isHTMLElement(currentTarget))\n            return;\n        const targetIsSubTrigger = target.hasAttribute('data-melt-menubar-menu-subtrigger');\n        const isKeyDownInsideSubMenu = target.closest('[role=\"menu\"]') !== currentTarget;\n        const prevMenuKey = kbd.ARROW_LEFT;\n        const isPrevKey = e.key === prevMenuKey;\n        const isNextKey = !isPrevKey;\n        // prevent navigation when opening a submenu\n        if (isNextKey && targetIsSubTrigger)\n            return;\n        // prevent navigation when closing a submenu\n        if (isPrevKey && isKeyDownInsideSubMenu)\n            return;\n        // Index of the currently focused item in the candidate nodes array\n        const menubarEl = document.getElementById(rootIds.menubar);\n        if (!isHTMLElement(menubarEl))\n            return;\n        const triggers = getMenuTriggers(menubarEl);\n        const currTriggerId = currentTarget.getAttribute('aria-labelledby');\n        const currIndex = triggers.findIndex((trigger) => trigger.id === currTriggerId);\n        let nextIndex;\n        switch (e.key) {\n            case kbd.ARROW_RIGHT:\n                nextIndex = currIndex < triggers.length - 1 ? currIndex + 1 : 0;\n                break;\n            case kbd.ARROW_LEFT:\n                nextIndex = currIndex > 0 ? currIndex - 1 : triggers.length - 1;\n                break;\n            case kbd.HOME:\n                nextIndex = 0;\n                break;\n            case kbd.END:\n                nextIndex = triggers.length - 1;\n                break;\n            default:\n                return;\n        }\n        const nextFocusedTrigger = triggers[nextIndex];\n        const menuId = nextFocusedTrigger.getAttribute('aria-controls');\n        menuId && activeMenu.set(menuId);\n    }\n    function getMenuTriggers(el) {\n        const menuEl = el.closest('[role=\"menubar\"]');\n        if (!isHTMLElement(menuEl))\n            return [];\n        return Array.from(menuEl.querySelectorAll('[data-melt-menubar-trigger]')).filter((el) => isHTMLElement(el));\n    }\n    /**\n     * Keyboard event handler for menubar navigation.\n     * @param e The keyboard event\n     */\n    function handleMenubarNavigation(e) {\n        e.preventDefault();\n        // currently focused menu item\n        const currentFocusedItem = document.activeElement;\n        // menu element being navigated\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget) || !isHTMLElement(currentFocusedItem))\n            return;\n        // menu items of the current menu\n        const menuTriggers = getMenuTriggers(currentTarget);\n        if (!menuTriggers.length)\n            return;\n        const candidateNodes = menuTriggers.filter((item) => {\n            if (item.hasAttribute('data-disabled')) {\n                return false;\n            }\n            if (item.getAttribute('disabled') === 'true') {\n                return false;\n            }\n            return true;\n        });\n        // Index of the currently focused item in the candidate nodes array\n        const currentIndex = candidateNodes.indexOf(currentFocusedItem);\n        // Calculate the index of the next menu item\n        let nextIndex;\n        const $loop = get(loop);\n        switch (e.key) {\n            case kbd.ARROW_RIGHT:\n                nextIndex =\n                    currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : $loop ? 0 : currentIndex;\n                break;\n            case kbd.ARROW_LEFT:\n                nextIndex = currentIndex > 0 ? currentIndex - 1 : $loop ? candidateNodes.length - 1 : 0;\n                break;\n            case kbd.HOME:\n                nextIndex = 0;\n                break;\n            case kbd.END:\n                nextIndex = candidateNodes.length - 1;\n                break;\n            default:\n                return;\n        }\n        handleRovingFocus(candidateNodes[nextIndex]);\n    }\n    /* --------------------*/\n    /* Lifecycle & Effects */\n    /* --------------------*/\n    onMount(() => {\n        if (!isBrowser)\n            return;\n        const menubarEl = document.getElementById(rootIds.menubar);\n        if (!menubarEl)\n            return;\n        const unsubEvents = executeCallbacks(addMeltEventListener(menubarEl, 'keydown', (e) => {\n            const target = e.target;\n            const menuEl = e.currentTarget;\n            if (!isHTMLElement(menuEl) || !isHTMLElement(target))\n                return;\n            /**\n             * Submenu key events bubble through portals and\n             * we only care about key events that happen inside this menu.\n             */\n            const isTargetTrigger = target.hasAttribute('data-melt-menubar-trigger');\n            if (!isTargetTrigger)\n                return;\n            if (MENUBAR_NAV_KEYS.includes(e.key)) {\n                handleMenubarNavigation(e);\n            }\n        }), addEventListener(document, 'keydown', (e) => {\n            if (get(closeOnEscape) && e.key === kbd.ESCAPE) {\n                window.clearTimeout(get(closeTimer));\n                activeMenu.set('');\n            }\n        }));\n        return () => {\n            unsubEvents();\n        };\n    });\n    const unsubs = [];\n    effect([activeMenu], ([$activeMenu]) => {\n        if (!isBrowser)\n            return;\n        /**\n         * To prevent adding/removing the scroll as we cycle through\n         * menus (which causes horrible performance issues), we only\n         * want to remove the scroll when the first menu is opened, and\n         * remove it when no menus are open.\n         */\n        if (!$activeMenu) {\n            unsubs.forEach((unsub) => unsub());\n            scrollRemoved = false;\n        }\n        else if (!scrollRemoved) {\n            unsubs.push(removeScroll());\n            scrollRemoved = true;\n        }\n    });\n    onDestroy(() => {\n        unsubs.forEach((unsub) => unsub());\n    });\n    return {\n        elements: {\n            menubar,\n        },\n        builders: {\n            createMenu,\n        },\n        options,\n    };\n}\n", "export function getPageItems({ page = 1, totalPages, siblingCount = 1, }) {\n    const pageItems = [];\n    const pagesToShow = new Set([1, totalPages]);\n    const firstItemWithSiblings = 3 + siblingCount;\n    const lastItemWithSiblings = totalPages - 2 - siblingCount;\n    if (firstItemWithSiblings > lastItemWithSiblings) {\n        for (let p = 2; p <= totalPages - 1; p++) {\n            pagesToShow.add(p);\n        }\n    }\n    else if (page < firstItemWithSiblings) {\n        for (let p = 2; p <= Math.min(firstItemWithSiblings, totalPages); p++) {\n            pagesToShow.add(p);\n        }\n    }\n    else if (page > lastItemWithSiblings) {\n        for (let p = totalPages - 1; p >= Math.max(lastItemWithSiblings, 2); p--) {\n            pagesToShow.add(p);\n        }\n    }\n    else {\n        for (let p = Math.max(page - siblingCount, 2); p <= Math.min(page + siblingCount, totalPages); p++) {\n            pagesToShow.add(p);\n        }\n    }\n    const addPage = (value) => {\n        pageItems.push({ type: 'page', value, key: `page-${value}` });\n    };\n    const addEllipsis = () => {\n        pageItems.push({ type: 'ellipsis', key: `ellipsis-${pageItems.length}` });\n    };\n    let lastNumber = 0;\n    for (const page of Array.from(pagesToShow).sort((a, b) => a - b)) {\n        if (page - lastNumber > 1) {\n            addEllipsis();\n        }\n        addPage(page);\n        lastNumber = page;\n    }\n    return pageItems;\n}\n", "import { builder, createElHelpers, executeCallbacks, isHTMLElement, kbd, omit, overridable, toWritableStores, addMeltEventListener, } from '../../internal/helpers/index.js';\nimport { derived, get, writable, readonly } from 'svelte/store';\nimport { getPageItems } from './helpers.js';\nconst defaults = {\n    perPage: 1,\n    siblingCount: 1,\n    defaultPage: 1,\n};\nconst { name, selector } = createElHelpers('pagination');\nexport function createPagination(props) {\n    const withDefaults = { ...defaults, ...props };\n    const pageWritable = withDefaults.page ?? writable(withDefaults.defaultPage);\n    const page = overridable(pageWritable, withDefaults?.onPageChange);\n    // options\n    const options = toWritableStores(omit(withDefaults, 'page', 'onPageChange', 'defaultPage'));\n    const { perPage, siblingCount, count } = options;\n    const totalPages = derived([count, perPage], ([$count, $perPage]) => {\n        return Math.ceil($count / $perPage);\n    });\n    const range = derived([page, perPage, count], ([$page, $perPage, $count]) => {\n        const start = ($page - 1) * $perPage;\n        const end = Math.min(start + $perPage, $count);\n        return { start, end };\n    });\n    const root = builder(name(), {\n        returned: () => ({\n            'data-scope': 'pagination',\n        }),\n    });\n    const pages = derived([page, totalPages, siblingCount], ([$page, $totalPages, $siblingCount]) => {\n        return getPageItems({ page: $page, totalPages: $totalPages, siblingCount: $siblingCount });\n    });\n    const keydown = (e) => {\n        const thisEl = e.target;\n        if (!isHTMLElement(thisEl))\n            return;\n        const rootEl = thisEl.closest('[data-scope=\"pagination\"]');\n        if (!isHTMLElement(rootEl))\n            return;\n        const triggers = Array.from(rootEl.querySelectorAll(selector('page'))).filter((el) => isHTMLElement(el));\n        const prevButton = rootEl.querySelector(selector('prev'));\n        const nextButton = rootEl.querySelector(selector('next'));\n        if (isHTMLElement(prevButton)) {\n            triggers.unshift(prevButton);\n        }\n        if (isHTMLElement(nextButton)) {\n            triggers.push(nextButton);\n        }\n        const index = triggers.indexOf(thisEl);\n        if (e.key === kbd.ARROW_LEFT && index !== 0) {\n            e.preventDefault();\n            triggers[index - 1].focus();\n        }\n        else if (e.key === kbd.ARROW_RIGHT && index !== triggers.length - 1) {\n            e.preventDefault();\n            triggers[index + 1].focus();\n        }\n        else if (e.key === kbd.HOME) {\n            e.preventDefault();\n            triggers[0].focus();\n        }\n        else if (e.key === kbd.END) {\n            e.preventDefault();\n            triggers[triggers.length - 1].focus();\n        }\n    };\n    const pageTrigger = builder(name('page'), {\n        stores: page,\n        returned: ($page) => {\n            return (pageItem) => {\n                return {\n                    'aria-label': `Page ${pageItem.value}`,\n                    'data-value': pageItem.value,\n                    'data-selected': pageItem.value === $page ? '' : undefined,\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const value = node.dataset.value;\n                if (!value || Number.isNaN(+value))\n                    return;\n                page.set(Number(value));\n            }), addMeltEventListener(node, 'keydown', keydown));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const prevButton = builder(name('prev'), {\n        stores: page,\n        returned: ($page) => {\n            return {\n                'aria-label': 'Previous',\n                disabled: $page <= 1,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                page.update((p) => Math.max(p - 1, 1));\n            }), addMeltEventListener(node, 'keydown', keydown));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const nextButton = builder(name('next'), {\n        stores: [page, totalPages],\n        returned: ([$page, $totalPages]) => {\n            return {\n                'aria-label': 'Next',\n                disabled: $page >= $totalPages,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const $totalPages = get(totalPages);\n                page.update((p) => Math.min(p + 1, $totalPages));\n            }), addMeltEventListener(node, 'keydown', keydown));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n            pageTrigger,\n            prevButton,\n            nextButton,\n        },\n        states: {\n            range: readonly(range),\n            page: page,\n            pages: readonly(pages),\n            totalPages: readonly(totalPages),\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, executeCallbacks, generateId, isBrowser, isHTMLElement, isHTMLInputElement, last, next, omit, overridable, prev, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { tick } from 'svelte';\nimport { derived, get, readonly, writable } from 'svelte/store';\nconst { name, selector } = createElHelpers('pin-input');\nconst getInputs = (node) => {\n    const rootEl = node.closest(selector());\n    if (!isHTMLElement(rootEl)) {\n        return { inputs: null, el: node, elIndex: -1 };\n    }\n    const inputs = Array.from(rootEl.querySelectorAll(selector('input'))).filter((input) => isHTMLInputElement(input));\n    return {\n        elIndex: inputs.indexOf(node),\n        inputs,\n    };\n};\nconst defaults = {\n    placeholder: '',\n    disabled: false,\n    type: 'text',\n    name: undefined,\n    defaultValue: [],\n};\nexport function createPinInput(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value'));\n    const { placeholder, disabled, type, name: nameStore } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    const valueStr = derived(value, (v) => v.join(''));\n    const ids = {\n        root: generateId(),\n    };\n    const root = builder(name(), {\n        stores: value,\n        returned: ($value) => {\n            return {\n                id: ids.root,\n                'data-complete': $value.length && $value.every((v) => v.length > 0) ? '' : undefined,\n            };\n        },\n    });\n    let index = 0;\n    const getTotalItems = () => {\n        if (!isBrowser)\n            return Infinity;\n        const rootEl = document.getElementById(ids.root);\n        if (!rootEl)\n            return Infinity;\n        const inputs = Array.from(rootEl.querySelectorAll(selector('input')));\n        return inputs.length;\n    };\n    const input = builder(name('input'), {\n        stores: [value, placeholder, disabled, type],\n        returned: ([$value, $placeholder, $disabled, $type]) => {\n            return () => {\n                const totalItems = getTotalItems();\n                const currIndex = index % totalItems;\n                index = (index + 1) % totalItems;\n                const currValue = $value[currIndex] ?? '';\n                return {\n                    'data-complete': $value.length && $value.every((v) => v.length > 0) ? '' : undefined,\n                    placeholder: $placeholder,\n                    disabled: $disabled,\n                    type: $type,\n                    value: currValue,\n                };\n            };\n        },\n        action: (node) => {\n            const { elIndex } = getInputs(node);\n            value.update((v) => {\n                v[elIndex] = node.value;\n                return v;\n            });\n            const unsub = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const { inputs, elIndex } = getInputs(node);\n                if (!inputs)\n                    return;\n                if (e.key === 'Backspace') {\n                    e.preventDefault();\n                    if (node.value) {\n                        node.value = '';\n                        tick().then(() => (node.placeholder = ''));\n                        value.set(inputs.map((input) => input.value.slice(-1) ?? undefined));\n                    }\n                    else {\n                        const prevEl = prev(inputs, elIndex, false);\n                        prevEl.focus();\n                        prevEl.value = '';\n                        tick().then(() => (prevEl.placeholder = ''));\n                        value.set(inputs.map((input) => input.value.slice(-1) ?? undefined));\n                    }\n                }\n                if (e.key === 'Delete') {\n                    e.preventDefault();\n                    node.value = '';\n                    tick().then(() => (node.placeholder = ''));\n                }\n                if (e.key === 'ArrowLeft') {\n                    e.preventDefault();\n                    const prevEl = prev(inputs, elIndex, false);\n                    prevEl.focus();\n                }\n                if (e.key === 'ArrowRight') {\n                    e.preventDefault();\n                    const nextEl = next(inputs, elIndex, false);\n                    nextEl.focus();\n                }\n                if (e.key === 'Home') {\n                    e.preventDefault();\n                    inputs[0].focus();\n                }\n                if (e.key === 'End') {\n                    e.preventDefault();\n                    last(inputs).focus();\n                }\n            }), addMeltEventListener(node, 'input', (e) => {\n                const { inputs, elIndex } = getInputs(node);\n                if (!inputs)\n                    return;\n                const getInputted = (el) => {\n                    const $value = get(value);\n                    const prevElValue = $value[elIndex];\n                    const selectionStart = el.selectionStart ?? 1;\n                    if (!prevElValue)\n                        return el.value;\n                    return selectionStart > 1\n                        ? el.value.slice(1)\n                        : el.value.slice(0, Math.max(el.value.length - 2, 1));\n                };\n                const inputted = getInputted(node);\n                const inputEvent = e;\n                if (inputEvent.inputType === 'insertFromPaste') {\n                    return;\n                }\n                // Only allow 1 character, get last\n                node.value = inputted.slice(-1);\n                if (node.value.length !== 0) {\n                    const nextEl = next(inputs, elIndex, false);\n                    nextEl.focus();\n                }\n                value.set(inputs.map((input) => input.value.slice(-1) ?? undefined));\n            }), addMeltEventListener(node, 'paste', (e) => {\n                e.preventDefault();\n                const { inputs, elIndex } = getInputs(node);\n                if (!inputs)\n                    return;\n                const inputEvent = e;\n                const clipboardData = inputEvent.clipboardData;\n                if (!clipboardData)\n                    return;\n                const pasted = clipboardData.getData('text');\n                const initialIndex = pasted.length >= inputs.length ? 0 : elIndex;\n                const lastIndex = Math.min(initialIndex + pasted.length, inputs.length);\n                for (let i = initialIndex; i < lastIndex; i++) {\n                    const input = inputs[i];\n                    input.value = pasted[i - initialIndex];\n                    input.focus();\n                }\n                inputs[lastIndex]?.focus();\n                value.set(inputs.map((input) => input.value.slice(-1) ?? undefined));\n            }), addMeltEventListener(node, 'change', () => {\n                const { inputs } = getInputs(node);\n                if (!inputs)\n                    return;\n                value.set(inputs.map((input) => input.value.slice(-1) ?? undefined));\n            }), addMeltEventListener(node, 'focus', () => {\n                node.setSelectionRange(1, 1);\n                node.placeholder = '';\n                tick().then(() => {\n                    node.placeholder = '';\n                });\n            }), addMeltEventListener(node, 'blur', () => {\n                node.placeholder = get(placeholder);\n            }));\n            return {\n                destroy() {\n                    unsub();\n                },\n            };\n        },\n    });\n    const hiddenInput = builder(name('hidden-input'), {\n        stores: [value, nameStore],\n        returned: ([$value, $nameStore]) => ({\n            value: $value,\n            name: $nameStore,\n            hidden: true,\n            style: styleToString({\n                display: 'none',\n            }),\n        }),\n    });\n    const clear = () => {\n        value.update((v) => {\n            v.forEach((_, i) => (v[i] = ''));\n            return v;\n        });\n    };\n    return {\n        elements: {\n            root,\n            input,\n            hiddenInput,\n        },\n        states: {\n            value,\n            valueStr: readonly(valueStr),\n        },\n        helpers: {\n            clear,\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, derivedVisible, effect, generateId, getPortalDestination, isBrowser, isHTMLElement, kbd, noop, omit, overridable, removeScroll, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { usePopper } from '../../internal/actions/index.js';\nimport { onMount, tick } from 'svelte';\nimport { writable } from 'svelte/store';\nimport { executeCallbacks } from '../../internal/helpers/callbacks.js';\nconst defaults = {\n    positioning: {\n        placement: 'bottom',\n    },\n    arrowSize: 8,\n    defaultOpen: false,\n    disableFocusTrap: false,\n    closeOnEscape: true,\n    preventScroll: false,\n    onOpenChange: undefined,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    forceVisible: false,\n};\nconst { name } = createElHelpers('popover');\nexport function createPopover(args) {\n    const withDefaults = { ...defaults, ...args };\n    const options = toWritableStores(omit(withDefaults, 'open'));\n    const { positioning, arrowSize, disableFocusTrap, preventScroll, closeOnEscape, closeOnOutsideClick, portal, forceVisible, } = options;\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const activeTrigger = writable(null);\n    const ids = {\n        content: generateId(),\n        trigger: generateId(),\n    };\n    onMount(() => {\n        activeTrigger.set(document.getElementById(ids.trigger));\n    });\n    function handleClose() {\n        open.set(false);\n        const triggerEl = document.getElementById(ids.trigger);\n        if (triggerEl) {\n            tick().then(() => {\n                triggerEl.focus();\n            });\n        }\n    }\n    const isVisible = derivedVisible({ open, activeTrigger, forceVisible });\n    const content = builder(name('content'), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            return {\n                hidden: $isVisible && isBrowser ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: ids.content,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': $portal ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            const unsubDerived = effect([\n                isVisible,\n                activeTrigger,\n                positioning,\n                disableFocusTrap,\n                closeOnEscape,\n                closeOnOutsideClick,\n                portal,\n            ], ([$isVisible, $activeTrigger, $positioning, $disableFocusTrap, $closeOnEscape, $closeOnOutsideClick, $portal,]) => {\n                unsubPopper();\n                if (!$isVisible || !$activeTrigger)\n                    return;\n                const popper = usePopper(node, {\n                    anchorElement: $activeTrigger,\n                    open,\n                    options: {\n                        floating: $positioning,\n                        focusTrap: $disableFocusTrap ? null : undefined,\n                        clickOutside: $closeOnOutsideClick ? undefined : null,\n                        escapeKeydown: $closeOnEscape\n                            ? {\n                                handler: () => {\n                                    handleClose();\n                                },\n                            }\n                            : null,\n                        portal: getPortalDestination(node, $portal),\n                    },\n                });\n                if (popper && popper.destroy) {\n                    unsubPopper = popper.destroy;\n                }\n            });\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubPopper();\n                },\n            };\n        },\n    });\n    function toggleOpen(triggerEl) {\n        open.update((prev) => {\n            return !prev;\n        });\n        if (triggerEl) {\n            activeTrigger.set(triggerEl);\n        }\n    }\n    const trigger = builder(name('trigger'), {\n        stores: open,\n        returned: ($open) => {\n            return {\n                role: 'button',\n                'aria-haspopup': 'dialog',\n                'aria-expanded': $open,\n                'data-state': $open ? 'open' : 'closed',\n                'aria-controls': ids.content,\n                id: ids.trigger,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                toggleOpen(node);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                toggleOpen(node);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const arrow = builder(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    const close = builder(name('close'), {\n        returned: () => ({\n            type: 'button',\n        }),\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleClose();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                toggleOpen();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    effect([open, activeTrigger, preventScroll], ([$open, $activeTrigger, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        const unsubs = [];\n        if ($open) {\n            if (!$activeTrigger) {\n                tick().then(() => {\n                    const triggerEl = document.getElementById(ids.trigger);\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    activeTrigger.set(triggerEl);\n                });\n            }\n            if ($preventScroll) {\n                unsubs.push(removeScroll());\n            }\n        }\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    return {\n        elements: {\n            trigger,\n            content,\n            arrow,\n            close,\n        },\n        states: {\n            open,\n        },\n        options,\n    };\n}\n", "import { builder, createElHelpers, omit, overridable, toWritableStores, } from '../../internal/helpers/index.js';\nimport { writable } from 'svelte/store';\nconst defaults = {\n    defaultValue: 0,\n    max: 100,\n};\nconst { name } = createElHelpers('progress');\nexport const createProgress = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value'));\n    const { max } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    const root = builder(name(), {\n        stores: [value, max],\n        returned: ([$value, $max]) => {\n            return {\n                value: $value,\n                max: $max,\n                role: 'meter',\n                'aria-valuemin': 0,\n                'aria-valuemax': $max,\n                'aria-valuenow': $value,\n                'data-value': $value,\n                'data-state': $value === null ? 'indeterminate' : $value === $max ? 'complete' : 'loading',\n                'data-max': $max,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n        states: {\n            value,\n        },\n        options,\n    };\n};\n", "import { addEventListener, addMeltEventListener, builder, createElHelpers, effect, executeCallbacks, getDirectionalKeys, getElemDirection, isHTMLElement, kbd, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { onMount } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nconst defaults = {\n    orientation: 'vertical',\n    loop: true,\n    disabled: false,\n    required: false,\n    defaultValue: undefined,\n};\nconst { name, selector } = createElHelpers('radio-group');\nexport function createRadioGroup(props) {\n    const withDefaults = { ...defaults, ...props };\n    // options\n    const options = toWritableStores(omit(withDefaults, 'value'));\n    const { disabled, required, loop, orientation } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    /** Lifecycle & Effects */\n    const focusedHistory = {\n        prev: null,\n        curr: null,\n    };\n    onMount(() => {\n        return addEventListener(document, 'focus', (e) => {\n            const focusedItem = e.target;\n            if (!isHTMLElement(focusedItem))\n                return;\n            focusedHistory.prev = focusedHistory.curr;\n            focusedHistory.curr = focusedItem;\n        });\n    });\n    let hasActiveTabIndex = false;\n    effect(value, ($value) => {\n        if ($value === undefined) {\n            hasActiveTabIndex = false;\n        }\n        else {\n            hasActiveTabIndex = true;\n        }\n    });\n    /* Helpers */\n    const selectItem = (item) => {\n        const disabled = item.dataset.disabled === 'true';\n        const itemValue = item.dataset.value;\n        if (disabled || itemValue === undefined)\n            return;\n        value.set(itemValue);\n    };\n    /** Elements */\n    const root = builder(name(), {\n        stores: [required, orientation],\n        returned: ([$required, $orientation]) => {\n            return {\n                role: 'radiogroup',\n                'aria-required': $required,\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    const item = builder(name('item'), {\n        stores: [value, orientation, disabled],\n        returned: ([$value, $orientation, $disabled]) => {\n            return (props) => {\n                const itemValue = typeof props === 'string' ? props : props.value;\n                const argDisabled = typeof props === 'string' ? false : !!props.disabled;\n                const disabled = $disabled || argDisabled;\n                const checked = $value === itemValue;\n                const tabindex = !hasActiveTabIndex ? 0 : checked ? 0 : -1;\n                hasActiveTabIndex = true;\n                return {\n                    disabled,\n                    'data-value': itemValue,\n                    'data-orientation': $orientation,\n                    'data-disabled': disabled ? true : undefined,\n                    'data-state': checked ? 'checked' : 'unchecked',\n                    'aria-checked': checked,\n                    type: 'button',\n                    role: 'radio',\n                    tabindex,\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                selectItem(node);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const el = e.currentTarget;\n                if (!isHTMLElement(el))\n                    return;\n                const root = el.closest(selector());\n                if (!isHTMLElement(root))\n                    return;\n                const items = Array.from(root.querySelectorAll(selector('item'))).filter((el) => isHTMLElement(el));\n                const currentIndex = items.indexOf(el);\n                const dir = getElemDirection(root);\n                const { nextKey, prevKey } = getDirectionalKeys(dir, get(orientation));\n                const $loop = get(loop);\n                let itemToFocus = null;\n                if (e.key === nextKey) {\n                    e.preventDefault();\n                    const nextIndex = currentIndex + 1;\n                    if (nextIndex >= items.length && $loop) {\n                        itemToFocus = items[0];\n                    }\n                    else {\n                        itemToFocus = items[nextIndex];\n                    }\n                }\n                else if (e.key === prevKey) {\n                    e.preventDefault();\n                    const prevIndex = currentIndex - 1;\n                    if (prevIndex < 0 && $loop) {\n                        itemToFocus = items[items.length - 1];\n                    }\n                    else {\n                        itemToFocus = items[prevIndex];\n                    }\n                }\n                else if (e.key === kbd.HOME) {\n                    e.preventDefault();\n                    itemToFocus = items[0];\n                }\n                else if (e.key === kbd.END) {\n                    e.preventDefault();\n                    itemToFocus = items[items.length - 1];\n                }\n                if (itemToFocus) {\n                    itemToFocus.focus();\n                    selectItem(itemToFocus);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const hiddenInput = builder(name('hidden-input'), {\n        stores: [disabled, value, required],\n        returned: ([$disabled, $value, $required]) => {\n            return {\n                'aria-hidden': true,\n                tabindex: -1,\n                disabled: $disabled,\n                value: $value,\n                required: $required,\n                style: styleToString({\n                    'pointer-events': 'none',\n                    position: 'absolute',\n                    opacity: 0,\n                    width: 0,\n                    height: 0,\n                }),\n            };\n        },\n        action: (_node) => {\n            _node;\n            // no-op, just to enforce the type of the element\n        },\n    });\n    const isChecked = derived(value, ($value) => {\n        return (itemValue) => {\n            return $value === itemValue;\n        };\n    });\n    return {\n        elements: {\n            root,\n            item,\n            hiddenInput,\n        },\n        states: {\n            value,\n        },\n        helpers: {\n            isChecked,\n        },\n        options,\n    };\n}\n", "import { createLabel, createSeparator } from '../index.js';\nimport { usePopper } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, SELECTION_KEYS, addEventListener, addHighlight, addMeltEventListener, back, builder, createClickOutsideIgnore, createElHelpers, createTypeaheadSearch, derivedVisible, effect, executeCallbacks, forward, generateId, getFirstOption, getNextFocusable, getOptions, getPortalDestination, getPreviousFocusable, handleRovingFocus, isBrowser, isElementDisabled, isHTMLElement, kbd, last, next, noop, omit, overridable, prev, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, toggle, } from '../../internal/helpers/index.js';\nimport { dequal as deepEqual } from 'dequal';\nimport { onMount, tick } from 'svelte';\nimport { derived, get, writable } from 'svelte/store';\nimport { getElementByMeltId } from '../../internal/helpers/builder';\nconst defaults = {\n    arrowSize: 8,\n    required: false,\n    disabled: false,\n    positioning: {\n        placement: 'bottom',\n        sameWidth: true,\n    },\n    preventScroll: true,\n    loop: false,\n    name: undefined,\n    defaultOpen: false,\n    forceVisible: false,\n    portal: undefined,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n};\nconst { name } = createElHelpers('select');\nexport function createSelect(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores({\n        ...omit(withDefaults, 'selected', 'defaultSelected', 'onSelectedChange', 'onOpenChange', 'open', 'defaultOpen'),\n        multiple: withDefaults.multiple ?? false,\n    });\n    const { positioning, arrowSize, required, disabled, loop, preventScroll, name: nameStore, portal, forceVisible, closeOnEscape, closeOnOutsideClick, multiple, } = options;\n    const openWritable = withDefaults.open ?? writable(false);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);\n    const selected = overridable(selectedWritable, withDefaults?.onSelectedChange);\n    const activeTrigger = writable(null);\n    /**\n     * Keeps track of the next/previous focusable element when the menu closes.\n     * This is because we are portaling the menu to the body and we need\n     * to be able to focus the next element in the DOM when the menu closes.\n     *\n     * Without keeping track of this, the focus would be reset to the top of\n     * the page (or the first focusable element in the body).\n     */\n    const nextFocusable = writable(null);\n    const prevFocusable = writable(null);\n    /**\n     * Keeps track of if the user is using the keyboard to navigate the menu.\n     * This is used to determine how we handle focus on open behavior differently\n     * than when the user is using the mouse.\n     */\n    let isUsingKeyboard = false;\n    const ids = {\n        menu: generateId(),\n        trigger: generateId(),\n        label: generateId(),\n    };\n    const { typed, handleTypeaheadSearch } = createTypeaheadSearch();\n    /* ------- */\n    /* Helpers */\n    /* ------- */\n    const isSelected = derived([selected], ([$selected]) => {\n        return (value) => {\n            if (Array.isArray($selected)) {\n                return $selected.map((o) => o.value).includes(value);\n            }\n            return deepEqual($selected?.value, value);\n        };\n    });\n    function isMouse(e) {\n        return e.pointerType === 'mouse';\n    }\n    function getSelectedOption(menuElement) {\n        const selectedOption = menuElement.querySelector('[data-selected]');\n        return isHTMLElement(selectedOption) ? selectedOption : null;\n    }\n    function onOptionPointerMove(e) {\n        if (!isMouse(e))\n            return;\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget))\n            return;\n        handleRovingFocus(currentTarget);\n    }\n    function onOptionLeave() {\n        const menuElement = document.getElementById(ids.menu);\n        if (!isHTMLElement(menuElement))\n            return;\n        handleRovingFocus(menuElement);\n    }\n    /**\n     * Keyboard event handler for menu navigation\n     * @param e The keyboard event\n     */\n    function handleMenuNavigation(e) {\n        e.preventDefault();\n        // currently focused menu item\n        const currentFocusedItem = document.activeElement;\n        // menu element being navigated\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))\n            return;\n        // menu items of the current menu\n        const items = getOptions(currentTarget);\n        if (!items.length)\n            return;\n        // Disabled items can't be highlighted. Skip them.\n        const candidateNodes = items.filter((opt) => !isElementDisabled(opt));\n        // Get the index of the currently highlighted item.\n        const currentIndex = candidateNodes.indexOf(currentFocusedItem);\n        // Find the next menu item to highlight.\n        let nextItem;\n        const $loop = get(loop);\n        switch (e.key) {\n            case kbd.ARROW_DOWN:\n                nextItem = next(candidateNodes, currentIndex, $loop);\n                break;\n            case kbd.PAGE_DOWN:\n                nextItem = forward(candidateNodes, currentIndex, 10, $loop);\n                break;\n            case kbd.ARROW_UP:\n                nextItem = prev(candidateNodes, currentIndex, $loop);\n                break;\n            case kbd.PAGE_UP:\n                nextItem = back(candidateNodes, currentIndex, 10, $loop);\n                break;\n            case kbd.HOME:\n                nextItem = candidateNodes[0];\n                break;\n            case kbd.END:\n                nextItem = last(candidateNodes);\n                break;\n            default:\n                return;\n        }\n        handleRovingFocus(nextItem);\n    }\n    function handleTabNavigation(e) {\n        if (e.shiftKey) {\n            const $prevFocusable = get(prevFocusable);\n            if ($prevFocusable) {\n                e.preventDefault();\n                $prevFocusable.focus();\n                prevFocusable.set(null);\n            }\n        }\n        else {\n            const $nextFocusable = get(nextFocusable);\n            if ($nextFocusable) {\n                e.preventDefault();\n                $nextFocusable.focus();\n                nextFocusable.set(null);\n            }\n        }\n    }\n    const isVisible = derivedVisible({ open, forceVisible, activeTrigger });\n    const selectedLabel = derived(selected, ($selected) => {\n        if (Array.isArray($selected)) {\n            return $selected.map((o) => o.label).join(', ');\n        }\n        return $selected?.label ?? '';\n    });\n    /* -------- */\n    /* Builders */\n    /* -------- */\n    const menu = builder(name('menu'), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            return {\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: ids.menu,\n                'aria-labelledby': ids.trigger,\n                role: 'listbox',\n                'data-portal': $portal ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            let unsubScroll = noop;\n            const unsubDerived = effect([isVisible, preventScroll, positioning, portal, closeOnEscape, closeOnOutsideClick], ([$isVisible, $preventScroll, $positioning, $portal, $closeOnEscape, $closeOnOutsideClick,]) => {\n                unsubPopper();\n                unsubScroll();\n                const $activeTrigger = get(activeTrigger);\n                if (!($isVisible && $activeTrigger))\n                    return;\n                if ($preventScroll) {\n                    unsubScroll = removeScroll();\n                }\n                const ignoreHandler = createClickOutsideIgnore(ids.trigger);\n                tick().then(() => {\n                    const popper = usePopper(node, {\n                        anchorElement: $activeTrigger,\n                        open,\n                        options: {\n                            floating: $positioning,\n                            clickOutside: $closeOnOutsideClick\n                                ? {\n                                    ignore: ignoreHandler,\n                                }\n                                : null,\n                            escapeKeydown: $closeOnEscape\n                                ? {\n                                    handler: () => {\n                                        open.set(false);\n                                    },\n                                }\n                                : null,\n                            portal: getPortalDestination(node, $portal),\n                        },\n                    });\n                    if (popper && popper.destroy) {\n                        unsubPopper = popper.destroy;\n                    }\n                });\n            });\n            const unsubEventListeners = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const menuEl = e.currentTarget;\n                const target = e.target;\n                if (!isHTMLElement(menuEl) || !isHTMLElement(target))\n                    return;\n                const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                const isCharacterKey = e.key.length === 1;\n                if (e.key === kbd.TAB) {\n                    e.preventDefault();\n                    open.set(false);\n                    handleTabNavigation(e);\n                }\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    e.preventDefault();\n                    if (menuEl === target) {\n                        const selectedOption = getSelectedOption(menuEl);\n                        if (selectedOption) {\n                            handleRovingFocus(selectedOption);\n                            return;\n                        }\n                    }\n                    handleMenuNavigation(e);\n                }\n                if (!isModifierKey && isCharacterKey) {\n                    handleTypeaheadSearch(e.key, getOptions(node));\n                }\n            }));\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubPopper();\n                    unsubScroll();\n                    unsubEventListeners();\n                },\n            };\n        },\n    });\n    const trigger = builder(name('trigger'), {\n        stores: [open, disabled, required],\n        returned: ([$open, $disabled, $required]) => {\n            return {\n                role: 'combobox',\n                type: 'button',\n                'aria-autocomplete': 'none',\n                'aria-haspopup': 'listbox',\n                'aria-controls': ids.menu,\n                'aria-expanded': $open,\n                'aria-required': $required,\n                'data-state': $open ? 'open' : 'closed',\n                'data-disabled': $disabled ? true : undefined,\n                'aria-labelledby': ids.label,\n                'data-melt-id': ids.trigger,\n                disabled: $disabled,\n                id: ids.trigger,\n                tabindex: 0,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                if (get(disabled)) {\n                    e.preventDefault();\n                    return;\n                }\n                const $open = get(open);\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                open.update((prev) => {\n                    const isOpen = !prev;\n                    if (isOpen) {\n                        nextFocusable.set(getNextFocusable(triggerEl));\n                        prevFocusable.set(getPreviousFocusable(triggerEl));\n                        activeTrigger.set(triggerEl);\n                    }\n                    return isOpen;\n                });\n                if (!$open)\n                    e.preventDefault();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                if (SELECTION_KEYS.includes(e.key) ||\n                    e.key === kbd.ARROW_DOWN ||\n                    e.key === kbd.ARROW_UP) {\n                    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {\n                        /**\n                         * We don't want to scroll the page when the user presses the\n                         * down arrow when focused on the trigger, so we prevent that\n                         * default behavior.\n                         */\n                        e.preventDefault();\n                    }\n                    open.update((prev) => {\n                        const isOpen = !prev;\n                        if (isOpen) {\n                            e.preventDefault();\n                            nextFocusable.set(getNextFocusable(triggerEl));\n                            prevFocusable.set(getPreviousFocusable(triggerEl));\n                            activeTrigger.set(triggerEl);\n                        }\n                        return isOpen;\n                    });\n                    const menu = document.getElementById(ids.menu);\n                    if (!menu)\n                        return;\n                    const selectedOption = menu.querySelector('[data-selected]');\n                    if (isHTMLElement(selectedOption)) {\n                        handleRovingFocus(selectedOption);\n                        return;\n                    }\n                    const options = getOptions(menu);\n                    if (!options.length)\n                        return;\n                    handleRovingFocus(options[0]);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    // Use our existing label builder to create a label for the select trigger.\n    const { elements: { root: labelBuilder }, } = createLabel();\n    const { action: labelAction } = get(labelBuilder);\n    const label = builder(name('label'), {\n        returned: () => {\n            return {\n                id: ids.label,\n                for: ids.trigger,\n            };\n        },\n        action: (node) => {\n            const destroy = executeCallbacks(labelAction(node).destroy ?? noop, addMeltEventListener(node, 'click', (e) => {\n                e.preventDefault();\n                const triggerEl = document.getElementById(ids.trigger);\n                if (!isHTMLElement(triggerEl))\n                    return;\n                triggerEl.focus();\n            }));\n            return {\n                destroy,\n            };\n        },\n    });\n    const { elements: { root: separator }, } = createSeparator({\n        decorative: true,\n    });\n    const group = builder(name('group'), {\n        returned: () => {\n            return (groupId) => ({\n                role: 'group',\n                'aria-labelledby': groupId,\n            });\n        },\n    });\n    const groupLabel = builder(name('group-label'), {\n        returned: () => {\n            return (groupId) => ({\n                id: groupId,\n            });\n        },\n    });\n    const arrow = builder(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    const getOptionProps = (el) => {\n        const value = el.getAttribute('data-value');\n        const label = el.getAttribute('data-label');\n        const disabled = el.hasAttribute('data-disabled');\n        return {\n            value: value ? JSON.parse(value) : value,\n            label: label ?? el.textContent ?? undefined,\n            disabled: disabled ? true : false,\n        };\n    };\n    const setOption = (newOption) => {\n        selected.update(($option) => {\n            const $multiple = get(multiple);\n            if ($multiple) {\n                const optionArr = Array.isArray($option) ? $option : [];\n                return toggle(newOption, optionArr);\n            }\n            return newOption;\n        });\n    };\n    const option = builder(name('option'), {\n        stores: selected,\n        returned: ($selected) => {\n            return (props) => {\n                const isSelected = Array.isArray($selected)\n                    ? $selected.map((o) => o.value).includes(props.value)\n                    : deepEqual($selected?.value, props?.value);\n                return {\n                    role: 'option',\n                    'aria-selected': isSelected,\n                    'data-selected': isSelected ? '' : undefined,\n                    'data-value': JSON.stringify(props.value),\n                    'data-label': props.label ?? undefined,\n                    'data-disabled': props.disabled ? '' : undefined,\n                    tabindex: -1,\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                const itemElement = e.currentTarget;\n                if (!isHTMLElement(itemElement))\n                    return;\n                const props = getOptionProps(node);\n                if (props.disabled) {\n                    e.preventDefault();\n                    return;\n                }\n                handleRovingFocus(itemElement);\n                setOption(props);\n                const $multiple = get(multiple);\n                if (!$multiple)\n                    open.set(false);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const $typed = get(typed);\n                const isTypingAhead = $typed.length > 0;\n                if (isTypingAhead && e.key === kbd.SPACE) {\n                    e.preventDefault();\n                    return;\n                }\n                if (e.key === kbd.ENTER || e.key === kbd.SPACE) {\n                    e.preventDefault();\n                    const props = getOptionProps(node);\n                    node.setAttribute('data-selected', '');\n                    setOption(props);\n                    const $multiple = get(multiple);\n                    if (!$multiple)\n                        open.set(false);\n                }\n            }), addMeltEventListener(node, 'pointermove', (e) => {\n                const props = getOptionProps(node);\n                if (props.disabled) {\n                    e.preventDefault();\n                    return;\n                }\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (props.disabled) {\n                    const menuElement = document.getElementById(ids.menu);\n                    if (!menuElement)\n                        return;\n                    handleRovingFocus(menuElement);\n                }\n                onOptionPointerMove(e);\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                if (!isMouse(e))\n                    return;\n                onOptionLeave();\n            }), addMeltEventListener(node, 'focusin', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                addHighlight(itemEl);\n            }), addMeltEventListener(node, 'focusout', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                removeHighlight(itemEl);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const input = builder(name('input'), {\n        stores: [selected, required, disabled, nameStore],\n        returned: ([$value, $required, $disabled, $nameStore]) => {\n            return {\n                type: 'hidden',\n                name: $nameStore,\n                value: $value,\n                'aria-hidden': true,\n                hidden: true,\n                tabIndex: -1,\n                required: $required,\n                disabled: $disabled,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n    });\n    /* ------------------- */\n    /* Lifecycle & Effects */\n    /* ------------------- */\n    onMount(() => {\n        const triggerEl = getElementByMeltId(ids.trigger);\n        if (triggerEl) {\n            activeTrigger.set(triggerEl);\n        }\n    });\n    let hasOpened = false;\n    effect(open, ($open) => {\n        if ($open) {\n            hasOpened = true;\n        }\n    });\n    effect([open, activeTrigger], function handleFocus([$open, $activeTrigger]) {\n        const unsubs = [];\n        if (!isBrowser)\n            return;\n        if ($open && get(preventScroll)) {\n            unsubs.push(removeScroll());\n        }\n        sleep(1).then(() => {\n            const menuEl = document.getElementById(ids.menu);\n            if (menuEl && $open && isUsingKeyboard) {\n                // Focus on selected option or first option\n                const selectedOption = getSelectedOption(menuEl);\n                if (!selectedOption) {\n                    const firstOption = getFirstOption(menuEl);\n                    if (!firstOption)\n                        return;\n                    handleRovingFocus(firstOption);\n                }\n                else {\n                    handleRovingFocus(selectedOption);\n                }\n            }\n            else if (menuEl && $open) {\n                // focus on the menu element\n                handleRovingFocus(menuEl);\n            }\n            else if ($activeTrigger && hasOpened) {\n                // Hacky way to prevent the keydown event from triggering on the trigger\n                handleRovingFocus($activeTrigger);\n            }\n        });\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    effect([open, activeTrigger], ([$open, $activeTrigger]) => {\n        if (!isBrowser)\n            return;\n        const handlePointer = () => (isUsingKeyboard = false);\n        const handleKeyDown = (e) => {\n            isUsingKeyboard = true;\n            if (e.key === kbd.ESCAPE && $open) {\n                open.set(false);\n                if (!$activeTrigger)\n                    return;\n                handleRovingFocus($activeTrigger);\n            }\n        };\n        return executeCallbacks(addEventListener(document, 'keydown', handleKeyDown, { capture: true }), addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true }));\n    });\n    return {\n        elements: {\n            menu,\n            trigger,\n            option,\n            input,\n            group,\n            groupLabel,\n            arrow,\n            separator,\n            label,\n        },\n        states: {\n            open,\n            selected,\n            selectedLabel,\n        },\n        helpers: {\n            isSelected,\n        },\n        options,\n    };\n}\n", "import { builder, toWritableStores } from '../../internal/helpers/index.js';\nconst defaults = {\n    orientation: 'horizontal',\n    decorative: false,\n};\nexport const createSeparator = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { orientation, decorative } = options;\n    const root = builder('separator', {\n        stores: [orientation, decorative],\n        returned: ([$orientation, $decorative]) => {\n            const ariaOrientation = $orientation === 'vertical' ? $orientation : undefined;\n            return {\n                role: $decorative ? 'none' : 'separator',\n                'aria-orientation': ariaOrientation,\n                'aria-hidden': $decorative,\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n        options,\n    };\n};\n", "// reinterpretation of https://github.com/guipn/sinful.js/blob/master/sinful.js\n// to fix floating point arithmetic\nfunction multiplier(x) {\n    const parts = x.toString().split('.');\n    if (parts.length < 2) {\n        return 1;\n    }\n    return Math.pow(10, parts[1].length);\n}\n// Given a variable number of arguments, returns the maximum\n// multiplier that must be used to normalize an operation involving\n// all of them.\nfunction correctionFactor(...args) {\n    return Math.max(...args.map(multiplier));\n}\nexport function add(...args) {\n    const factor = correctionFactor(...args);\n    let sum = 0;\n    for (const number of args) {\n        sum += number * factor;\n    }\n    return sum / factor;\n}\nexport function sub(...[first, ...args]) {\n    const factor = correctionFactor(...args);\n    let sum = first * factor;\n    for (const number of args) {\n        sum -= number * factor;\n    }\n    return sum / factor;\n}\nexport function mul(...args) {\n    let total = 1;\n    for (const number of args) {\n        const factor = correctionFactor(total, number);\n        total = (total * factor * (number * factor)) / (factor * factor);\n    }\n    return total;\n}\nexport function div(...[first, ...args]) {\n    let total = first;\n    for (const number of args) {\n        const factor = correctionFactor(total, number);\n        total = (total * factor) / (number * factor);\n    }\n    return total;\n}\n", "import { addEventListener, addMeltEventListener, builder, createElHelpers, effect, executeCallbacks, generateId, getElementByMeltId, isBrowser, isHTMLElement, kbd, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { add, sub, div, mul } from './helpers.js';\nimport { derived, get, writable } from 'svelte/store';\nconst defaults = {\n    defaultValue: [],\n    min: 0,\n    max: 100,\n    step: 1,\n    orientation: 'horizontal',\n    disabled: false,\n};\nconst { name } = createElHelpers('slider');\nexport const createSlider = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value', 'onValueChange', 'defaultValue'));\n    const { min, max, step, orientation, disabled } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    const isActive = writable(false);\n    const currentThumbIndex = writable(0);\n    const activeThumb = writable(null);\n    const ids = {\n        root: generateId(),\n    };\n    const root = builder(name(), {\n        stores: [disabled, orientation],\n        returned: ([$disabled, $orientation]) => {\n            return {\n                disabled: $disabled,\n                'data-orientation': $orientation,\n                style: $disabled ? undefined : 'touch-action: none;',\n                'data-melt-id': ids.root,\n            };\n        },\n    });\n    const position = derived([min, max], ([$min, $max]) => {\n        return (val) => {\n            const pos = mul(div(sub(val, $min), sub($max, $min)), 100);\n            return pos;\n        };\n    });\n    const range = builder(name('range'), {\n        stores: [value, orientation, position],\n        returned: ([$value, $orientation, $position]) => {\n            const minimum = $value.length > 1 ? $position(Math.min(...$value) ?? 0) : 0;\n            const maximum = 100 - $position(Math.max(...$value) ?? 0);\n            const orientationStyles = $orientation === 'horizontal'\n                ? { left: `${minimum}%`, right: `${maximum}%` }\n                : { top: `${maximum}%`, bottom: `${minimum}%` };\n            return {\n                style: styleToString({\n                    position: 'absolute',\n                    ...orientationStyles,\n                }),\n            };\n        },\n    });\n    const updatePosition = (val, index) => {\n        value.update((prev) => {\n            if (!prev)\n                return [val];\n            const newValue = [...prev];\n            const direction = newValue[index] > val ? -1 : +1;\n            function swap() {\n                newValue[index] = newValue[index + direction];\n                newValue[index + direction] = val;\n                const thumbs = getAllThumbs();\n                if (thumbs) {\n                    thumbs[index + direction].focus();\n                    activeThumb.set({ thumb: thumbs[index + direction], index: index + direction });\n                }\n            }\n            if (direction === -1 && val < newValue[index - 1]) {\n                swap();\n                return newValue;\n            }\n            else if (direction === 1 && val > newValue[index + 1]) {\n                swap();\n                return newValue;\n            }\n            const $min = get(min);\n            const $max = get(max);\n            newValue[index] = Math.min(Math.max(val, $min), $max);\n            return newValue;\n        });\n    };\n    const getAllThumbs = () => {\n        const root = getElementByMeltId(ids.root);\n        if (!root)\n            return null;\n        return Array.from(root.querySelectorAll('[data-melt-part=\"thumb\"]')).filter((thumb) => isHTMLElement(thumb));\n    };\n    const thumb = builder(name('thumb'), {\n        stores: [value, position, min, max, disabled, orientation],\n        returned: ([$value, $position, $min, $max, $disabled, $orientation]) => {\n            let index = -1;\n            return () => {\n                index++;\n                const currentThumb = get(currentThumbIndex);\n                if (currentThumb < $value.length) {\n                    currentThumbIndex.update((prev) => prev + 1);\n                }\n                const thumbPosition = `${$position($value[index])}%`;\n                return {\n                    role: 'slider',\n                    'aria-valuemin': $min,\n                    'aria-valuemax': $max,\n                    'aria-valuenow': $value[index],\n                    'data-melt-part': 'thumb',\n                    style: styleToString({\n                        position: 'absolute',\n                        ...($orientation === 'horizontal'\n                            ? { left: thumbPosition, translate: '-50% 0' }\n                            : { bottom: thumbPosition, translate: '0 50%' }),\n                    }),\n                    tabindex: $disabled ? -1 : 0,\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = addMeltEventListener(node, 'keydown', (event) => {\n                const $min = get(min);\n                const $max = get(max);\n                if (get(disabled))\n                    return;\n                const target = event.currentTarget;\n                if (!isHTMLElement(target))\n                    return;\n                const thumbs = getAllThumbs();\n                if (!thumbs?.length)\n                    return;\n                const index = thumbs.indexOf(target);\n                currentThumbIndex.set(index);\n                if (![\n                    kbd.ARROW_LEFT,\n                    kbd.ARROW_RIGHT,\n                    kbd.ARROW_UP,\n                    kbd.ARROW_DOWN,\n                    kbd.HOME,\n                    kbd.END,\n                ].includes(event.key)) {\n                    return;\n                }\n                event.preventDefault();\n                const $step = get(step);\n                const $value = get(value);\n                const $orientation = get(orientation);\n                switch (event.key) {\n                    case kbd.HOME: {\n                        updatePosition($min, index);\n                        break;\n                    }\n                    case kbd.END: {\n                        updatePosition($max, index);\n                        break;\n                    }\n                    case kbd.ARROW_LEFT: {\n                        if ($orientation !== 'horizontal')\n                            break;\n                        if (event.metaKey) {\n                            updatePosition($min, index);\n                        }\n                        else if ($value[index] > $min) {\n                            const newValue = sub($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        break;\n                    }\n                    case kbd.ARROW_RIGHT: {\n                        if ($orientation !== 'horizontal')\n                            break;\n                        if (event.metaKey) {\n                            updatePosition($max, index);\n                        }\n                        else if ($value[index] < $max) {\n                            const newValue = add($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        break;\n                    }\n                    case kbd.ARROW_UP: {\n                        if (event.metaKey) {\n                            updatePosition($max, index);\n                        }\n                        else if ($value[index] > $min && $orientation === 'vertical') {\n                            const newValue = add($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        else if ($value[index] < $max) {\n                            const newValue = add($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        break;\n                    }\n                    case kbd.ARROW_DOWN: {\n                        if (event.metaKey) {\n                            updatePosition($min, index);\n                        }\n                        else if ($value[index] < $max && $orientation === 'vertical') {\n                            const newValue = sub($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        else if ($value[index] > $min) {\n                            const newValue = sub($value[index], $step);\n                            updatePosition(newValue, index);\n                        }\n                        break;\n                    }\n                }\n            });\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    effect([root, min, max, disabled, orientation, step], ([$root, $min, $max, $disabled, $orientation, $step]) => {\n        if (!isBrowser || $disabled)\n            return;\n        const applyPosition = (clientXY, activeThumbIdx, leftOrBottom, rightOrTop) => {\n            const percent = div(sub(clientXY, leftOrBottom), sub(rightOrTop, leftOrBottom));\n            const val = add(mul(percent, sub($max, $min)), $min);\n            if (val < $min) {\n                updatePosition($min, activeThumbIdx);\n            }\n            else if (val > $max) {\n                updatePosition($max, activeThumbIdx);\n            }\n            else {\n                const step = $step;\n                const newValue = mul(Math.round(div(val, step)), step);\n                updatePosition(newValue, activeThumbIdx);\n            }\n        };\n        const getClosestThumb = (e) => {\n            const thumbs = getAllThumbs();\n            if (!thumbs)\n                return;\n            thumbs.forEach((thumb) => thumb.blur());\n            const distances = thumbs.map((thumb) => {\n                if ($orientation === 'horizontal') {\n                    const { left, right } = thumb.getBoundingClientRect();\n                    return Math.abs(e.clientX - (left + right) / 2);\n                }\n                else {\n                    const { top, bottom } = thumb.getBoundingClientRect();\n                    return Math.abs(e.clientY - (top + bottom) / 2);\n                }\n            });\n            const thumb = thumbs[distances.indexOf(Math.min(...distances))];\n            const index = thumbs.indexOf(thumb);\n            return { thumb, index };\n        };\n        const pointerDown = (e) => {\n            if (e.button !== 0)\n                return;\n            const sliderEl = getElementByMeltId($root['data-melt-id']);\n            const closestThumb = getClosestThumb(e);\n            if (!closestThumb || !sliderEl)\n                return;\n            const target = e.target;\n            if (!isHTMLElement(target) || !sliderEl.contains(target))\n                return;\n            e.preventDefault();\n            activeThumb.set(closestThumb);\n            closestThumb.thumb.focus();\n            isActive.set(true);\n            if ($orientation === 'horizontal') {\n                const { left, right } = sliderEl.getBoundingClientRect();\n                applyPosition(e.clientX, closestThumb.index, left, right);\n            }\n            else {\n                const { top, bottom } = sliderEl.getBoundingClientRect();\n                applyPosition(e.clientY, closestThumb.index, bottom, top);\n            }\n        };\n        const pointerUp = () => {\n            isActive.set(false);\n        };\n        const pointerMove = (e) => {\n            if (!get(isActive))\n                return;\n            const sliderEl = getElementByMeltId($root['data-melt-id']);\n            const closestThumb = get(activeThumb);\n            if (!sliderEl || !closestThumb)\n                return;\n            closestThumb.thumb.focus();\n            if ($orientation === 'horizontal') {\n                const { left, right } = sliderEl.getBoundingClientRect();\n                applyPosition(e.clientX, closestThumb.index, left, right);\n            }\n            else {\n                const { top, bottom } = sliderEl.getBoundingClientRect();\n                applyPosition(e.clientY, closestThumb.index, bottom, top);\n            }\n        };\n        const unsub = executeCallbacks(addEventListener(document, 'pointerdown', pointerDown), addEventListener(document, 'pointerup', pointerUp), addEventListener(document, 'pointerleave', pointerUp), addEventListener(document, 'pointermove', pointerMove));\n        return () => {\n            unsub();\n        };\n    });\n    return {\n        elements: {\n            root,\n            thumb,\n            range,\n        },\n        states: {\n            value,\n        },\n        options,\n    };\n};\n", "import { addMeltEventListener, builder, createElHelpers, kbd, omit, overridable, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { get, writable } from 'svelte/store';\nimport { executeCallbacks } from '../../internal/helpers/callbacks.js';\nconst defaults = {\n    defaultChecked: false,\n    disabled: false,\n    required: false,\n    name: '',\n    value: '',\n};\nconst { name } = createElHelpers('switch');\nexport function createSwitch(props) {\n    const propsWithDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(propsWithDefaults, 'checked'));\n    const { disabled, required, name: nameStore, value } = options;\n    const checkedWritable = propsWithDefaults.checked ?? writable(propsWithDefaults.defaultChecked);\n    const checked = overridable(checkedWritable, propsWithDefaults?.onCheckedChange);\n    function toggleSwitch() {\n        if (get(disabled))\n            return;\n        checked.update((prev) => !prev);\n    }\n    const root = builder(name(), {\n        stores: [checked, disabled, required],\n        returned: ([$checked, $disabled, $required]) => {\n            return {\n                'data-disabled': $disabled,\n                disabled: $disabled,\n                'data-state': $checked ? 'checked' : 'unchecked',\n                type: 'button',\n                role: 'switch',\n                'aria-checked': $checked,\n                'aria-required': $required,\n            };\n        },\n        action(node) {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                toggleSwitch();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                toggleSwitch();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const input = builder(name('input'), {\n        stores: [checked, nameStore, required, disabled, value],\n        returned: ([$checked, $name, $required, $disabled, $value]) => {\n            return {\n                type: 'checkbox',\n                'aria-hidden': true,\n                hidden: true,\n                tabindex: -1,\n                name: $name,\n                value: $value,\n                checked: $checked,\n                required: $required,\n                disabled: $disabled,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n            input,\n        },\n        states: {\n            checked,\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, executeCallbacks, getDirectionalKeys, getElemDirection, isBrowser, isHTMLElement, kbd, last, next, omit, overridable, prev, toWritableStores, } from '../../internal/helpers/index.js';\nimport { get, writable } from 'svelte/store';\nconst defaults = {\n    orientation: 'horizontal',\n    activateOnFocus: true,\n    loop: true,\n    autoSet: true,\n};\nconst { name, selector } = createElHelpers('tabs');\nexport function createTabs(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'defaultValue', 'value', 'onValueChange', 'autoSet'));\n    const { orientation, activateOnFocus, loop } = options;\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    let ssrValue = withDefaults.defaultValue ?? get(value);\n    // Root\n    const root = builder(name(), {\n        stores: orientation,\n        returned: ($orientation) => {\n            return {\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    // List\n    const list = builder(name('list'), {\n        stores: orientation,\n        returned: ($orientation) => {\n            return {\n                role: 'tablist',\n                'aria-orientation': $orientation,\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    const parseTriggerProps = (props) => {\n        if (typeof props === 'string') {\n            return { value: props };\n        }\n        else {\n            return props;\n        }\n    };\n    const trigger = builder(name('trigger'), {\n        stores: [value, orientation],\n        returned: ([$value, $orientation]) => {\n            return (props) => {\n                const { value: tabValue, disabled } = parseTriggerProps(props);\n                if (!$value && !ssrValue && withDefaults.autoSet) {\n                    ssrValue = tabValue;\n                    $value = tabValue;\n                    value.set(tabValue);\n                }\n                const sourceOfTruth = isBrowser ? $value : ssrValue;\n                const isActive = sourceOfTruth === tabValue;\n                return {\n                    type: 'button',\n                    role: 'tab',\n                    'data-state': isActive ? 'active' : 'inactive',\n                    tabindex: isActive ? 0 : -1,\n                    'data-value': tabValue,\n                    'data-orientation': $orientation,\n                    'data-disabled': disabled ? true : undefined,\n                    disabled,\n                };\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'focus', () => {\n                const disabled = node.dataset.disabled === 'true';\n                const tabValue = node.dataset.value;\n                if (get(activateOnFocus) && !disabled && tabValue !== undefined) {\n                    value.set(tabValue);\n                }\n            }), addMeltEventListener(node, 'click', (e) => {\n                node.focus();\n                e.preventDefault();\n                const disabled = node.dataset.disabled === 'true';\n                if (disabled)\n                    return;\n                const tabValue = node.dataset.value;\n                node.focus();\n                if (tabValue !== undefined) {\n                    value.set(tabValue);\n                }\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const tabValue = node.dataset.value;\n                if (!tabValue)\n                    return;\n                const el = e.currentTarget;\n                if (!isHTMLElement(el))\n                    return;\n                const rootEl = el.closest(selector());\n                if (!isHTMLElement(rootEl))\n                    return;\n                const $loop = get(loop);\n                const triggers = Array.from(rootEl.querySelectorAll('[role=\"tab\"]')).filter((trigger) => isHTMLElement(trigger));\n                const enabledTriggers = triggers.filter((el) => !el.hasAttribute('data-disabled'));\n                const triggerIdx = enabledTriggers.findIndex((el) => el === e.target);\n                const dir = getElemDirection(rootEl);\n                const { nextKey, prevKey } = getDirectionalKeys(dir, get(orientation));\n                if (e.key === nextKey) {\n                    e.preventDefault();\n                    const nextEl = next(enabledTriggers, triggerIdx, $loop);\n                    nextEl.focus();\n                }\n                else if (e.key === prevKey) {\n                    e.preventDefault();\n                    const prevEl = prev(enabledTriggers, triggerIdx, $loop);\n                    prevEl.focus();\n                }\n                else if (e.key === kbd.ENTER || e.key === kbd.SPACE) {\n                    e.preventDefault();\n                    value.set(tabValue);\n                }\n                else if (e.key === kbd.HOME) {\n                    e.preventDefault();\n                    const firstTrigger = enabledTriggers[0];\n                    firstTrigger.focus();\n                }\n                else if (e.key === kbd.END) {\n                    e.preventDefault();\n                    const lastTrigger = last(enabledTriggers);\n                    lastTrigger.focus();\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    // Content\n    const content = builder(name('content'), {\n        stores: value,\n        returned: ($value) => {\n            return (tabValue) => {\n                return {\n                    role: 'tabpanel',\n                    // TODO: improve\n                    'aria-labelledby': tabValue,\n                    hidden: isBrowser\n                        ? $value === tabValue\n                            ? undefined\n                            : true\n                        : ssrValue === tabValue\n                            ? undefined\n                            : true,\n                    tabindex: 0,\n                };\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n            list,\n            trigger,\n            content,\n        },\n        states: {\n            value,\n        },\n        options,\n    };\n}\n", "import { addEventListener, builder, createElHelpers, executeCallbacks, } from '../../internal/helpers';\nimport { onMount } from 'svelte';\nimport { get, writable } from 'svelte/store';\nimport { dequal } from 'dequal';\nconst defaults = {\n    exclude: ['h1'],\n    scrollOffset: 0,\n    scrollBehaviour: 'smooth',\n    activeType: 'lowest',\n};\n/**\n * @param args Provide the arguments for the table of contents builder.\n * @param args.selector The id of the container in which the content of the page is.\n * @param args.exclude A list of headings that should be excluded in the table.\n * @param args.scrollOffset The offset that should be added when scrolling to a heading.\n * @param args.scrollBehaviour Describes whether the scroll behaviour should be 'smooth' or 'instant'.\n * @param args.headingFilterFn Allows you to pass a filter function to filter the headings that are returned in the 'headingsTree' store.\n * @param args.scrollFn Overwrite the default scroll function with your own.\n * @param args.activeType Describes which header should be considered active:\n *     - 'none': no intersection observers are added and no headings are considered active\n *     - 'all': all headings with visible content are considered active\n *     - 'lowest': the heading of the lowest visible content is considered active\n *     - 'highest': the heading of the highest visible content is considered active\n *     - 'lowest-parents': parents of the heading with the lowest visible content are also considered active\n *     - 'highest-parents': parents of the heading with the highest visible content are also considered active\n */\nexport function createTableOfContents(args) {\n    const argsWithDefaults = { ...defaults, ...args };\n    const { selector, exclude, activeType, scrollBehaviour, scrollOffset, headingFilterFn, scrollFn, } = argsWithDefaults;\n    const { name } = createElHelpers('table-of-contents');\n    // Variables\n    const possibleHeadings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n    let headingsList = [];\n    let elementsList = [];\n    /** Lookup to see which heading an element belongs to. */\n    let elementHeadingLU = {};\n    /** Lookup to see which parent headings a heading has. */\n    let headingParentsLU = {};\n    /** List of the active parent indexes. */\n    const activeParentIdxs = writable([]);\n    /** List of the indexes of the visible elements. */\n    const visibleElementIdxs = writable([]);\n    let elementTarget = null;\n    let mutationObserver = null;\n    let observer = null;\n    const observer_threshold = 0.25;\n    // Stores\n    const activeHeadingIdxs = writable([]);\n    const headingsTree = writable([]);\n    /**\n     * Create a tree view of our headings so that the hierarchy is represented.\n     * @param arr An array of heading elements.\n     * @param startIndex The parent elements original index in the array.\n     */\n    function createTree(arr, startIndex = 0) {\n        const tree = [];\n        let i = 0;\n        while (i < arr.length) {\n            const node = {\n                title: arr[i].innerText,\n                index: startIndex + i,\n                id: arr[i].id,\n                node: arr[i],\n                children: [],\n            };\n            let j = i + 1;\n            while (j < arr.length &&\n                parseInt(arr[j].tagName.charAt(1)) > parseInt(arr[i].tagName.charAt(1))) {\n                j++;\n            }\n            // Recursive call.\n            node.children = createTree(arr.slice(i + 1, j), startIndex + i + 1);\n            tree.push(node);\n            i = j;\n        }\n        return tree;\n    }\n    function generateInitialLists(elementTarget) {\n        let headingsList = [];\n        let elementsList = [];\n        const includedHeadings = possibleHeadings.filter((h) => !exclude.includes(h));\n        const targetHeaders = elementTarget?.querySelectorAll(includedHeadings.join(', '));\n        // Create a unique ID for each heading which doesn't have one.\n        targetHeaders?.forEach((el) => {\n            if (!el.id) {\n                const uniqueID = el.innerText\n                    .replaceAll(/[^a-zA-Z0-9 ]/g, '')\n                    .replaceAll(' ', '-')\n                    .toLowerCase();\n                el.id = `${uniqueID}`;\n            }\n            headingsList.push(el);\n        });\n        headingsList = [...headingsList];\n        if (headingFilterFn) {\n            headingsList = headingsList.filter((heading) => headingFilterFn(heading));\n        }\n        // Get all elements in our elementTarget and convert it from an HTMLCollection to an array.\n        elementsList = [].slice.call(elementTarget?.getElementsByTagName('*'));\n        // Filter the array, so that only the allowed headings and elements with no children are in the list to avoid problems with elements that wrap around others.\n        elementsList = elementsList.filter((el) => includedHeadings.includes(el.nodeName.toLowerCase()) || el.children.length === 0);\n        // We don't care about elements before our first header element, so we can remove those as well.\n        elementsList.splice(0, elementsList.indexOf(headingsList[0]));\n        return {\n            headingsList,\n            elementsList\n        };\n    }\n    function findParentIdxs() {\n        /** Get all parents for each heading element, by checking\n         *  which previous headings in the list have a lower H value,\n         *  so H1 < H2 < H3 < ...\n         */\n        headingsList.forEach((h, i) => {\n            headingParentsLU[i] = null;\n            let current_heading = h.tagName;\n            let parents = [];\n            for (let j = i - 1; j >= 0; j--) {\n                if (headingsList[j].tagName < current_heading) {\n                    current_heading = headingsList[j].tagName;\n                    parents = [...parents, j];\n                }\n            }\n            headingParentsLU[i] = parents.length > 0 ? parents : null;\n        });\n    }\n    function createElementHeadingLU() {\n        headingsList.forEach((h, i) => {\n            // Find all elements between the current heading and the next one and assign them the current heading.\n            const startIndex = elementsList.indexOf(headingsList[i]);\n            const endIndex = i !== headingsList.length - 1\n                ? elementsList.indexOf(headingsList[i + 1])\n                : elementsList.length;\n            for (let j = startIndex; j < endIndex; j++) {\n                elementHeadingLU[j] = i;\n            }\n        });\n    }\n    function handleElementObservation(entries) {\n        // Iterate through all elements that crossed the observer_threshold.\n        for (let i = 0; i < entries.length; i++) {\n            // Get the index of the observed element in our elementsList, as well as the ToC heading it belongs to.\n            const el_idx = elementsList.indexOf(entries[i].target);\n            const toc_idx = elementHeadingLU[el_idx];\n            let tempVisibleElementIdxs = get(visibleElementIdxs);\n            if (entries[i].intersectionRatio >= observer_threshold) {\n                // Only add the observed element to the visibleElementIdxs list if it isn't added yet.\n                if (tempVisibleElementIdxs.indexOf(el_idx) === -1) {\n                    tempVisibleElementIdxs = [...tempVisibleElementIdxs, el_idx];\n                    visibleElementIdxs.set(tempVisibleElementIdxs);\n                    // Only add active parents if parent headings should be highlighted.\n                    activeParentIdxs.set((activeType === 'highest-parents' || activeType === 'lowest-parents') &&\n                        headingParentsLU[toc_idx]\n                        ? [...get(activeParentIdxs), ...headingParentsLU[toc_idx]]\n                        : []);\n                }\n            }\n            else {\n                // Remove the observed element from the visibleElementIdxs list if the intersection ratio is below the threshold.\n                tempVisibleElementIdxs = tempVisibleElementIdxs.filter((item) => item !== el_idx);\n                visibleElementIdxs.set(tempVisibleElementIdxs);\n                // Remove all parents of obsIndex from the activeParentIdxs list.\n                if ((activeType === 'highest-parents' || activeType === 'lowest-parents') &&\n                    headingParentsLU[toc_idx]) {\n                    headingParentsLU[toc_idx]?.forEach((parent) => {\n                        const tempActiveParentIdxs = get(activeParentIdxs);\n                        const index = tempActiveParentIdxs.indexOf(parent);\n                        tempActiveParentIdxs.splice(index, 1);\n                        activeParentIdxs.set(tempActiveParentIdxs);\n                    });\n                }\n            }\n        }\n        const allActiveHeaderIdxs = Array.from(new Set(get(visibleElementIdxs).map((idx) => elementHeadingLU[idx])));\n        let activeHeaderIdxs;\n        if (allActiveHeaderIdxs.length === 0) {\n            activeHeaderIdxs = [];\n        }\n        else if (activeType === 'highest') {\n            activeHeaderIdxs = [Math.min(...allActiveHeaderIdxs)];\n        }\n        else if (activeType === 'lowest') {\n            activeHeaderIdxs = [Math.max(...allActiveHeaderIdxs)];\n        }\n        else if (activeType === 'all') {\n            activeHeaderIdxs = allActiveHeaderIdxs;\n        }\n        else {\n            const activeHeaderIdx = activeType === 'highest-parents'\n                ? Math.min(...allActiveHeaderIdxs)\n                : Math.max(...allActiveHeaderIdxs);\n            if (headingParentsLU[activeHeaderIdx]) {\n                activeHeaderIdxs = [...headingParentsLU[activeHeaderIdx], activeHeaderIdx];\n            }\n            else {\n                activeHeaderIdxs = [activeHeaderIdx];\n            }\n        }\n        // Set store to active indexes.\n        activeHeadingIdxs.set(activeHeaderIdxs);\n    }\n    /**\n     * Scrolls to the element specified by the selector.\n     * The offset and scroll behaviour are determined by the\n     * builder arguments.\n     *\n     * Source: https://stackoverflow.com/questions/49820013/javascript-scrollintoview-smooth-scroll-and-offset?answertab=scoredesc#tab-top\n     *\n     * @param selector The id of the element.\n     */\n    function scrollToTargetAdjusted(selector) {\n        const element = document.getElementById(selector);\n        if (element) {\n            const elementPosition = element.getBoundingClientRect().top;\n            const offsetPosition = elementPosition + window.scrollY - scrollOffset;\n            window.scrollTo({\n                top: offsetPosition,\n                behavior: scrollBehaviour,\n            });\n        }\n    }\n    const item = builder(name('item'), {\n        stores: activeHeadingIdxs,\n        returned: ($activeHeadingIdxs) => {\n            return (id) => {\n                const idx = headingsList.findIndex((heading) => heading.id === id);\n                const active = $activeHeadingIdxs.includes(idx);\n                return {\n                    'data-id': id,\n                    'data-active': active ? '' : undefined,\n                };\n            };\n        },\n        action: (node) => {\n            const id = node.getAttribute('data-id');\n            const unsub = executeCallbacks(addEventListener(node, 'click', (e) => {\n                e.preventDefault();\n                if (scrollFn) {\n                    scrollFn(`${id}`);\n                }\n                else {\n                    scrollToTargetAdjusted(`${id}`);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    function mutationHandler() {\n        const newElementTarget = document.querySelector(selector);\n        if (!newElementTarget)\n            return;\n        const { headingsList: newHeadingsList, elementsList: newElementsList } = generateInitialLists(newElementTarget);\n        if (dequal(headingsList, newHeadingsList))\n            return;\n        // Update lists and LUs and re-run initialization.\n        headingsList = newHeadingsList;\n        elementsList = newElementsList;\n        headingParentsLU = {};\n        elementHeadingLU = {};\n        initialization();\n    }\n    function initialization() {\n        observer?.disconnect();\n        findParentIdxs();\n        createElementHeadingLU();\n        headingsTree.set(createTree(headingsList));\n        if (activeType !== 'none') {\n            // Create observer and observe all elements.\n            observer = new IntersectionObserver(handleElementObservation, {\n                root: null,\n                threshold: observer_threshold,\n            });\n            elementsList.forEach((el) => observer?.observe(el));\n        }\n    }\n    onMount(() => {\n        elementTarget = document.querySelector(selector);\n        if (!elementTarget)\n            return;\n        ({ headingsList, elementsList } = generateInitialLists(elementTarget));\n        initialization();\n        mutationObserver = new MutationObserver(mutationHandler);\n        mutationObserver.observe(elementTarget, { childList: true, subtree: true });\n        return () => {\n            observer?.disconnect();\n            mutationObserver?.disconnect();\n        };\n    });\n    return {\n        elements: {\n            item\n        },\n        states: {\n            activeHeadingIdxs,\n            headingsTree\n        }\n    };\n}\n", "import { getElementByMeltId, isHTMLElement, isHTMLInputElement, } from '../../internal/helpers/index.js';\nexport function focusInput(id, pos = 'default') {\n    const inputEl = getElementByMeltId(id);\n    if (!isHTMLInputElement(inputEl))\n        return;\n    inputEl.focus();\n    if (pos === 'start') {\n        inputEl.setSelectionRange(0, 0);\n    }\n    else if (pos === 'end') {\n        inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);\n    }\n}\nexport function setSelectedFromEl(el, selected) {\n    if (!el) {\n        selected.set(null);\n        return;\n    }\n    selected.set({\n        id: el.getAttribute('data-tag-id') ?? '',\n        value: el.getAttribute('data-tag-value') ?? '',\n    });\n}\nexport function highlightText(query) {\n    const el = document.querySelector(query);\n    if (!isHTMLElement(el))\n        return;\n    el.focus();\n    const range = document.createRange();\n    range.selectNodeContents(el);\n    const selection = window.getSelection();\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n", "import { builder, createElHelpers, effect, executeCallbacks, generateId, getElementByMeltId, isBrowser, isHTMLElement, kbd, omit, overridable, styleToString, toWritableStores, addMeltEventListener, } from '../../internal/helpers/index.js';\nimport { derived, get, readonly, writable } from 'svelte/store';\nimport { focusInput, highlightText, setSelectedFromEl } from './helpers.js';\nimport { tick } from 'svelte';\nconst defaults = {\n    placeholder: '',\n    disabled: false,\n    editable: true,\n    defaultTags: [],\n    unique: false,\n    trim: true,\n    blur: 'nothing',\n    addOnPaste: false,\n    maxTags: undefined,\n    allowed: [],\n    denied: [],\n    add: undefined,\n    remove: undefined,\n    update: undefined,\n};\nconst { name, attribute, selector } = createElHelpers('tags-input');\nexport function createTagsInput(props) {\n    const withDefaults = { ...defaults, ...props };\n    // UUID for specific containers\n    const ids = {\n        root: generateId(),\n        input: generateId(),\n    };\n    const options = toWritableStores(omit(withDefaults, 'tags'));\n    const { placeholder, disabled, editable, unique, trim, blur, addOnPaste, allowed, denied, add, remove, update, maxTags, } = options;\n    // A store representing the current input value. A readable version is exposed to the\n    // user\n    const inputValue = writable('');\n    // True when the input is invalid\n    const inputInvalid = writable(false);\n    // A store representing the current edit value.\n    const editValue = writable('');\n    // Tags store of type Tag[]\n    //\n    // `withDefaults.tags` can be\n    //   - undefined => set empty []\n    //   - string[]  => generate Tag[] from string[]\n    //   - Tag[]     => set Tag[]\n    const tagsWritable = withDefaults.tags ??\n        writable(withDefaults.defaultTags && withDefaults.defaultTags.length > 0\n            ? typeof withDefaults.defaultTags[0] === 'string'\n                ? withDefaults.defaultTags.map((tag) => ({ id: generateId(), value: tag }))\n                : withDefaults.defaultTags\n            : [] // if undefined)\n        );\n    const tags = overridable(tagsWritable, withDefaults?.onTagsChange);\n    // Selected tag store. When `null`, no tag is selected\n    const selected = writable(withDefaults.selected ?? null);\n    const editing = writable(null);\n    // Run validation checks and if a validation fails return false immediately\n    const isInputValid = (v) => {\n        const $tags = get(tags);\n        const $editing = get(editing);\n        const $allowed = get(allowed);\n        const $denied = get(denied);\n        const $maxTags = get(maxTags);\n        // Trim the validation value before validations\n        if (get(trim))\n            v = v.trim();\n        // Tag uniqueness\n        if (get(unique) && $editing?.value !== v) {\n            const index = $tags.findIndex((tag) => tag.value === v);\n            if (index >= 0)\n                return false;\n        }\n        // Allowed list is populated and this value is not in it\n        if ($allowed && $allowed.length > 0 && !$allowed.includes(v))\n            return false;\n        // Deny list is populated and this value is in it\n        if ($denied && $denied.length > 0 && $denied.includes(v))\n            return false;\n        if ($maxTags && $maxTags > 0 && $tags.length >= $maxTags)\n            return false;\n        return true;\n    };\n    // Add a tag to the $tags store. Calls `$options.add()` if set\n    const addTag = async (v) => {\n        const $add = get(add);\n        let workingTag = { id: '', value: v };\n        if ($add) {\n            try {\n                const res = await $add(v);\n                if (typeof res === 'string')\n                    workingTag.value = res;\n                else\n                    workingTag = res;\n                if (!workingTag.id)\n                    workingTag.id = generateId();\n            }\n            catch {\n                return false;\n            }\n        }\n        else {\n            workingTag.id = generateId();\n        }\n        // Trim the value, only after the user defined add function\n        if (get(trim))\n            workingTag.value = workingTag.value.trim();\n        // if it's not valid we don't add it to the tags list\n        if (!isInputValid(workingTag.value))\n            return false;\n        tags.update((current) => {\n            current.push(workingTag);\n            return current;\n        });\n        return true;\n    };\n    // Update a tag in the $tags store. Calls `$options.update()` if set\n    async function updateTag(tag, select = false) {\n        const $update = get(update);\n        // Store the id, incase it changes during the update\n        const oldId = tag.id;\n        let workingTag = tag;\n        if ($update) {\n            try {\n                const res = await $update(workingTag);\n                workingTag = res;\n                // If the id was wiped, give it a new one\n                if (!workingTag.id)\n                    workingTag.id = generateId();\n            }\n            catch {\n                return false;\n            }\n        }\n        // Trim the value, only after the user defined update function\n        if (get(trim))\n            workingTag.value = workingTag.value.trim();\n        // if it's not valid we don't add it to the tags list\n        if (!isInputValid(workingTag.value))\n            return false;\n        // Update the tag matching the old id\n        tags.update(($tags) => {\n            return $tags.map((t) => {\n                if (t.id === oldId) {\n                    return workingTag;\n                }\n                return t;\n            });\n        });\n        if (select)\n            selected.set(workingTag);\n        return true;\n    }\n    // Remove a tag from the $tags store. Calls `$options.remove()` if set\n    async function removeTag(t) {\n        const $remove = get(remove);\n        if ($remove) {\n            try {\n                if (!(await $remove(t)))\n                    return false;\n            }\n            catch {\n                return false;\n            }\n        }\n        const $tags = get(tags);\n        const index = $tags.findIndex((tag) => tag.id === t.id);\n        tags.update((t) => {\n            t.splice(index, 1);\n            return t;\n        });\n        return true;\n    }\n    const root = builder(name(''), {\n        stores: disabled,\n        returned: ($disabled) => {\n            return {\n                'data-melt-id': ids.root,\n                'data-disabled': $disabled ? true : undefined,\n                disabled: $disabled,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'mousedown', (e) => {\n                // Focus on input when root is the target\n                const target = e.target;\n                if (!isHTMLElement(target))\n                    return;\n                if (target.hasAttribute(attribute())) {\n                    e.preventDefault();\n                    focusInput(ids.input);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const input = builder(name('input'), {\n        stores: [disabled, placeholder],\n        returned: ([$disabled, $placeholder]) => {\n            return {\n                'data-melt-id': ids.input,\n                'data-disabled': $disabled ? '' : undefined,\n                disabled: $disabled,\n                placeholder: $placeholder,\n            };\n        },\n        action: (node) => {\n            const getTagsInfo = (id) => {\n                const rootEl = getElementByMeltId(ids.root);\n                let tagsEl = [];\n                let selectedIndex = -1;\n                let prevIndex = -1;\n                let nextIndex = -1;\n                if (rootEl) {\n                    tagsEl = Array.from(rootEl.querySelectorAll(selector('tag')));\n                    selectedIndex = tagsEl.findIndex((element) => element.getAttribute('data-tag-id') === id);\n                    prevIndex = selectedIndex - 1;\n                    nextIndex = selectedIndex + 1;\n                }\n                return {\n                    tagsEl,\n                    selectedIndex,\n                    prevIndex,\n                    nextIndex,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'focus', () => {\n                // Set data-focus on root and input\n                const rootEl = getElementByMeltId(ids.root);\n                if (rootEl)\n                    rootEl.setAttribute('data-focus', '');\n                node.setAttribute('data-focus', '');\n            }), addMeltEventListener(node, 'blur', async () => {\n                // Clear data-focus from root and input\n                const rootEl = getElementByMeltId(ids.root);\n                if (rootEl)\n                    rootEl.removeAttribute('data-focus');\n                node.removeAttribute('data-focus');\n                // Clear selected tag\n                selected.set(null);\n                // Do nothing when input is empty\n                const value = node.value;\n                if (!value)\n                    return;\n                // Handle clear or add (if set)\n                const $blur = get(blur);\n                if ($blur === 'clear') {\n                    node.value = '';\n                }\n                else if ($blur === 'add') {\n                    if (isInputValid(value) && (await addTag(value))) {\n                        node.value = '';\n                        inputValue.set('');\n                    }\n                    else {\n                        inputInvalid.set(true);\n                    }\n                }\n            }), addMeltEventListener(node, 'paste', async (e) => {\n                // Do nothing when there is nothing to paste\n                if (!e.clipboardData)\n                    return;\n                const pastedText = e.clipboardData.getData('text');\n                if (!pastedText)\n                    return;\n                // Do nothing when addOnPaste is false\n                if (!get(addOnPaste))\n                    return;\n                // Update value with the pasted text or set invalid\n                if (isInputValid(pastedText) && (await addTag(pastedText))) {\n                    node.value = '';\n                }\n                else {\n                    inputInvalid.set(true);\n                }\n            }), addMeltEventListener(node, 'keydown', async (e) => {\n                const $selected = get(selected);\n                if ($selected) {\n                    // Check if a character is entered into the input\n                    if (e.key.length === 1) {\n                        selected.set(null);\n                    }\n                    else if (e.key === kbd.ARROW_LEFT) {\n                        // Move to the previous tag\n                        e.preventDefault();\n                        const { tagsEl, prevIndex } = getTagsInfo($selected.id);\n                        if (prevIndex >= 0) {\n                            setSelectedFromEl(tagsEl[prevIndex], selected);\n                        }\n                    }\n                    else if (e.key === kbd.ARROW_RIGHT) {\n                        // Move to the next element of tag or input\n                        e.preventDefault();\n                        const { tagsEl, nextIndex } = getTagsInfo($selected.id);\n                        if (nextIndex === -1 || nextIndex >= tagsEl.length) {\n                            selected.set(null);\n                            focusInput(ids.input, 'start');\n                        }\n                        else {\n                            setSelectedFromEl(tagsEl[nextIndex], selected);\n                        }\n                    }\n                    else if (e.key === kbd.HOME) {\n                        // Jump to the first tag or do nothing\n                        e.preventDefault();\n                        const { tagsEl } = getTagsInfo($selected.id);\n                        if (tagsEl.length > 0)\n                            setSelectedFromEl(tagsEl[0], selected);\n                    }\n                    else if (e.key === kbd.END) {\n                        // Jump to the input\n                        e.preventDefault();\n                        selected.set(null);\n                        focusInput(ids.input);\n                    }\n                    else if (e.key === kbd.DELETE) {\n                        // Delete this tag and move to the next element of tag or input\n                        e.preventDefault();\n                        const prevSelected = $selected;\n                        const { tagsEl, nextIndex } = getTagsInfo($selected.id);\n                        if (nextIndex === -1 || nextIndex >= tagsEl.length) {\n                            selected.set(null);\n                            focusInput(ids.input);\n                        }\n                        else {\n                            setSelectedFromEl(tagsEl[nextIndex], selected);\n                        }\n                        // Delete the previously selected tag\n                        if (!(await removeTag(prevSelected)))\n                            selected.set(prevSelected);\n                    }\n                    else if (e.key === kbd.BACKSPACE) {\n                        // Delete this tag and move to the previous tag. If this is the\n                        // first tag, delete and move to the next element of tag or input\n                        e.preventDefault();\n                        const prevSelected = $selected;\n                        const { tagsEl, nextIndex, prevIndex } = getTagsInfo($selected.id);\n                        if (prevIndex >= 0) {\n                            setSelectedFromEl(tagsEl[prevIndex], selected);\n                        }\n                        else {\n                            if (nextIndex === -1 || nextIndex >= tagsEl.length) {\n                                selected.set(null);\n                                focusInput(ids.input, 'start');\n                            }\n                            else {\n                                setSelectedFromEl(tagsEl[nextIndex], selected);\n                            }\n                        }\n                        // Delete the previously selected tag\n                        if (!(await removeTag(prevSelected)))\n                            selected.set(prevSelected);\n                    }\n                    else if (e.key === kbd.ENTER) {\n                        // Start editing this selected tag\n                        e.preventDefault();\n                        // Do nothing when there is no edit container\n                        const editEl = document.querySelector(selector('edit') + `[data-tag-id=\"${$selected.id}\"]`);\n                        if (!editEl)\n                            return;\n                        editing.set({ id: $selected.id, value: $selected.value });\n                        editEl.textContent = $selected.value;\n                        // Let it become visible then select all\n                        await tick();\n                        highlightText(selector('edit') + `[data-tag-id=\"${$selected.id}\"]`);\n                    }\n                }\n                else {\n                    if (e.key === kbd.ENTER) {\n                        // Add a new tag (if valid)\n                        e.preventDefault();\n                        const value = node.value;\n                        if (!value)\n                            return;\n                        if (isInputValid(value) && (await addTag(value))) {\n                            node.value = '';\n                            inputValue.set('');\n                        }\n                        else {\n                            inputInvalid.set(true);\n                        }\n                    }\n                    else if (node.selectionStart === 0 &&\n                        node.selectionEnd === 0 &&\n                        (e.key === kbd.ARROW_LEFT || e.key === kbd.BACKSPACE)) {\n                        // At the start of the input. Move the the last tag (if there is one)\n                        e.preventDefault();\n                        const { tagsEl } = getTagsInfo('');\n                        const lastTag = tagsEl.at(-1);\n                        if (!lastTag)\n                            return;\n                        setSelectedFromEl(lastTag, selected);\n                    }\n                }\n            }), addMeltEventListener(node, 'input', () => {\n                inputValue.set(node.value);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const tag = builder(name('tag'), {\n        stores: [selected, editing, disabled, editable],\n        returned: ([$selected, $editing, $disabled, $editable]) => {\n            return (tag) => {\n                const disabled = $disabled || tag.disabled;\n                const editable = $editable && tag.editable !== false;\n                const selected = disabled ? undefined : $selected?.id === tag?.id;\n                const editing = editable ? $editing?.id === tag?.id : undefined;\n                return {\n                    'aria-hidden': editing,\n                    'aria-selected': selected,\n                    'data-tag-id': tag.id,\n                    'data-tag-value': tag.value,\n                    'data-selected': selected ? '' : undefined,\n                    'data-editable': editable ? '' : undefined,\n                    'data-editing': editing ? '' : undefined,\n                    'data-disabled': disabled ? '' : undefined,\n                    disabled: disabled,\n                    hidden: editing,\n                    tabindex: -1,\n                    style: editing\n                        ? styleToString({\n                            position: 'absolute',\n                            opacity: 0,\n                            'pointer-events': 'none',\n                            margin: 0,\n                        })\n                        : undefined,\n                };\n            };\n        },\n        action: (node) => {\n            const getElProps = () => {\n                const id = node.getAttribute('data-tag-id') ?? '';\n                return {\n                    id,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'mousedown', (e) => {\n                // Do nothing when editing any tag\n                const $editing = get(editing);\n                if ($editing && $editing.id !== getElProps().id)\n                    return;\n                // Focus on the input and set this as the selected tag\n                focusInput(ids.input);\n                e.preventDefault();\n                setSelectedFromEl(node, selected);\n                editing.set(null);\n            }), addMeltEventListener(node, 'click', (e) => {\n                // Do nothing when editing any tag\n                const $editing = get(editing);\n                if ($editing && $editing.id === getElProps().id)\n                    return;\n                // Focus on the input and set this as the selected tag\n                focusInput(ids.input);\n                e.preventDefault();\n                setSelectedFromEl(node, selected);\n                editing.set(null);\n            }), addMeltEventListener(node, 'dblclick', async () => {\n                if (!isBrowser)\n                    return;\n                // Do nothing when it is not editable\n                if (!node.hasAttribute('data-editable'))\n                    return;\n                // Do nothing when there is no edit container\n                const editEl = document.querySelector(selector('edit') + `[data-tag-id=\"${getElProps().id}\"]`);\n                if (!editEl)\n                    return;\n                // Start editing this tag\n                const value = node.getAttribute('data-tag-value') ?? '';\n                editing.set({\n                    id: node.getAttribute('data-tag-id') ?? '',\n                    value,\n                });\n                editEl.textContent = value;\n                // Let it become visible then select all text\n                await tick();\n                highlightText(selector('edit') + `[data-tag-id=\"${getElProps().id}\"]`);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const deleteTrigger = builder(name('delete-trigger'), {\n        stores: [selected, editing, disabled, editable],\n        returned: ([$selected, $editing, $disabled, $editable]) => {\n            return (tag) => {\n                const disabled = $disabled || tag.disabled;\n                const editable = $editable && tag.editable !== false;\n                const selected = disabled ? undefined : $selected?.id === tag?.id;\n                const editing = editable ? $editing?.id === tag?.id : undefined;\n                return {\n                    'aria-selected': selected,\n                    'data-tag-id': tag.id,\n                    'data-tag-value': tag.value,\n                    'data-selected': selected ? '' : undefined,\n                    'data-editing': editing ? '' : undefined,\n                    'data-disabled': disabled ? '' : undefined,\n                    disabled: disabled,\n                    tabindex: -1,\n                };\n            };\n        },\n        action: (node) => {\n            function handleDelete() {\n                if (node.hasAttribute('data-disabled'))\n                    return;\n                // Remove the tag and put focus on the input\n                const value = node.getAttribute('data-tag-value') ?? '';\n                const id = node.getAttribute('data-tag-id') ?? '';\n                removeTag({ id, value });\n                focusInput(ids.input);\n            }\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                // Do nothing when disabled\n                e.stopPropagation();\n                handleDelete();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                handleDelete();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const edit = builder(name('edit'), {\n        stores: [editing, editable],\n        returned: ([$editing, $editable]) => {\n            return (tag) => {\n                const editable = $editable;\n                const editing = editable ? $editing?.id === tag.id : undefined;\n                return {\n                    'aria-hidden': !editing,\n                    'data-tag-id': tag.id,\n                    'data-tag-value': tag.value,\n                    hidden: !editing ? true : undefined,\n                    contenteditable: editing,\n                    tabindex: -1,\n                    style: !editing\n                        ? styleToString({\n                            position: 'absolute',\n                            opacity: 0,\n                            'pointer-events': 'none',\n                            margin: 0,\n                        })\n                        : undefined,\n                };\n            };\n        },\n        action: (node) => {\n            const getElProps = () => {\n                const id = node.getAttribute('data-tag-id') ?? '';\n                const value = node.getAttribute('data-tag-value') ?? '';\n                return {\n                    id,\n                    value,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'blur', () => {\n                if (node.hasAttribute('hidden'))\n                    return;\n                // Stop editing, reset the value to the original and clear an invalid state\n                editing.set(null);\n                node.textContent = getElProps().value;\n                getElementByMeltId(ids.root)?.removeAttribute('data-invalid-edit');\n                node.removeAttribute('data-invalid-edit');\n            }), addMeltEventListener(node, 'keydown', async (e) => {\n                if (node.hasAttribute('hidden'))\n                    return;\n                if (e.key === kbd.ENTER) {\n                    // Capture the edit value, validate and then update\n                    e.preventDefault();\n                    // Do nothing when the value is empty\n                    const value = node.textContent;\n                    if (!value)\n                        return;\n                    const t = { id: getElProps().id, value };\n                    if (isInputValid(value) && (await updateTag(t, true))) {\n                        node.textContent = t.value;\n                        editValue.set('');\n                        focusInput(ids.input);\n                    }\n                    else {\n                        getElementByMeltId(ids.root)?.setAttribute('data-invalid-edit', '');\n                        node.setAttribute('data-invalid-edit', '');\n                    }\n                }\n                else if (e.key === kbd.ESCAPE) {\n                    // Reset the value, clear the edit value store, set this tag as\n                    // selected and focus on input\n                    e.preventDefault();\n                    node.textContent = getElProps().value;\n                    editValue.set('');\n                    setSelectedFromEl(node, selected);\n                    focusInput(ids.input);\n                }\n            }), addMeltEventListener(node, 'input', () => {\n                if (node.hasAttribute('hidden'))\n                    return;\n                // Update the edit value store\n                editValue.set(node.textContent || '');\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    // Used to determine if a tag is selected\n    const isSelected = derived(selected, ($selected) => {\n        return (tag) => $selected?.id === tag.id;\n    });\n    // When the input value changes, set inputInvalid to false\n    effect(inputValue, () => {\n        inputInvalid.set(false);\n    });\n    // Flip the data-invalid attribute based upon the inputInvalid store\n    effect(inputInvalid, ($inputInvalid) => {\n        if ($inputInvalid) {\n            getElementByMeltId(ids.root)?.setAttribute('data-invalid', '');\n            getElementByMeltId(ids.input)?.setAttribute('data-invalid', '');\n        }\n        else {\n            getElementByMeltId(ids.root)?.removeAttribute('data-invalid');\n            getElementByMeltId(ids.input)?.removeAttribute('data-invalid');\n        }\n    });\n    // When the input valid changes, clear any potential invalid states\n    effect(editValue, () => {\n        if (!isBrowser)\n            return;\n        getElementByMeltId(ids.root)?.removeAttribute('data-invalid-edit');\n        const invalidEl = Array.from(document.querySelectorAll(selector('edit') + '[data-invalid-edit]'));\n        invalidEl.forEach((e) => {\n            e.removeAttribute('data-invalid-edit');\n        });\n    });\n    return {\n        elements: {\n            root,\n            input,\n            deleteTrigger,\n            edit,\n            tag,\n        },\n        states: {\n            tags,\n            inputValue: readonly(inputValue),\n            inputInvalid: readonly(inputInvalid),\n            selected: readonly(selected),\n        },\n        helpers: {\n            isSelected,\n            isInputValid,\n            addTag,\n            updateTag,\n            removeTag,\n        },\n        options,\n    };\n}\n", "import { derived, get, writable, readonly } from 'svelte/store';\nimport { builder, createElHelpers, executeCallbacks, generateId, isTouch, noop, toWritableStores, addMeltEventListener, kbd, } from '../../internal/helpers/index.js';\nimport { usePortal } from '../../internal/actions/index.js';\nconst { name } = createElHelpers('toast');\nconst defaults = {\n    closeDelay: 5000,\n    type: 'foreground',\n};\nexport function createToaster(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { closeDelay, type } = options;\n    const toastsMap = writable(new Map());\n    const addToast = (props) => {\n        const propsWithDefaults = {\n            closeDelay: get(closeDelay),\n            type: get(type),\n            ...props,\n        };\n        const ids = {\n            content: generateId(),\n            title: generateId(),\n            description: generateId(),\n        };\n        const timeout = propsWithDefaults.closeDelay === 0\n            ? null\n            : window.setTimeout(() => {\n                removeToast(ids.content);\n            }, propsWithDefaults.closeDelay);\n        const getPercentage = () => {\n            const { createdAt, pauseDuration, closeDelay, pausedAt } = toast;\n            if (closeDelay === 0)\n                return 0;\n            if (pausedAt) {\n                return (100 * (pausedAt - createdAt - pauseDuration)) / closeDelay;\n            }\n            else {\n                const now = performance.now();\n                return (100 * (now - createdAt - pauseDuration)) / closeDelay;\n            }\n        };\n        const toast = {\n            id: ids.content,\n            ids,\n            ...propsWithDefaults,\n            timeout,\n            createdAt: performance.now(),\n            pauseDuration: 0,\n            getPercentage,\n        };\n        toastsMap.update((currentMap) => {\n            currentMap.set(ids.content, toast);\n            return new Map(currentMap);\n        });\n        return toast;\n    };\n    const removeToast = (id) => {\n        toastsMap.update((currentMap) => {\n            currentMap.delete(id);\n            return new Map(currentMap);\n        });\n    };\n    const updateToast = (id, data) => {\n        toastsMap.update((currentMap) => {\n            const toast = currentMap.get(id);\n            if (!toast)\n                return currentMap;\n            currentMap.set(id, { ...toast, data });\n            return new Map(currentMap);\n        });\n    };\n    const content = builder(name('content'), {\n        stores: toastsMap,\n        returned: ($toasts) => {\n            return (id) => {\n                const t = $toasts.get(id);\n                if (!t)\n                    return null;\n                const { ...toast } = t;\n                return {\n                    id,\n                    role: 'alert',\n                    'aria-describedby': toast.ids.description,\n                    'aria-labelledby': toast.ids.title,\n                    'aria-live': toast.type === 'foreground' ? 'assertive' : 'polite',\n                    tabindex: -1,\n                };\n            };\n        },\n        action: (node) => {\n            let destroy = noop;\n            destroy = executeCallbacks(addMeltEventListener(node, 'pointerenter', (e) => {\n                if (isTouch(e))\n                    return;\n                toastsMap.update((currentMap) => {\n                    const currentToast = currentMap.get(node.id);\n                    if (!currentToast || currentToast.closeDelay === 0)\n                        return currentMap;\n                    if (currentToast.timeout !== null) {\n                        window.clearTimeout(currentToast.timeout);\n                    }\n                    currentToast.pausedAt = performance.now();\n                    return new Map(currentMap);\n                });\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                if (isTouch(e))\n                    return;\n                toastsMap.update((currentMap) => {\n                    const currentToast = currentMap.get(node.id);\n                    if (!currentToast || currentToast.closeDelay === 0)\n                        return currentMap;\n                    const pausedAt = currentToast.pausedAt ?? currentToast.createdAt;\n                    const elapsed = pausedAt - currentToast.createdAt - currentToast.pauseDuration;\n                    const remaining = currentToast.closeDelay - elapsed;\n                    currentToast.timeout = window.setTimeout(() => {\n                        removeToast(node.id);\n                    }, remaining);\n                    currentToast.pauseDuration += performance.now() - pausedAt;\n                    currentToast.pausedAt = undefined;\n                    return new Map(currentMap);\n                });\n            }), () => {\n                removeToast(node.id);\n            });\n            return {\n                destroy,\n            };\n        },\n    });\n    const title = builder(name('title'), {\n        stores: toastsMap,\n        returned: ($toasts) => {\n            return (id) => {\n                const toast = $toasts.get(id);\n                if (!toast)\n                    return null;\n                return {\n                    id: toast.ids.title,\n                };\n            };\n        },\n    });\n    const description = builder(name('description'), {\n        stores: toastsMap,\n        returned: ($toasts) => {\n            return (id) => {\n                const toast = $toasts.get(id);\n                if (!toast)\n                    return null;\n                return {\n                    id: toast.ids.description,\n                };\n            };\n        },\n    });\n    const close = builder(name('close'), {\n        returned: () => {\n            return (id) => ({\n                type: 'button',\n                'data-id': id,\n            });\n        },\n        action: (node) => {\n            function handleClose() {\n                if (!node.dataset.id)\n                    return;\n                removeToast(node.dataset.id);\n            }\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleClose();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                handleClose();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const toasts = derived(toastsMap, ($toastsMap) => {\n        return Array.from($toastsMap.values());\n    });\n    return {\n        elements: {\n            content,\n            title,\n            description,\n            close,\n        },\n        states: {\n            toasts: readonly(toasts),\n        },\n        helpers: {\n            addToast,\n            removeToast,\n            updateToast,\n        },\n        actions: {\n            portal: usePortal,\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, executeCallbacks, kbd, omit, overridable, toWritableStores, } from '../../internal/helpers/index.js';\nimport { get, writable } from 'svelte/store';\nconst defaults = {\n    defaultPressed: false,\n    disabled: false,\n};\nexport function createToggle(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'pressed'));\n    const { disabled } = options;\n    const pressedWritable = withDefaults.pressed ?? writable(withDefaults.defaultPressed);\n    const pressed = overridable(pressedWritable, withDefaults?.onPressedChange);\n    function handleToggle() {\n        const $disabled = get(disabled);\n        if ($disabled)\n            return;\n        pressed.update((v) => !v);\n    }\n    const root = builder('toggle', {\n        stores: [pressed, disabled],\n        returned: ([$pressed, $disabled]) => {\n            return {\n                'data-disabled': $disabled ? true : undefined,\n                disabled: $disabled,\n                'data-state': $pressed ? 'on' : 'off',\n                'aria-pressed': $pressed,\n                type: 'button',\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleToggle();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                handleToggle();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n        states: {\n            pressed,\n        },\n        options,\n    };\n}\n", "import { addMeltEventListener, builder, createElHelpers, executeCallbacks, getElemDirection, handleRovingFocus, isHTMLElement, kbd, noop, omit, overridable, toWritableStores, } from '../../internal/helpers/index.js';\nimport { derived, get, writable } from 'svelte/store';\nconst defaults = {\n    type: 'single',\n    orientation: 'horizontal',\n    loop: true,\n    rovingFocus: true,\n    disabled: false,\n    defaultValue: '',\n};\nconst { name, selector } = createElHelpers('toggle-group');\nexport const createToggleGroup = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value'));\n    const { type, orientation, loop, rovingFocus, disabled } = options;\n    const defaultValue = withDefaults.defaultValue\n        ? withDefaults.defaultValue\n        : withDefaults.type === 'single'\n            ? 'undefined'\n            : [];\n    const valueWritable = withDefaults.value ?? writable(defaultValue);\n    const value = overridable(valueWritable, withDefaults?.onValueChange);\n    const root = builder(name(), {\n        stores: orientation,\n        returned: ($orientation) => {\n            return {\n                role: 'group',\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    const item = builder(name('item'), {\n        stores: [value, disabled, orientation, type],\n        returned: ([$value, $disabled, $orientation, $type]) => {\n            return (props) => {\n                const itemValue = typeof props === 'string' ? props : props.value;\n                const argDisabled = typeof props === 'string' ? false : !!props.disabled;\n                const disabled = $disabled || argDisabled;\n                const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;\n                return {\n                    disabled,\n                    pressed,\n                    'data-orientation': $orientation,\n                    'data-disabled': disabled ? true : undefined,\n                    'data-state': pressed ? 'on' : 'off',\n                    'data-value': itemValue,\n                    'aria-pressed': pressed,\n                    type: 'button',\n                    role: $type === 'single' ? 'radio' : undefined,\n                    tabindex: pressed ? 0 : -1,\n                };\n            };\n        },\n        action: (node) => {\n            let unsub = noop;\n            const parentGroup = node.closest(selector());\n            if (!isHTMLElement(parentGroup))\n                return {};\n            const items = Array.from(parentGroup.querySelectorAll(selector('item')));\n            const $value = get(value);\n            const anyPressed = Array.isArray($value) ? $value.length > 0 : $value !== null;\n            if (!anyPressed && items[0] === node) {\n                node.tabIndex = 0;\n            }\n            function getNodeProps() {\n                const itemValue = node.dataset.value;\n                const disabled = node.dataset.disabled === 'true';\n                return { value: itemValue, disabled };\n            }\n            function handleValueUpdate() {\n                const { value: itemValue, disabled } = getNodeProps();\n                if (itemValue === undefined || disabled)\n                    return;\n                value.update(($value) => {\n                    if (Array.isArray($value)) {\n                        if ($value.includes(itemValue)) {\n                            return $value.filter((i) => i !== itemValue);\n                        }\n                        $value.push(itemValue);\n                        return $value;\n                    }\n                    return $value === itemValue ? undefined : itemValue;\n                });\n            }\n            unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleValueUpdate();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n                    e.preventDefault();\n                    handleValueUpdate();\n                    return;\n                }\n                if (!get(rovingFocus))\n                    return;\n                const el = e.currentTarget;\n                if (!isHTMLElement(el))\n                    return;\n                const root = el.closest(selector());\n                if (!isHTMLElement(root))\n                    return;\n                const items = Array.from(root.querySelectorAll(selector('item') + ':not([data-disabled])')).filter((item) => isHTMLElement(item));\n                const currentIndex = items.indexOf(el);\n                const dir = getElemDirection(el);\n                const $orientation = get(orientation);\n                const nextKey = {\n                    horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n                    vertical: kbd.ARROW_DOWN,\n                }[$orientation ?? 'horizontal'];\n                const prevKey = {\n                    horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n                    vertical: kbd.ARROW_UP,\n                }[$orientation ?? 'horizontal'];\n                const $loop = get(loop);\n                if (e.key === nextKey) {\n                    e.preventDefault();\n                    const nextIndex = currentIndex + 1;\n                    if (nextIndex >= items.length && $loop) {\n                        handleRovingFocus(items[0]);\n                    }\n                    else {\n                        handleRovingFocus(items[nextIndex]);\n                    }\n                }\n                else if (e.key === prevKey) {\n                    e.preventDefault();\n                    const prevIndex = currentIndex - 1;\n                    if (prevIndex < 0 && $loop) {\n                        handleRovingFocus(items[items.length - 1]);\n                    }\n                    else {\n                        handleRovingFocus(items[prevIndex]);\n                    }\n                }\n                else if (e.key === kbd.HOME) {\n                    e.preventDefault();\n                    handleRovingFocus(items[0]);\n                }\n                else if (e.key === kbd.END) {\n                    e.preventDefault();\n                    handleRovingFocus(items[items.length - 1]);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const isPressed = derived(value, ($value) => {\n        return (itemValue) => {\n            return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;\n        };\n    });\n    return {\n        elements: {\n            root,\n            item,\n        },\n        states: {\n            value,\n        },\n        helpers: {\n            isPressed,\n        },\n        options,\n    };\n};\n", "import { addMeltEventListener, builder, createElHelpers, executeCallbacks, handleRovingFocus, isHTMLElement, kbd, overridable, toWritableStores, } from '../../internal/helpers/index.js';\nimport { derived, get, writable } from 'svelte/store';\nconst defaults = {\n    loop: true,\n    orientation: 'horizontal',\n};\nconst { name, selector } = createElHelpers('toolbar');\nexport const createToolbar = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { loop, orientation } = options;\n    const root = builder(name(), {\n        stores: orientation,\n        returned: ($orientation) => {\n            return {\n                role: 'toolbar',\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    const button = builder(name('button'), {\n        returned: () => ({\n            role: 'button',\n            type: 'button',\n            tabIndex: -1,\n        }),\n        action: (node) => {\n            const unsub = addMeltEventListener(node, 'keydown', handleKeyDown);\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const link = builder(name('link'), {\n        returned: () => ({\n            role: 'link',\n            'data-melt-toolbar-item': '',\n            tabIndex: -1,\n        }),\n        action: (node) => {\n            const unsub = addMeltEventListener(node, 'keydown', handleKeyDown);\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const separator = builder(name('separator'), {\n        stores: orientation,\n        returned: ($orientation) => {\n            return {\n                role: 'separator',\n                'data-orientation': $orientation === 'horizontal' ? 'vertical' : 'horizontal',\n                'aria-orientation': $orientation === 'horizontal' ? 'vertical' : 'horizontal',\n            };\n        },\n    });\n    const groupDefaults = {\n        type: 'single',\n        disabled: false,\n    };\n    const createToolbarGroup = (props) => {\n        const groupWithDefaults = { ...groupDefaults, ...props };\n        const options = toWritableStores(groupWithDefaults);\n        const { type, disabled } = options;\n        const defaultValue = groupWithDefaults.defaultValue\n            ? groupWithDefaults.defaultValue\n            : groupWithDefaults.type === 'single'\n                ? undefined\n                : [];\n        const valueWritable = groupWithDefaults.value ?? writable(defaultValue);\n        const value = overridable(valueWritable, groupWithDefaults?.onValueChange);\n        const { name } = createElHelpers('toolbar-group');\n        const group = builder(name(), {\n            stores: orientation,\n            returned: ($orientation) => {\n                return {\n                    role: 'group',\n                    'data-orientation': $orientation,\n                };\n            },\n        });\n        const item = builder(name('item'), {\n            stores: [disabled, type, value, orientation],\n            returned: ([$disabled, $type, $value, $orientation]) => {\n                return (props) => {\n                    const itemValue = typeof props === 'string' ? props : props.value;\n                    const argDisabled = typeof props === 'string' ? false : !!props.disabled;\n                    const disabled = $disabled || argDisabled;\n                    const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;\n                    return {\n                        disabled,\n                        pressed,\n                        'data-orientation': $orientation,\n                        'data-disabled': disabled ? true : undefined,\n                        'data-value': itemValue,\n                        'data-state': pressed ? 'on' : 'off',\n                        'aria-pressed': pressed,\n                        type: 'button',\n                        role: $type === 'single' ? 'radio' : undefined,\n                        'data-melt-toolbar-item': '',\n                    };\n                };\n            },\n            action: (node) => {\n                function getNodeProps() {\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled === 'true';\n                    return { value: itemValue, disabled };\n                }\n                function handleValueUpdate() {\n                    const { value: itemValue, disabled } = getNodeProps();\n                    if (itemValue === undefined || disabled)\n                        return;\n                    value.update(($value) => {\n                        if (Array.isArray($value)) {\n                            if ($value.includes(itemValue)) {\n                                return $value.filter((i) => i !== itemValue);\n                            }\n                            $value.push(itemValue);\n                            return $value;\n                        }\n                        return $value === itemValue ? undefined : itemValue;\n                    });\n                }\n                const parentToolbar = node.closest('[data-melt-toolbar]');\n                if (!isHTMLElement(parentToolbar))\n                    return {};\n                const items = getToolbarItems(parentToolbar);\n                if (items[0] === node) {\n                    node.tabIndex = 0;\n                }\n                else {\n                    node.tabIndex = -1;\n                }\n                const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                    handleValueUpdate();\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    if (e.key === kbd.ENTER || e.key === kbd.SPACE) {\n                        e.preventDefault();\n                        handleValueUpdate();\n                        return;\n                    }\n                    handleKeyDown(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isPressed = derived(value, ($value) => {\n            return (itemValue) => {\n                return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;\n            };\n        });\n        return {\n            elements: {\n                group,\n                item,\n            },\n            states: {\n                value,\n            },\n            helpers: {\n                isPressed,\n            },\n            options,\n        };\n    };\n    function getToolbarItems(element) {\n        return Array.from(element.querySelectorAll(`${selector('item')}, ${selector('button')}`)).filter((el) => isHTMLElement(el));\n    }\n    function handleKeyDown(e) {\n        const $orientation = get(orientation);\n        const $loop = get(loop);\n        const dir = 'ltr';\n        const nextKey = {\n            horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n            vertical: kbd.ARROW_DOWN,\n        }[$orientation ?? 'horizontal'];\n        const prevKey = {\n            horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n            vertical: kbd.ARROW_UP,\n        }[$orientation ?? 'horizontal'];\n        const el = e.currentTarget;\n        if (!isHTMLElement(el))\n            return;\n        const root = el.closest('[data-melt-toolbar]');\n        if (!isHTMLElement(root))\n            return;\n        const items = Array.from(root.querySelectorAll(`${selector('item')}, ${selector('button')}`)).filter((el) => isHTMLElement(el));\n        const currentIndex = items.indexOf(el);\n        if (e.key === nextKey) {\n            e.preventDefault();\n            const nextIndex = currentIndex + 1;\n            if (nextIndex >= items.length && $loop) {\n                handleRovingFocus(items[0]);\n            }\n            else {\n                handleRovingFocus(items[nextIndex]);\n            }\n        }\n        else if (e.key === prevKey) {\n            e.preventDefault();\n            const prevIndex = currentIndex - 1;\n            if (prevIndex < 0 && $loop) {\n                handleRovingFocus(items[items.length - 1]);\n            }\n            else {\n                handleRovingFocus(items[prevIndex]);\n            }\n        }\n        else if (e.key === kbd.HOME) {\n            e.preventDefault();\n            handleRovingFocus(items[0]);\n        }\n        else if (e.key === kbd.END) {\n            e.preventDefault();\n            handleRovingFocus(items[items.length - 1]);\n        }\n    }\n    return {\n        elements: {\n            root,\n            button,\n            separator,\n            link,\n        },\n        builders: {\n            createToolbarGroup,\n        },\n        options,\n    };\n};\n", "import { addEventListener, addMeltEventListener, builder, createElHelpers, derivedVisible, effect, executeCallbacks, generateId, getPortalDestination, isBrowser, isTouch, kbd, makeHullFromElements, noop, omit, overridable, pointInPolygon, styleToString, toWritableStores, } from '../../internal/helpers/index.js';\nimport { useFloating, usePortal } from '../../internal/actions/index.js';\nimport { onMount, tick } from 'svelte';\nimport { get, writable } from 'svelte/store';\nconst defaults = {\n    positioning: {\n        placement: 'bottom',\n    },\n    arrowSize: 8,\n    defaultOpen: false,\n    closeOnPointerDown: true,\n    openDelay: 1000,\n    closeDelay: 0,\n    forceVisible: false,\n    portal: 'body',\n    closeOnEscape: true,\n};\nconst { name } = createElHelpers('tooltip');\nexport function createTooltip(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'open'));\n    const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape, } = options;\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const activeTrigger = writable(null);\n    const ids = {\n        content: generateId(),\n        trigger: generateId(),\n    };\n    let clickedTrigger = false;\n    onMount(() => {\n        if (!isBrowser)\n            return;\n        activeTrigger.set(document.querySelector(`[aria-describedby=\"${ids.content}\"]`));\n    });\n    let openTimeout = null;\n    let closeTimeout = null;\n    function openTooltip() {\n        if (closeTimeout) {\n            window.clearTimeout(closeTimeout);\n            closeTimeout = null;\n        }\n        if (!openTimeout) {\n            openTimeout = window.setTimeout(() => {\n                open.set(true);\n                openTimeout = null;\n            }, get(openDelay));\n        }\n    }\n    function closeTooltip(isBlur) {\n        if (openTimeout) {\n            window.clearTimeout(openTimeout);\n            openTimeout = null;\n        }\n        if (isBlur && isMouseInTooltipArea)\n            return;\n        if (!closeTimeout) {\n            closeTimeout = window.setTimeout(() => {\n                open.set(false);\n                if (isBlur)\n                    clickedTrigger = false;\n                closeTimeout = null;\n            }, get(closeDelay));\n        }\n    }\n    const trigger = builder(name('trigger'), {\n        returned: () => {\n            return {\n                'aria-describedby': ids.content,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', () => {\n                const $closeOnPointerDown = get(closeOnPointerDown);\n                if (!$closeOnPointerDown)\n                    return;\n                open.set(false);\n                clickedTrigger = true;\n                if (openTimeout) {\n                    window.clearTimeout(openTimeout);\n                    openTimeout = null;\n                }\n            }), addMeltEventListener(node, 'pointerenter', (e) => {\n                if (isTouch(e))\n                    return;\n                openTooltip();\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                if (isTouch(e))\n                    return;\n                if (openTimeout) {\n                    window.clearTimeout(openTimeout);\n                    openTimeout = null;\n                }\n            }), addMeltEventListener(node, 'focus', () => {\n                if (clickedTrigger)\n                    return;\n                openTooltip();\n            }), addMeltEventListener(node, 'blur', () => closeTooltip(true)), addMeltEventListener(node, 'keydown', (e) => {\n                if (get(closeOnEscape) && e.key === kbd.ESCAPE) {\n                    if (openTimeout) {\n                        window.clearTimeout(openTimeout);\n                        openTimeout = null;\n                    }\n                    open.set(false);\n                }\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const isVisible = derivedVisible({ open, activeTrigger, forceVisible });\n    const content = builder(name('content'), {\n        stores: [isVisible, portal],\n        returned: ([$isVisible, $portal]) => {\n            return {\n                role: 'tooltip',\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: ids.content,\n                'data-portal': $portal ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            let unsubFloating = noop;\n            let unsubPortal = noop;\n            const unsubDerived = effect([isVisible, activeTrigger, positioning, portal], ([$isVisible, $activeTrigger, $positioning, $portal]) => {\n                if (!$isVisible || !$activeTrigger) {\n                    unsubPortal();\n                    unsubFloating();\n                    return;\n                }\n                tick().then(() => {\n                    const floatingReturn = useFloating($activeTrigger, node, $positioning);\n                    unsubFloating = floatingReturn.destroy;\n                    if (!$portal) {\n                        unsubPortal();\n                        return;\n                    }\n                    const portalDest = getPortalDestination(node, $portal);\n                    if (portalDest) {\n                        const portalReturn = usePortal(node, portalDest);\n                        if (portalReturn && portalReturn.destroy) {\n                            unsubPortal = portalReturn.destroy;\n                        }\n                    }\n                });\n            });\n            const unsubEvents = executeCallbacks(addMeltEventListener(node, 'pointerenter', openTooltip), addMeltEventListener(node, 'pointerdown', openTooltip));\n            return {\n                destroy() {\n                    unsubEvents();\n                    unsubPortal();\n                    unsubFloating();\n                    unsubDerived();\n                },\n            };\n        },\n    });\n    const arrow = builder(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    let isMouseInTooltipArea = false;\n    effect([isVisible, activeTrigger], ([$isVisible, $activeTrigger]) => {\n        if (!$isVisible || !$activeTrigger)\n            return;\n        return executeCallbacks(addEventListener(document, 'mousemove', (e) => {\n            const contentEl = document.getElementById(ids.content);\n            if (!contentEl)\n                return;\n            const polygon = makeHullFromElements([$activeTrigger, contentEl]);\n            isMouseInTooltipArea = pointInPolygon({\n                x: e.clientX,\n                y: e.clientY,\n            }, polygon);\n            if (isMouseInTooltipArea ||\n                (document.activeElement === $activeTrigger && !clickedTrigger)) {\n                openTooltip();\n            }\n            else {\n                closeTooltip();\n            }\n        }));\n    });\n    return {\n        elements: {\n            trigger,\n            content,\n            arrow,\n        },\n        states: { open },\n        options,\n    };\n}\n"],
  "mappings": "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",
  "names": ["name", "args", "attribute", "selector", "el", "next", "size", "fn", "stores", "defaults", "props", "disabled", "item", "defaults", "image", "defaults", "name", "value", "defaults", "name", "disabled", "platform", "name", "max", "offset", "platform", "placements", "sides", "side", "placement", "overflow", "platform", "x", "y", "min", "max", "platform", "isElement", "isHTMLElement", "getComputedStyle", "getComputedStyle", "isHTMLElement", "isElement", "window", "computePosition", "computePosition", "x", "y", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "_element$getRootNode", "call", "ownerDocument", "isInert", "node", "lookUp", "_node$getAttribute", "inertAtt", "getAttribute", "inert", "result", "parentNode", "isContentEditable", "_node$getAttribute2", "attValue", "getCandidates", "el", "includeContainer", "filter", "candidates", "Array", "slice", "apply", "querySelectorAll", "unshift", "getCandidatesIteratively", "elements", "options", "elementsToCheck", "from", "length", "shift", "tagName", "assigned", "assignedElements", "content", "children", "nestedCandidates", "flatten", "push", "scopeParent", "validCandidate", "includes", "shadowRoot", "getShadowRoot", "validShadowRoot", "shadowRootFilter", "hasTabIndex", "isNaN", "parseInt", "getTabIndex", "Error", "tabIndex", "test", "getSortOrderTabIndex", "isScope", "sortOrderedTabbables", "a", "b", "documentOrder", "isInput", "isHiddenInput", "type", "isDetailsWithSummary", "r", "some", "child", "getCheckedRadio", "nodes", "form", "i", "checked", "isTabbableRadio", "name", "radioScope", "queryRadios", "radioSet", "window", "CSS", "escape", "err", "console", "error", "message", "isRadio", "isNonTabbableRadio", "isNodeAttached", "_nodeRoot", "nodeRoot", "nodeRootHost", "host", "attached", "_nodeRootHost", "_nodeRootHost$ownerDo", "_node$ownerDocument", "contains", "_nodeRoot2", "_nodeRootHost2", "_nodeRootHost2$ownerD", "isZeroArea", "_node$getBoundingClie", "getBoundingClientRect", "width", "height", "isHidden", "_ref", "displayCheck", "getComputedStyle", "visibility", "isDirectSummary", "nodeUnderDetails", "parentElement", "originalNode", "rootNode", "assignedSlot", "getClientRects", "isDisabledFromFieldset", "disabled", "item", "isNodeMatchingSelectorFocusable", "isNodeMatchingSelectorTabbable", "isValidShadowRootTabbable", "shadowHostNode", "sortByOrder", "regularTabbables", "orderedTabbables", "forEach", "candidateTabindex", "sort", "reduce", "acc", "sortable", "concat", "tabbable", "container", "bind", "focusable", "isTabbable", "focusableCandidateSelector", "isFocusable", "activeFocusTraps", "activateTrap", "trapStack", "trap", "length", "activeTrap", "pause", "trapIndex", "indexOf", "push", "splice", "deactivateTrap", "unpause", "isSelectableInput", "node", "tagName", "toLowerCase", "select", "isEscapeEvent", "e", "key", "keyCode", "isTabEvent", "isKeyForward", "shiftKey", "isKeyBackward", "delay", "fn", "setTimeout", "findIndex", "arr", "idx", "every", "value", "i", "valueOrHandler", "_len", "arguments", "params", "Array", "_key", "apply", "getActualTarget", "event", "target", "shadowRoot", "composedPath", "internalTrapStack", "createFocusTrap", "elements", "userOptions", "doc", "document", "config", "_objectSpread", "returnFocusOnDeactivate", "escapeDeactivates", "delayInitialFocus", "state", "containers", "containerGroups", "tabbableGroups", "nodeFocusedBeforeActivation", "mostRecentlyFocusedNode", "active", "paused", "delayInitialFocusTimer", "undefined", "recentNavEvent", "getOption", "configOverrideOptions", "optionName", "configOptionName", "findContainerIndex", "element", "_ref", "container", "tabbableNodes", "contains", "includes", "find", "getNodeForOption", "optionValue", "_len2", "_key2", "Error", "concat", "querySelector", "getInitialFocusNode", "isFocusable", "tabbableOptions", "activeElement", "firstTabbableGroup", "firstTabbableNode", "updateTabbableNodes", "map", "tabbable", "focusableNodes", "focusable", "lastTabbableNode", "firstDomTabbableNode", "isTabbable", "lastDomTabbableNode", "slice", "reverse", "posTabIndexesFound", "getTabIndex", "nextTabbableNode", "forward", "nodeIdx", "el", "filter", "group", "g", "getActiveElement", "tryFocus", "focus", "preventScroll", "getReturnFocusNode", "previousActiveElement", "findNextNavNode", "_ref2", "_ref2$isBackward", "isBackward", "destinationNode", "containerIndex", "containerGroup", "startOfGroupIndex", "_ref3", "destinationGroupIndex", "destinationGroup", "lastOfGroupIndex", "_ref4", "checkPointerDown", "clickOutsideDeactivates", "deactivate", "returnFocus", "allowOutsideClick", "preventDefault", "checkFocusIn", "targetContained", "Document", "stopImmediatePropagation", "nextNode", "navAcrossContainers", "mruContainerIdx", "mruTabIdx", "some", "n", "checkKeyNav", "checkKey", "checkClick", "addListeners", "addEventListener", "capture", "passive", "removeListeners", "removeEventListener", "checkDomRemoval", "mutations", "isFocusedNodeRemoved", "mutation", "removedNodes", "from", "mutationObserver", "window", "MutationObserver", "updateObservedNodes", "disconnect", "observe", "subtree", "childList", "activate", "activateOptions", "onActivate", "onPostActivate", "checkCanFocusTrap", "finishActivation", "then", "deactivateOptions", "options", "onDeactivate", "onPostDeactivate", "checkCanReturnFocus", "clearTimeout", "finishDeactivation", "pauseOptions", "onPause", "onPostPause", "unpauseOptions", "onUnpause", "onPostUnpause", "updateContainerElements", "containerElements", "elementsAsArray", "Boolean", "createFocusTrap", "defaultConfig", "createFocusTrap", "defaults", "name", "selector", "label", "_a", "props", "activeTrigger", "options", "isHidden", "selected", "defaults", "name", "selector", "prev", "positioning", "arrowSize", "subTrigger", "defaults", "name", "selector", "arrow", "name", "defaults", "prev", "createFocusTrap", "defaults", "arrow", "name", "defaults", "arrow", "tabbable", "name", "defaults", "props", "withDefaults", "options", "menu", "prev", "el", "page", "defaults", "name", "selector", "prevButton", "nextButton", "name", "selector", "defaults", "elIndex", "input", "defaults", "name", "prev", "arrow", "defaults", "name", "max", "defaults", "name", "selector", "item", "disabled", "props", "root", "el", "defaults", "name", "isMouse", "handleMenuNavigation", "handleTabNavigation", "prev", "menu", "options", "arrow", "label", "disabled", "props", "isSelected", "defaults", "defaults", "name", "min", "max", "prev", "root", "thumb", "step", "defaults", "name", "prev", "defaults", "name", "selector", "props", "trigger", "el", "defaults", "selector", "name", "elementTarget", "headingsList", "elementsList", "item", "defaults", "name", "selector", "add", "tag", "t", "disabled", "editable", "selected", "editing", "name", "defaults", "props", "closeDelay", "defaults", "defaults", "name", "selector", "props", "disabled", "$value", "root", "items", "item", "defaults", "name", "selector", "props", "options", "disabled", "root", "el", "defaults", "name", "arrow"]
}
