import {
  derived,
  readable,
  readonly,
  writable
} from "./chunk-ABWKT543.js";
import "./chunk-C6APWDKU.js";
import {
  get_store_value,
  onDestroy,
  onMount,
  tick
} from "./chunk-YDWHRBN7.js";
import "./chunk-DMI3OY3J.js";
import "./chunk-2B2CG5KL.js";

// ../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js
function back(array, index, increment, loop = true) {
  const previousIndex = index - increment;
  if (previousIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[previousIndex];
}
function forward(array, index, increment, loop = true) {
  const nextIndex = index + increment;
  if (nextIndex > array.length - 1) {
    return loop ? array[0] : array[array.length - 1];
  }
  return array[nextIndex];
}
function next(array, index, loop = true) {
  if (index === array.length - 1) {
    return loop ? array[0] : array[index];
  }
  return array[index + 1];
}
function prev(array, currentIndex, loop = true) {
  if (currentIndex <= 0) {
    return loop ? array[array.length - 1] : array[0];
  }
  return array[currentIndex - 1];
}
function last(array) {
  return array[array.length - 1];
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function toggle(item, array) {
  const itemIdx = array.findIndex((i) => dequal(i, item));
  if (itemIdx !== -1) {
    array.splice(itemIdx, 1);
  } else {
    array.push(item);
  }
  return array;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js
function lightable(value) {
  function subscribe(run) {
    run(value);
    return () => {
    };
  }
  return { subscribe };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/builder.js
function getElementByMeltId(id) {
  if (!isBrowser)
    return null;
  const el = document.querySelector(`[data-melt-id="${id}"]`);
  return isHTMLElement(el) ? el : null;
}
var hiddenAction = (obj) => {
  return new Proxy(obj, {
    get(target, prop, receiver) {
      return Reflect.get(target, prop, receiver);
    },
    ownKeys(target) {
      return Reflect.ownKeys(target).filter((key) => key !== "action");
    }
  });
};
var isFunctionWithParams = (fn) => {
  return typeof fn === "function";
};
function builder(name22, args) {
  const { stores, action, returned } = args ?? {};
  const derivedStore = (() => {
    if (stores && returned) {
      return derived(stores, (values) => {
        const result = returned(values);
        if (isFunctionWithParams(result)) {
          const fn = (...args2) => {
            return hiddenAction({
              ...result(...args2),
              [`data-melt-${name22}`]: "",
              action: action ?? noop
            });
          };
          fn.action = action ?? noop;
          return fn;
        }
        return hiddenAction({
          ...result,
          [`data-melt-${name22}`]: "",
          action: action ?? noop
        });
      });
    } else {
      const returnedFn = returned;
      const result = returnedFn == null ? void 0 : returnedFn();
      if (isFunctionWithParams(result)) {
        const resultFn = (...args2) => {
          return hiddenAction({
            ...result(...args2),
            [`data-melt-${name22}`]: "",
            action: action ?? noop
          });
        };
        resultFn.action = action ?? noop;
        return lightable(resultFn);
      }
      return lightable(hiddenAction({
        ...result,
        [`data-melt-${name22}`]: "",
        action: action ?? noop
      }));
    }
  })();
  const actionFn = action ?? (() => {
  });
  actionFn.subscribe = derivedStore.subscribe;
  return actionFn;
}
function createElHelpers(prefix) {
  const name22 = (part) => part ? `${prefix}-${part}` : prefix;
  const attribute2 = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
  const selector11 = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
  const getEl = (part) => document.querySelector(selector11(part));
  return {
    name: name22,
    attribute: attribute2,
    selector: selector11,
    getEl
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js
var isBrowser = typeof document !== "undefined";
var isFunction = (v) => typeof v === "function";
function isElement(element) {
  return element instanceof Element;
}
function isHTMLElement(element) {
  return element instanceof HTMLElement;
}
function isHTMLInputElement(element) {
  return element instanceof HTMLInputElement;
}
function isHTMLLabelElement(element) {
  return element instanceof HTMLLabelElement;
}
function isElementDisabled(element) {
  const ariaDisabled = element.getAttribute("aria-disabled");
  const disabled = element.getAttribute("disabled");
  const dataDisabled = element.hasAttribute("data-disabled");
  if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
    return true;
  }
  return false;
}
function isTouch(event) {
  return event.pointerType === "touch";
}
function isLeftClick(event) {
  return event.button === 0 && event.ctrlKey === false && event.metaKey === false;
}
function isFocusVisible(element) {
  return element.matches(":focus-visible");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/dom.js
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) {
    nodes.push(walker.currentNode);
  }
  return nodes;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}
function noop() {
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}
function addMeltEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  if (typeof handler === "function") {
    const handlerWithMelt = withMelt((_event) => handler(_event));
    events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));
    };
  }
  return () => noop();
}
function dispatchMeltEvent(originalEvent) {
  const node = originalEvent.currentTarget;
  if (!isHTMLElement(node))
    return null;
  const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
    detail: {
      originalEvent
    },
    cancelable: true
  });
  node.dispatchEvent(customMeltEvent);
  return customMeltEvent;
}
function withMelt(handler) {
  return (event) => {
    const customEvent = dispatchMeltEvent(event);
    if (customEvent == null ? void 0 : customEvent.defaultPrevented)
      return;
    return handler(event);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js
function addHighlight(element) {
  element.setAttribute("data-highlighted", "");
}
function removeHighlight(element) {
  element.removeAttribute("data-highlighted");
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/list.js
function getOptions(el) {
  return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement(el2));
}
function getFirstOption(el) {
  const firstOption = el.querySelector('[role="option"]:not([data-disabled])');
  return isHTMLElement(firstOption) ? firstOption : null;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js
function omit(obj, ...keys) {
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js
var overridable = (store, onChange) => {
  const update = (updater, sideEffect) => {
    store.update((curr) => {
      const next2 = updater(curr);
      let res = next2;
      if (onChange) {
        res = onChange({ curr, next: next2 });
      }
      sideEffect == null ? void 0 : sideEffect(res);
      return res;
    });
  };
  const set = (curr) => {
    update(() => curr);
  };
  return {
    ...store,
    update,
    set
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js
function styleToString(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}

// ../../node_modules/.pnpm/nanoid@4.0.2/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size2 = 21) => {
  let id = "";
  let i = size2;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js
function generateId() {
  return nanoid(10);
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js
var kbd = {
  ALT: "Alt",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  CAPS_LOCK: "CapsLock",
  CONTROL: "Control",
  DELETE: "Delete",
  END: "End",
  ENTER: "Enter",
  ESCAPE: "Escape",
  F1: "F1",
  F10: "F10",
  F11: "F11",
  F12: "F12",
  F2: "F2",
  F3: "F3",
  F4: "F4",
  F5: "F5",
  F6: "F6",
  F7: "F7",
  F8: "F8",
  F9: "F9",
  HOME: "Home",
  META: "Meta",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  SHIFT: "Shift",
  SPACE: " ",
  TAB: "Tab",
  CTRL: "Control"
};
var FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
var LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
var getNextKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
    vertical: kbd.ARROW_DOWN
  }[orientation];
};
var getPrevKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
    vertical: kbd.ARROW_UP
  }[orientation];
};
var getDirectionalKeys = (dir = "ltr", orientation = "horizontal") => {
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js
function debounce(fn, wait = 500) {
  let timeout = null;
  return function(...args) {
    const later = () => {
      timeout = null;
      fn(...args);
    };
    timeout && clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^Mac/) && !isTouchDevice();
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => isApple() && !isMac();

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/hull.js
function makeHull(points) {
  const newPoints = points.slice();
  newPoints.sort(POINT_COMPARATOR);
  return makeHullPresorted(newPoints);
}
function makeHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function POINT_COMPARATOR(a, b) {
  if (a.x < b.x)
    return -1;
  else if (a.x > b.x)
    return 1;
  else if (a.y < b.y)
    return -1;
  else if (a.y > b.y)
    return 1;
  else
    return 0;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/polygon/index.js
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    { x: rect.right, y: rect.top },
    { x: rect.right, y: rect.bottom },
    { x: rect.left, y: rect.bottom }
  ];
}
function makeHullFromElements(els) {
  const points = els.flatMap((el) => getPointsFromEl(el));
  return makeHull(points);
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js
var LOCK_CLASSNAME = "data-melt-scroll-lock";
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return noop;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];
  const setStyle = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo(scrollX, scrollY);
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js
function derivedVisible(obj) {
  const { open, forceVisible, activeTrigger } = obj;
  return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedWithUnsubscribe.js
function derivedWithUnsubscribe(stores, fn) {
  let unsubscribers = [];
  const onUnsubscribe = (cb) => {
    unsubscribers.push(cb);
  };
  const unsubscribe = () => {
    unsubscribers.forEach((fn2) => fn2());
    unsubscribers = [];
  };
  const derivedStore = derived(stores, ($storeValues) => {
    unsubscribe();
    return fn($storeValues, onUnsubscribe);
  });
  onDestroy(unsubscribe);
  const subscribe = (...args) => {
    const unsub = derivedStore.subscribe(...args);
    return () => {
      unsub();
      unsubscribe();
    };
  };
  return {
    ...derivedStore,
    subscribe
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js
function effect(stores, fn) {
  const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
    return {
      stores: stores2,
      onUnsubscribe
    };
  }).subscribe(({ stores: stores2, onUnsubscribe }) => {
    const returned = fn(stores2);
    if (returned) {
      onUnsubscribe(returned);
    }
  });
  onDestroy(unsub);
  return unsub;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/debounceable.js
function debounceable(initialValue, wait = 0) {
  const store = writable({ value: initialValue, debounced: initialValue });
  let timeout;
  function debouncedSet(value) {
    store.update((state) => {
      state.value = value;
      return state;
    });
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      store.update((state) => {
        state.debounced = state.value;
        return state;
      });
    }, wait);
  }
  function debouncedUpdate(fn) {
    store.update((state) => {
      state.value = fn(state.value);
      return state;
    });
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      store.update((state) => {
        state.debounced = state.value;
        return state;
      });
    }, wait);
  }
  function set(value) {
    store.update((state) => {
      state.value = value;
      state.debounced = value;
      return state;
    });
  }
  function update(fn) {
    store.update((state) => {
      state.value = fn(state.value);
      state.debounced = state.value;
      return state;
    });
  }
  return {
    ...store,
    debouncedSet,
    debouncedUpdate,
    set,
    update
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js
function handleRovingFocus(nextElement) {
  if (!isBrowser)
    return;
  const currentFocusedElement = document.activeElement;
  if (!isHTMLElement(currentFocusedElement))
    return;
  if (currentFocusedElement === nextElement)
    return;
  currentFocusedElement.tabIndex = -1;
  nextElement.tabIndex = 0;
  sleep(1).then(() => nextElement.focus());
}
function getFocusableElements() {
  return Array.from(document.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), textarea:not([disabled]):not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])'));
}
function getNextFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const nextIndex = currentIndex + 1;
  const nextElement = focusableElements[nextIndex];
  if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {
    return nextElement;
  }
  return null;
}
function getPreviousFocusable(currentElement) {
  const focusableElements = getFocusableElements();
  const currentIndex = focusableElements.indexOf(currentElement);
  const previousIndex = currentIndex - 1;
  const prevElement = focusableElements[previousIndex];
  if (previousIndex >= 0 && isHTMLElement(prevElement)) {
    return prevElement;
  }
  return null;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js
var defaults = {
  onMatch: handleRovingFocus
};
function createTypeaheadSearch(args = {}) {
  const withDefaults = { ...defaults, ...args };
  const typed = writable([]);
  const resetTyped = debounce(() => {
    typed.update(() => []);
  });
  const handleTypeaheadSearch = (key, items) => {
    const currentItem = document.activeElement;
    if (!isHTMLElement(currentItem))
      return;
    const $typed = get_store_value(typed);
    if (!Array.isArray($typed)) {
      return;
    }
    $typed.push(key.toLowerCase());
    typed.update(() => $typed);
    const candidateItems = items.filter((item) => {
      if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
        return false;
      }
      return true;
    });
    const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
    const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
    const currentItemIndex = currentItem ? candidateItems.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizeSearch.length === 1;
    if (excludeCurrentItem) {
      wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    }
    const nextItem = wrappedItems.find((item) => item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
    if (isHTMLElement(nextItem) && nextItem !== currentItem) {
      withDefaults.onMatch(nextItem);
    }
    resetTyped();
  };
  return {
    typed,
    resetTyped,
    handleTypeaheadSearch
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js
function getPortalParent(node) {
  let parent = node.parentElement;
  while (isHTMLElement(parent) && !parent.hasAttribute("data-portal")) {
    parent = parent.parentElement;
  }
  return parent || "body";
}
function getPortalDestination(node, portalProp) {
  const portalParent = getPortalParent(node);
  if (portalProp !== void 0)
    return portalProp;
  if (portalParent === "body")
    return document.body;
  return null;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/helpers/ignore.js
function createClickOutsideIgnore(meltId) {
  return (e) => {
    const target = e.target;
    const triggerEl = getElementByMeltId(meltId);
    if (!triggerEl || !isElement(target))
      return false;
    const id = triggerEl.id;
    if (isHTMLLabelElement(target) && id === target.htmlFor) {
      return true;
    }
    if (target.closest(`label[for="${id}"]`)) {
      return true;
    }
    return false;
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/accordion/create.js
var { name, selector } = createElHelpers("accordion");
var defaults2 = {
  multiple: false,
  disabled: false,
  forceVisible: false
};
var createAccordion = (props) => {
  const withDefaults = { ...defaults2, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "onValueChange", "defaultValue"));
  const { disabled, forceVisible } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isSelected = (key, v) => {
    if (v === void 0)
      return false;
    if (typeof v === "string")
      return v === key;
    return v.includes(key);
  };
  const isSelectedStore = derived(value, ($value) => {
    return (key) => isSelected(key, $value);
  });
  const ids = {
    root: generateId()
  };
  const root = builder(name(), {
    returned: () => ({
      "data-melt-id": ids.root
    })
  });
  const parseItemProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const parseHeadingProps = (props2) => {
    if (typeof props2 === "number") {
      return { level: props2 };
    } else {
      return props2;
    }
  };
  const item = builder(name("item"), {
    stores: value,
    returned: ($value) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          "data-state": isSelected(itemValue, $value) ? "open" : "closed",
          "data-disabled": disabled2 ? true : void 0
        };
      };
    }
  });
  const trigger = builder(name("trigger"), {
    stores: [value, disabled],
    returned: ([$value, $disabled]) => {
      return (props2) => {
        const { value: itemValue, disabled: disabled2 } = parseItemProps(props2);
        return {
          disabled: $disabled || disabled2,
          "aria-expanded": isSelected(itemValue, $value) ? true : false,
          "aria-disabled": disabled2 ? true : false,
          "data-disabled": disabled2 ? true : void 0,
          "data-value": itemValue,
          "data-state": isSelected(itemValue, $value) ? "open" : "closed"
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled === "true";
        const itemValue = node.dataset.value;
        if (disabled2 || !itemValue)
          return;
        handleValueUpdate(itemValue);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (![kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.HOME, kbd.END].includes(e.key)) {
          return;
        }
        e.preventDefault();
        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
          const disabled2 = node.dataset.disabled === "true";
          const itemValue = node.dataset.value;
          if (disabled2 || !itemValue)
            return;
          handleValueUpdate(itemValue);
          return;
        }
        const el = e.target;
        const rootEl = getElementByMeltId(ids.root);
        if (!rootEl || !isHTMLElement(el))
          return;
        const items = Array.from(rootEl.querySelectorAll(selector("trigger")));
        const candidateItems = items.filter((item2) => {
          if (!isHTMLElement(item2))
            return false;
          return item2.dataset.disabled !== "true";
        });
        if (!candidateItems.length)
          return;
        const elIdx = candidateItems.indexOf(el);
        if (e.key === kbd.ARROW_DOWN) {
          candidateItems[(elIdx + 1) % candidateItems.length].focus();
        }
        if (e.key === kbd.ARROW_UP) {
          candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length].focus();
        }
        if (e.key === kbd.HOME) {
          candidateItems[0].focus();
        }
        if (e.key === kbd.END) {
          candidateItems[candidateItems.length - 1].focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = builder(name("content"), {
    stores: [value, disabled, forceVisible],
    returned: ([$value, $disabled, $forceVisible]) => {
      return (props2) => {
        const { value: itemValue } = parseItemProps(props2);
        const isVisible = isSelected(itemValue, $value) || $forceVisible;
        return {
          "data-state": isVisible ? "open" : "closed",
          "data-disabled": $disabled ? true : void 0,
          "data-value": itemValue,
          hidden: isVisible ? void 0 : true,
          style: styleToString({
            display: isVisible ? void 0 : "none"
          })
        };
      };
    },
    action: (node) => {
      tick().then(() => {
        const contentId = generateId();
        const triggerId = generateId();
        const parentTrigger = document.querySelector(`${selector("trigger")}, [data-value="${node.dataset.value}"]`);
        if (!isHTMLElement(parentTrigger))
          return;
        node.id = contentId;
        parentTrigger.setAttribute("aria-controls", contentId);
        parentTrigger.id = triggerId;
      });
    }
  });
  const heading = builder(name("heading"), {
    returned: () => {
      return (props2) => {
        const { level } = parseHeadingProps(props2);
        return {
          role: "heading",
          "aria-level": level,
          "data-heading-level": level
        };
      };
    }
  });
  function handleValueUpdate(itemValue) {
    value.update(($value) => {
      if ($value === void 0) {
        return withDefaults.multiple ? [itemValue] : itemValue;
      }
      if (Array.isArray($value)) {
        if ($value.includes(itemValue)) {
          return $value.filter((v) => v !== itemValue);
        }
        $value.push(itemValue);
        return $value;
      }
      return $value === itemValue ? void 0 : itemValue;
    });
  }
  return {
    elements: {
      root,
      item,
      trigger,
      content,
      heading
    },
    states: {
      value
    },
    helpers: {
      isSelected: isSelectedStore
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/avatar/create.js
var defaults3 = {
  src: "",
  delayMs: 0,
  onLoadingStatusChange: void 0
};
var createAvatar = (props) => {
  const withDefaults = { ...defaults3, ...props };
  const options = toWritableStores(omit(withDefaults, "loadingStatus", "onLoadingStatusChange"));
  const { src, delayMs } = options;
  const loadingStatusWritable = withDefaults.loadingStatus ?? writable("loading");
  const loadingStatus = overridable(loadingStatusWritable, withDefaults == null ? void 0 : withDefaults.onLoadingStatusChange);
  effect([src, delayMs], ([$src, $delayMs]) => {
    if (isBrowser) {
      const image2 = new Image();
      image2.src = $src;
      image2.onload = () => {
        if (delayMs !== void 0) {
          const timerId = window.setTimeout(() => {
            loadingStatus.set("loaded");
          }, $delayMs);
          return () => window.clearTimeout(timerId);
        } else {
          loadingStatus.set("loaded");
        }
      };
      image2.onerror = () => {
        loadingStatus.set("error");
      };
    }
  });
  const image = builder("avatar-image", {
    stores: [src, loadingStatus],
    returned: ([$src, $loadingStatus]) => {
      const imageStyles = styleToString({
        display: $loadingStatus === "loaded" ? "block" : "none"
      });
      return {
        src: $src,
        style: imageStyles
      };
    }
  });
  const fallback = builder("avatar-fallback", {
    stores: [loadingStatus],
    returned: ([$loadingStatus]) => {
      return {
        style: $loadingStatus === "loaded" ? styleToString({
          display: "none"
        }) : void 0,
        hidden: $loadingStatus === "loaded" ? true : void 0
      };
    }
  });
  return {
    elements: {
      image,
      fallback
    },
    states: {
      loadingStatus
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/checkbox/create.js
var defaults4 = {
  disabled: false,
  required: false,
  name: void 0,
  value: "on",
  defaultChecked: false
};
function createCheckbox(props) {
  const withDefaults = { ...defaults4, ...props };
  const options = toWritableStores(omit(withDefaults, "checked", "defaultChecked"));
  const { disabled, name: name22, required, value } = options;
  const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked);
  const checked = overridable(checkedWritable, withDefaults == null ? void 0 : withDefaults.onCheckedChange);
  const root = builder("checkbox", {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": $disabled,
        "data-state": $checked === "indeterminate" ? "indeterminate" : $checked ? "checked" : "unchecked",
        type: "button",
        role: "checkbox",
        "aria-checked": $checked === "indeterminate" ? "mixed" : $checked,
        "aria-required": $required
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd.ENTER)
          e.preventDefault();
      }), addMeltEventListener(node, "click", () => {
        if (get_store_value(disabled))
          return;
        checked.update((value2) => {
          if (value2 === "indeterminate")
            return true;
          return !value2;
        });
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder("checkbox-input", {
    stores: [checked, name22, value, required, disabled],
    returned: ([$checked, $name, $value, $required, $disabled]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked === "indeterminate" ? false : $checked,
        required: $required,
        disabled: $disabled,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  const isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
  const isChecked = derived(checked, ($checked) => $checked === true);
  return {
    elements: {
      root,
      input
    },
    states: {
      checked
    },
    helpers: {
      isIndeterminate,
      isChecked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/collapsible/create.js
var defaults5 = {
  defaultOpen: false,
  disabled: false,
  forceVisible: false
};
var { name: name2 } = createElHelpers("collapsible");
function createCollapsible(props) {
  const withDefaults = { ...defaults5, ...props };
  const options = toWritableStores(omit(withDefaults, "open", "defaultOpen", "onOpenChange"));
  const { disabled, forceVisible } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const root = builder(name2(), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": $disabled ? "" : "undefined"
    })
  });
  const trigger = builder(name2("trigger"), {
    stores: [open, disabled],
    returned: ([$open, $disabled]) => ({
      "data-state": $open ? "open" : "closed",
      "data-disabled": $disabled ? "" : void 0,
      disabled: $disabled
    }),
    action: (node) => {
      const unsub = addMeltEventListener(node, "click", () => {
        const disabled2 = node.dataset.disabled !== void 0;
        if (disabled2)
          return;
        open.update(($open) => !$open);
      });
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => $open || $forceVisible);
  const content = builder(name2("content"), {
    stores: [isVisible, disabled],
    returned: ([$isVisible, $disabled]) => ({
      "data-state": $isVisible ? "open" : "closed",
      "data-disabled": $disabled ? "" : void 0,
      hidden: $isVisible ? void 0 : true,
      style: styleToString({
        display: $isVisible ? void 0 : "none"
      })
    })
  });
  return {
    elements: {
      root,
      trigger,
      content
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js
var documentClickStore = readable(void 0, (set) => {
  function clicked(event) {
    set(event);
    set(void 0);
  }
  const unsubscribe = addEventListener(document, "pointerdown", clicked, {
    passive: false,
    capture: true
  });
  return unsubscribe;
});
var useClickOutside = (node, config = {}) => {
  let options = { enabled: true, ...config };
  function isEnabled() {
    return typeof options.enabled === "boolean" ? options.enabled : get_store_value(options.enabled);
  }
  const unsubscribe = documentClickStore.subscribe((e) => {
    var _a;
    if (!isEnabled() || !e || e.target === node) {
      return;
    }
    const composedPath = e.composedPath();
    if (composedPath.includes(node))
      return;
    if (options.ignore) {
      if (isFunction(options.ignore)) {
        if (options.ignore(e))
          return;
      } else if (Array.isArray(options.ignore)) {
        if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
          return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));
        }))
          return;
      }
    }
    (_a = options.handler) == null ? void 0 : _a.call(options, e);
  });
  return {
    update(params) {
      options = { ...options, ...params };
    },
    destroy() {
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js
var documentEscapeKeyStore = readable(void 0, (set) => {
  function keydown(event) {
    if (event && event.key === kbd.ESCAPE) {
      set(event);
    }
    set(void 0);
  }
  const unsubscribe = addEventListener(document, "keydown", keydown, {
    passive: false,
    capture: true
  });
  return unsubscribe;
});
var useEscapeKeydown = (node, config = {}) => {
  node.dataset.escapee = "";
  let options = { enabled: true, ...config };
  function isEnabled() {
    return typeof options.enabled === "boolean" ? options.enabled : get_store_value(options.enabled);
  }
  const unsubscribe = documentEscapeKeyStore.subscribe((e) => {
    var _a;
    if (!e || !isEnabled())
      return;
    const target = e.target;
    if (!isHTMLElement(target) || target.closest("[data-escapee]") !== node) {
      return;
    }
    if (options.ignore) {
      if (isFunction(options.ignore)) {
        if (options.ignore(e))
          return;
      } else if (Array.isArray(options.ignore)) {
        if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
          return ignoreEl && target === ignoreEl;
        }))
          return;
      }
    }
    (_a = options.handler) == null ? void 0 : _a.call(options, e);
  });
  return {
    update(params) {
      options = { ...options, ...params };
    },
    destroy() {
      node.removeAttribute("data-escapee");
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// ../../node_modules/.pnpm/@floating-ui+core@1.5.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name22,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name22]: {
        ...middlewareData[name22],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// ../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement2(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js
var defaultConfig = {
  strategy: "absolute",
  placement: "top",
  gutter: 5,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
var ARROW_TRANSFORM = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function useFloating(reference, floating, opts = {}) {
  if (!floating || !reference)
    return {
      destroy: noop
    };
  const options = { ...defaultConfig, ...opts };
  const arrowEl = floating.querySelector("[data-arrow=true]");
  const middleware = [];
  if (options.flip) {
    middleware.push(flip({
      boundary: options.boundary,
      padding: options.overflowPadding
    }));
  }
  const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
  if (options.gutter || options.offset) {
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null) {
      data.mainAxis += arrowOffset;
    }
    middleware.push(offset(data));
  }
  middleware.push(shift({
    boundary: options.boundary,
    crossAxis: options.overlap,
    padding: options.overflowPadding
  }));
  if (arrowEl) {
    middleware.push(arrow({ element: arrowEl, padding: 8 }));
  }
  middleware.push(size({
    padding: options.overflowPadding,
    apply({ rects, availableHeight, availableWidth }) {
      if (options.sameWidth) {
        Object.assign(floating.style, {
          width: `${Math.round(rects.reference.width)}px`,
          minWidth: "unset"
        });
      }
      if (options.fitViewport) {
        Object.assign(floating.style, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        });
      }
    }
  }));
  function compute() {
    if (!reference || !floating)
      return;
    const { placement, strategy } = options;
    computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    }).then((data) => {
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: options.strategy,
        top: `${y}px`,
        left: `${x}px`
      });
      if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {
        const { x: x2, y: y2 } = data.middlewareData.arrow;
        const dir = data.placement.split("-")[0];
        Object.assign(arrowEl.style, {
          position: "absolute",
          left: x2 != null ? `${x2}px` : "",
          top: y2 != null ? `${y2}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
      }
      return data;
    });
  }
  Object.assign(floating.style, {
    position: options.strategy
  });
  return {
    destroy: autoUpdate(reference, floating, compute)
  };
}

// ../../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name22) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name22 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// ../../node_modules/.pnpm/focus-trap@7.5.4/node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward2) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward2 ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var getActiveElement = function getActiveElement2(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return getActiveElement2(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref2) {
    var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n) {
              return getTabIndex(n) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        tryFocus(nextNode);
      } else {
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js
function createFocusTrap3(config = {}) {
  let trap;
  const { immediate, ...focusTrapOptions } = config;
  const hasFocus = writable(false);
  const isPaused = writable(false);
  const activate = (opts) => trap == null ? void 0 : trap.activate(opts);
  const deactivate = (opts) => {
    trap == null ? void 0 : trap.deactivate(opts);
  };
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.set(true);
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.set(false);
    }
  };
  const useFocusTrap = (node) => {
    trap = createFocusTrap(node, {
      ...focusTrapOptions,
      onActivate() {
        var _a;
        hasFocus.set(true);
        (_a = config.onActivate) == null ? void 0 : _a.call(config);
      },
      onDeactivate() {
        var _a;
        hasFocus.set(false);
        (_a = config.onDeactivate) == null ? void 0 : _a.call(config);
      }
    });
    if (immediate) {
      activate();
    }
    return {
      destroy() {
        deactivate();
        trap = void 0;
      }
    };
  };
  return {
    useFocusTrap,
    hasFocus: readonly(hasFocus),
    isPaused: readonly(isPaused),
    activate,
    deactivate,
    pause,
    unpause
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/melt/index.js
function melt(node, params) {
  return params.action(node);
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js
var defaultConfig2 = {
  floating: {},
  focusTrap: {},
  clickOutside: {},
  escapeKeydown: {},
  portal: "body"
};
var usePopper = (popperElement, args) => {
  popperElement.dataset.escapee = "";
  const { anchorElement, open, options } = args;
  if (!anchorElement || !open || !options) {
    return { destroy: noop };
  }
  const opts = { ...defaultConfig2, ...options };
  const callbacks = [];
  if (opts.portal !== null) {
    const portal = usePortal(popperElement, opts.portal);
    if (portal == null ? void 0 : portal.destroy) {
      callbacks.push(portal.destroy);
    }
  }
  callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
  if (opts.focusTrap !== null) {
    const { useFocusTrap } = createFocusTrap3({
      immediate: true,
      escapeDeactivates: false,
      allowOutsideClick: true,
      returnFocusOnDeactivate: false,
      fallbackFocus: popperElement,
      ...opts.focusTrap
    });
    const usedFocusTrap = useFocusTrap(popperElement);
    if (usedFocusTrap == null ? void 0 : usedFocusTrap.destroy) {
      callbacks.push(usedFocusTrap.destroy);
    }
  }
  if (opts.clickOutside !== null) {
    callbacks.push(useClickOutside(popperElement, {
      enabled: open,
      handler: (e) => {
        if (e.defaultPrevented)
          return;
        if (isHTMLElement(anchorElement) && !anchorElement.contains(e.target)) {
          open.set(false);
          anchorElement.focus();
        }
      },
      ...opts.clickOutside
    }).destroy);
  }
  if (opts.escapeKeydown !== null) {
    callbacks.push(useEscapeKeydown(popperElement, {
      enabled: open,
      handler: (e) => {
        if (e.defaultPrevented)
          return;
        open.set(false);
      },
      ...opts.escapeKeydown
    }).destroy);
  }
  const unsubscribe = executeCallbacks(...callbacks);
  return {
    destroy() {
      unsubscribe();
    }
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js
var usePortal = (el, target = "body") => {
  let targetEl;
  if (!isHTMLElement(target) && typeof target !== "string") {
    return {
      destroy: noop
    };
  }
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    el.dataset.portal = "";
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    el.remove();
  }
  update(target);
  return {
    update,
    destroy
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/label/create.js
function createLabel() {
  const root = builder("label", {
    action: (node) => {
      const mouseDown = addMeltEventListener(node, "mousedown", (e) => {
        if (!e.defaultPrevented && e.detail > 1) {
          e.preventDefault();
        }
      });
      return {
        destroy: mouseDown
      };
    }
  });
  return {
    elements: {
      root
    }
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/combobox/create.js
var INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
var defaults6 = {
  positioning: {
    placement: "bottom",
    sameWidth: true
  },
  scrollAlignment: "nearest",
  loop: true,
  defaultOpen: false,
  closeOnOutsideClick: true,
  preventScroll: true,
  closeOnEscape: true,
  forceVisible: false,
  portal: void 0,
  filterFunction: () => true,
  debounce: 0
};
var { name: name3, selector: selector2 } = createElHelpers("combobox");
function createCombobox(props) {
  var _a;
  const withDefaults = { ...defaults6, ...props };
  const activeTrigger = writable(null);
  const highlightedItem = writable(null);
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults == null ? void 0 : withDefaults.onSelectedChange);
  const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
  const inputValue = debounceable(((_a = withDefaults.defaultSelected) == null ? void 0 : _a.label) ?? "", withDefaults.debounce);
  const openWritable = withDefaults.open ?? writable(false);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const isEmpty = writable(false);
  const options = toWritableStores(omit(withDefaults, "open", "defaultOpen", "debounce"));
  const { scrollAlignment, loop, filterFunction, closeOnOutsideClick, closeOnEscape, preventScroll, portal, forceVisible, positioning } = options;
  const touchedInput = debounceable(false, withDefaults.debounce);
  const ids = {
    input: generateId(),
    menu: generateId(),
    label: generateId()
  };
  function getOptionProps(el) {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled ? true : false
    };
  }
  function reset() {
    var _a2;
    const $selectedItem = get_store_value(selected);
    if (!$selectedItem) {
      inputValue.set("");
    } else {
      inputValue.set(((_a2 = get_store_value(selected)) == null ? void 0 : _a2.label) ?? "");
    }
    touchedInput.set(false);
  }
  function selectItem(item) {
    const props2 = getOptionProps(item);
    selected.set(props2);
    const activeTrigger2 = getElementByMeltId(ids.input);
    if (activeTrigger2) {
      activeTrigger2.focus();
    }
  }
  async function handleIsEmpty() {
    if (!isBrowser)
      return;
    await tick();
    const menuElement = document.getElementById(ids.menu);
    if (!isHTMLElement(menuElement))
      return;
    const options2 = getOptions(menuElement);
    const visibleOptions = options2.filter((opt) => {
      const isHidden3 = opt.dataset.hidden !== void 0;
      return !isHidden3;
    });
    if (!visibleOptions.length) {
      isEmpty.set(true);
    } else {
      isEmpty.set(false);
    }
  }
  async function openMenu(currentOpenState = false) {
    if (!currentOpenState) {
      open.set(true);
    }
    const triggerEl = getElementByMeltId(ids.input);
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
    await tick();
    const menuElement = document.getElementById(ids.menu);
    if (!isHTMLElement(menuElement))
      return;
    const selectedItem = menuElement.querySelector("[aria-selected=true]");
    if (!isHTMLElement(selectedItem))
      return;
    highlightedItem.set(selectedItem);
  }
  function closeMenu() {
    open.set(false);
    touchedInput.set(false);
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const isSelected = derived([selected], ([$value]) => {
    return (item) => dequal($value == null ? void 0 : $value.value, item);
  });
  const isHighlighted = derived([highlighted], ([$value]) => {
    return (item) => {
      return dequal($value == null ? void 0 : $value.value, item);
    };
  });
  const input = builder(name3("input"), {
    stores: [open, highlightedItem, inputValue],
    returned: ([$open, $highlightedItem, $inputValue]) => {
      return {
        "aria-activedescendant": $highlightedItem == null ? void 0 : $highlightedItem.id,
        "aria-autocomplete": "list",
        "aria-controls": ids.menu,
        "aria-expanded": $open,
        "aria-labelledby": ids.label,
        "data-melt-id": ids.input,
        autocomplete: "off",
        id: ids.input,
        role: "combobox",
        value: $inputValue.value
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(
        addMeltEventListener(node, "click", () => {
          const $open = get_store_value(open);
          if ($open) {
            return;
          }
          openMenu($open);
        }),
        // Handle all input key events including typing, meta, and navigation.
        addMeltEventListener(node, "keydown", (e) => {
          const $open = get_store_value(open);
          if (!$open) {
            if (INTERACTION_KEYS.includes(e.key)) {
              return;
            }
            if (e.key === kbd.TAB) {
              return;
            }
            if (e.key === kbd.BACKSPACE && node.value === "") {
              return;
            }
            openMenu($open);
            tick().then(() => {
              const $selectedItem = get_store_value(selected);
              if ($selectedItem)
                return;
              const menuEl = document.getElementById(ids.menu);
              if (!isHTMLElement(menuEl))
                return;
              const enabledItems = Array.from(menuEl.querySelectorAll(`${selector2("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement(item));
              if (!enabledItems.length)
                return;
              if (e.key === kbd.ARROW_DOWN) {
                highlightedItem.set(enabledItems[0]);
              } else if (e.key === kbd.ARROW_UP) {
                highlightedItem.set(last(enabledItems));
              }
            });
          }
          if (e.key === kbd.TAB || e.key === kbd.ESCAPE) {
            closeMenu();
            reset();
            return;
          }
          if (e.key === kbd.ENTER) {
            const $highlightedItem = get_store_value(highlightedItem);
            if ($highlightedItem) {
              selectItem($highlightedItem);
            }
            closeMenu();
          }
          if (e.key === kbd.ARROW_UP && e.altKey) {
            closeMenu();
            reset();
          }
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.preventDefault();
            const menuElement = document.getElementById(ids.menu);
            if (!isHTMLElement(menuElement))
              return;
            const itemElements = getOptions(menuElement);
            if (!itemElements.length)
              return;
            const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
            const $currentItem = get_store_value(highlightedItem);
            const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
            const $loop = get_store_value(loop);
            const $scrollAlignment = get_store_value(scrollAlignment);
            let nextItem;
            switch (e.key) {
              case kbd.ARROW_DOWN:
                nextItem = next(candidateNodes, currentIndex, $loop);
                break;
              case kbd.ARROW_UP:
                nextItem = prev(candidateNodes, currentIndex, $loop);
                break;
              case kbd.PAGE_DOWN:
                nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.PAGE_UP:
                nextItem = back(candidateNodes, currentIndex, 10, $loop);
                break;
              case kbd.HOME:
                nextItem = candidateNodes[0];
                break;
              case kbd.END:
                nextItem = last(candidateNodes);
                break;
              default:
                return;
            }
            highlightedItem.set(nextItem);
            nextItem.scrollIntoView({ block: $scrollAlignment });
          }
        }),
        // Listens to the input value and filters the items accordingly.
        addMeltEventListener(node, "input", (e) => {
          if (!isHTMLInputElement(e.target))
            return;
          const value = e.target.value;
          inputValue.debouncedSet(value);
          touchedInput.debouncedSet(true);
          tick().then(() => {
            const $highlightedItem = get_store_value(highlightedItem);
            if ($highlightedItem == null ? void 0 : $highlightedItem.dataset.hidden) {
              const menuElement = document.getElementById(ids.menu);
              if (!isHTMLElement(menuElement))
                return;
              const itemElements = getOptions(menuElement);
              const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && !opt.dataset.hidden);
              highlightedItem.set(candidateNodes[0] ?? null);
            }
          });
        })
      );
      let unsubEscapeKeydown = noop;
      const escape = useEscapeKeydown(node, {
        handler: () => {
          closeMenu();
          reset();
        }
      });
      if (escape && escape.destroy) {
        unsubEscapeKeydown = escape.destroy;
      }
      return {
        destroy() {
          unsubscribe();
          unsubEscapeKeydown();
        }
      };
    }
  });
  const menu = builder(name3("menu"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        id: ids.menu,
        role: "listbox",
        style: styleToString({ display: $isVisible ? void 0 : "none" })
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      let unsubScroll = noop;
      const unsubscribe = executeCallbacks(
        //  Bind the popper portal to the input element.
        effect([
          isVisible,
          preventScroll,
          closeOnEscape,
          portal,
          closeOnOutsideClick,
          positioning,
          activeTrigger
        ], ([$isVisible, $preventScroll, $closeOnEscape, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
          unsubPopper();
          unsubScroll();
          if (!$isVisible || !$activeTrigger)
            return;
          if ($preventScroll) {
            unsubScroll = removeScroll();
          }
          const ignoreHandler = createClickOutsideIgnore(ids.input);
          const popper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              focusTrap: null,
              clickOutside: $closeOnOutsideClick ? {
                handler: (e) => {
                  const target = e.target;
                  if (target === $activeTrigger)
                    return;
                  closeMenu();
                  reset();
                },
                ignore: ignoreHandler
              } : null,
              escapeKeydown: $closeOnEscape ? {
                handler: () => {
                  closeMenu();
                  reset();
                }
              } : null,
              portal: getPortalDestination(node, $portal)
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        }),
        // Remove highlight when the pointer leaves the menu.
        addMeltEventListener(node, "pointerleave", () => {
          highlightedItem.set(null);
        })
      );
      return {
        destroy: () => {
          unsubscribe();
          unsubPopper();
          unsubScroll();
        }
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get_store_value(labelBuilder);
  const label = builder(name3("label"), {
    returned: () => {
      return {
        id: ids.label,
        for: ids.input
      };
    },
    action: labelAction
  });
  const option = builder(name3("option"), {
    stores: [selected, filterFunction, inputValue, touchedInput],
    returned: ([$value, $filterFunction, $inputValue, $touchedInput]) => (props2) => {
      let hidden = false;
      if ($touchedInput.debounced && ($filterFunction == null ? void 0 : $filterFunction({ input: $inputValue.debounced, itemValue: props2.value })) === false) {
        hidden = true;
      }
      const selected2 = dequal(props2.value, $value);
      return {
        "data-value": JSON.stringify(props2.value),
        "data-label": props2.label,
        "data-disabled": props2.disabled ? "" : void 0,
        "aria-disabled": props2.disabled ? true : void 0,
        "aria-selected": selected2,
        "data-selected": selected2 ? "" : void 0,
        hidden: hidden ? true : void 0,
        "data-hidden": hidden ? "" : void 0,
        id: generateId(),
        role: "option",
        style: styleToString({ cursor: props2.disabled ? "default" : "pointer" })
      };
    },
    action: (node) => {
      const unsubscribe = executeCallbacks(
        // Handle highlighting items when the pointer moves over them.
        addMeltEventListener(node, "pointermove", () => {
          if (isElementDisabled(node)) {
            highlightedItem.set(null);
            return;
          }
          highlightedItem.set(node);
        }),
        addMeltEventListener(node, "click", (e) => {
          if (isElementDisabled(node)) {
            e.preventDefault();
            return;
          }
          selectItem(node);
          closeMenu();
        })
      );
      return { destroy: unsubscribe };
    }
  });
  onMount(() => {
    open.set(withDefaults.defaultOpen);
    if (!isBrowser)
      return;
    const menuEl = document.getElementById(ids.menu);
    if (!menuEl)
      return;
    const triggerEl = getElementByMeltId(ids.input);
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
    const selectedEl = menuEl.querySelector("[data-selected]");
    if (!isHTMLElement(selectedEl))
      return;
    const dataLabel = selectedEl.getAttribute("data-label");
    inputValue.debouncedSet(dataLabel ?? selectedEl.textContent ?? "");
  });
  effect(selected, function setInputValue($selected) {
    inputValue.debouncedSet(($selected == null ? void 0 : $selected.label) ?? "");
  });
  effect([highlightedItem, scrollAlignment], ([$highlightedItem, $scrollAlignment]) => {
    if (!isBrowser)
      return;
    const menuElement = document.getElementById(ids.menu);
    if (!isHTMLElement(menuElement))
      return;
    getOptions(menuElement).forEach((node) => {
      if (node === $highlightedItem) {
        addHighlight(node);
      } else {
        removeHighlight(node);
      }
    });
    if ($highlightedItem) {
      sleep(1).then(() => $highlightedItem.scrollIntoView({ block: $scrollAlignment }));
    }
  });
  effect([inputValue, touchedInput], () => {
    handleIsEmpty();
  });
  return {
    elements: {
      input,
      option,
      menu,
      label
    },
    states: {
      open,
      selected,
      highlighted,
      inputValue,
      isEmpty: readonly(isEmpty)
    },
    helpers: {
      isSelected,
      isHighlighted
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/menu/create.js
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd.ARROW_LEFT],
  rtl: [kbd.ARROW_RIGHT]
};
var defaults7 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: "body",
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  typeahead: true
};
function createMenuBuilder(opts) {
  const { name: name22, selector: selector11 } = createElHelpers(opts.selector);
  const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead } = opts.rootOptions;
  const rootOpen = opts.rootOpen;
  const rootActiveTrigger = opts.rootActiveTrigger;
  const nextFocusable = opts.nextFocusable;
  const prevFocusable = opts.prevFocusable;
  const isUsingKeyboard = writable(false);
  const lastPointerX = writable(0);
  const pointerGraceIntent = writable(null);
  const pointerDir = writable("right");
  const currentFocusedItem = writable(null);
  const pointerMovingToSubmenu = derivedWithUnsubscribe([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {
    return (e) => {
      const isMovingTowards = $pointerDir === ($pointerGraceIntent == null ? void 0 : $pointerGraceIntent.side);
      return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent == null ? void 0 : $pointerGraceIntent.area);
    };
  });
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const rootIds = {
    menu: generateId(),
    trigger: generateId()
  };
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const rootMenu = builder(name22(), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: rootIds.menu,
        "aria-labelledby": rootIds.trigger,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector11);
          const popper = usePopper(node, {
            anchorElement: $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? void 0 : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e);
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const rootTrigger = builder(name22("trigger"), {
    stores: [rootOpen],
    returned: ([$rootOpen]) => {
      return {
        "aria-controls": rootIds.menu,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: rootIds.trigger,
        tabindex: 0
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        const $rootOpen = get_store_value(rootOpen);
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        handleOpen(triggerEl);
        if (!$rootOpen)
          e.preventDefault();
      }), addMeltEventListener(node, "keydown", (e) => {
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))
          return;
        e.preventDefault();
        handleOpen(triggerEl);
        const menuId = triggerEl.getAttribute("aria-controls");
        if (!menuId)
          return;
        const menu = document.getElementById(menuId);
        if (!menu)
          return;
        const menuItems = getMenuItems(menu);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const rootArrow = builder(name22("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const item = builder(name22("item"), {
    returned: () => {
      return {
        role: "menuitem",
        tabindex: -1,
        "data-orientation": "vertical"
      };
    },
    action: (node) => {
      setMeltMenuAttribute(node, selector11);
      applyAttrsIfDisabled(node);
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
      }), addMeltEventListener(node, "click", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (isElementDisabled(itemEl)) {
          e.preventDefault();
          return;
        }
        if (e.defaultPrevented) {
          handleRovingFocus(itemEl);
          return;
        }
        sleep(1).then(() => {
          rootOpen.set(false);
        });
      }), addMeltEventListener(node, "keydown", (e) => {
        onItemKeyDown(e);
      }), addMeltEventListener(node, "pointermove", (e) => {
        onMenuItemPointerMove(e);
      }), addMeltEventListener(node, "pointerleave", (e) => {
        onMenuItemPointerLeave(e);
      }), addMeltEventListener(node, "focusin", (e) => {
        onItemFocusIn(e);
      }), addMeltEventListener(node, "focusout", (e) => {
        onItemFocusOut(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const group = builder(name22("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = builder(name22("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const checkboxItemDefaults = {
    defaultChecked: false,
    disabled: false
  };
  const createCheckboxItem = (props) => {
    const withDefaults = { ...checkboxItemDefaults, ...props };
    const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);
    const checked = overridable(checkedWritable, withDefaults.onCheckedChange);
    const disabled = writable(withDefaults.disabled);
    const checkboxItem = builder(name22("checkbox-item"), {
      stores: [checked, disabled],
      returned: ([$checked, $disabled]) => {
        return {
          role: "menuitemcheckbox",
          tabindex: -1,
          "data-orientation": "vertical",
          "aria-checked": isIndeterminate($checked) ? "mixed" : $checked ? "true" : "false",
          "data-disabled": $disabled ? "" : void 0,
          "data-state": getCheckedState($checked)
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector11);
        applyAttrsIfDisabled(node);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            handleRovingFocus(itemEl);
            return;
          }
          checked.update((prev2) => {
            if (isIndeterminate(prev2))
              return true;
            return !prev2;
          });
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          if (isElementDisabled(itemEl)) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    return {
      elements: {
        checkboxItem
      },
      states: {
        checked
      },
      options: {
        disabled
      }
    };
  };
  const createMenuRadioGroup = (args = {}) => {
    const valueWritable = args.value ?? writable(args.defaultValue ?? null);
    const value = overridable(valueWritable, args.onValueChange);
    const radioGroup = builder(name22("radio-group"), {
      returned: () => ({
        role: "group"
      })
    });
    const radioItemDefaults = {
      disabled: false
    };
    const radioItem = builder(name22("radio-item"), {
      stores: [value],
      returned: ([$value]) => {
        return (itemProps) => {
          const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };
          const checked = $value === itemValue;
          return {
            disabled,
            role: "menuitemradio",
            "data-state": checked ? "checked" : "unchecked",
            "aria-checked": checked,
            "data-disabled": disabled ? "" : void 0,
            "data-value": itemValue,
            "data-orientation": "vertical",
            tabindex: -1
          };
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector11);
        const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
        }), addMeltEventListener(node, "click", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            e.preventDefault();
            return;
          }
          if (e.defaultPrevented) {
            if (!isHTMLElement(itemEl))
              return;
            handleRovingFocus(itemEl);
            return;
          }
          value.set(itemValue);
          tick().then(() => {
            rootOpen.set(false);
          });
        }), addMeltEventListener(node, "keydown", (e) => {
          onItemKeyDown(e);
        }), addMeltEventListener(node, "pointermove", (e) => {
          const itemEl = e.currentTarget;
          if (!isHTMLElement(itemEl))
            return;
          const itemValue = node.dataset.value;
          const disabled = node.dataset.disabled;
          if (disabled || itemValue === void 0) {
            onItemLeave(e);
            return;
          }
          onMenuItemPointerMove(e, itemEl);
        }), addMeltEventListener(node, "pointerleave", (e) => {
          onMenuItemPointerLeave(e);
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          onItemFocusOut(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isChecked = derived(value, ($value) => {
      return (itemValue) => {
        return $value === itemValue;
      };
    });
    return {
      elements: {
        radioGroup,
        radioItem
      },
      states: {
        value
      },
      helpers: {
        isChecked
      }
    };
  };
  const { elements: { root: separator } } = createSeparator({
    orientation: "horizontal"
  });
  const subMenuDefaults = {
    ...defaults7,
    disabled: false,
    positioning: {
      placement: "right-start",
      gutter: 8
    }
  };
  const createSubmenu = (args) => {
    const withDefaults = { ...subMenuDefaults, ...args };
    const subOpen = writable(false);
    const options = toWritableStores(withDefaults);
    const { positioning: positioning2, arrowSize: arrowSize2, disabled } = options;
    const subActiveTrigger = writable(null);
    const subOpenTimer = writable(null);
    const pointerGraceTimer = writable(0);
    const subIds = {
      menu: generateId(),
      trigger: generateId()
    };
    onMount(() => {
      const subTrigger2 = document.getElementById(subIds.trigger);
      if (subTrigger2) {
        subActiveTrigger.set(subTrigger2);
      }
    });
    const subIsVisible = derivedVisible({
      open: subOpen,
      forceVisible,
      activeTrigger: subActiveTrigger
    });
    const subMenu = builder(name22("submenu"), {
      stores: [subIsVisible],
      returned: ([$subIsVisible]) => {
        return {
          role: "menu",
          hidden: $subIsVisible ? void 0 : true,
          style: styleToString({
            display: $subIsVisible ? void 0 : "none"
          }),
          id: subIds.menu,
          "aria-labelledby": subIds.trigger,
          "data-state": $subIsVisible ? "open" : "closed",
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop;
        const unsubDerived = effect([subIsVisible, positioning2], ([$subIsVisible, $positioning]) => {
          unsubPopper();
          if (!$subIsVisible)
            return;
          const activeTrigger = get_store_value(subActiveTrigger);
          if (!activeTrigger)
            return;
          tick().then(() => {
            const parentMenuEl = getParentMenu(activeTrigger);
            const popper = usePopper(node, {
              anchorElement: activeTrigger,
              open: subOpen,
              options: {
                floating: $positioning,
                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : void 0,
                clickOutside: null,
                focusTrap: null
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd.ESCAPE) {
            return;
          }
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement(target) || !isHTMLElement(menuEl))
            return;
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            e.stopImmediatePropagation();
            handleMenuNavigation(e);
            return;
          }
          const isCloseKey = SUB_CLOSE_KEYS["ltr"].includes(e.key);
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          const isCharacterKey = e.key.length === 1;
          if (isCloseKey) {
            const $subActiveTrigger = get_store_value(subActiveTrigger);
            e.preventDefault();
            subOpen.update(() => {
              if ($subActiveTrigger) {
                handleRovingFocus($subActiveTrigger);
              }
              return false;
            });
            return;
          }
          if (e.key === kbd.TAB) {
            e.preventDefault();
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
            return;
          }
          if (!isModifierKey && isCharacterKey && get_store_value(typeahead) === true) {
            handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          onMenuPointerMove(e);
        }), addMeltEventListener(node, "focusout", (e) => {
          const $subActiveTrigger = get_store_value(subActiveTrigger);
          if (get_store_value(isUsingKeyboard)) {
            const target = e.target;
            const submenuEl = document.getElementById(subIds.menu);
            if (!isHTMLElement(submenuEl) || !isHTMLElement(target))
              return;
            if (!submenuEl.contains(target) && target !== $subActiveTrigger) {
              subOpen.set(false);
            }
          } else {
            const menuEl = e.currentTarget;
            const relatedTarget = e.relatedTarget;
            if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))
              return;
            if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {
              subOpen.set(false);
            }
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubPopper();
            unsubEvents();
          }
        };
      }
    });
    const subTrigger = builder(name22("subtrigger"), {
      stores: [subOpen, disabled],
      returned: ([$subOpen, $disabled]) => {
        return {
          role: "menuitem",
          id: subIds.trigger,
          tabindex: -1,
          "aria-controls": subIds.menu,
          "aria-expanded": $subOpen,
          "data-state": $subOpen ? "open" : "closed",
          "data-disabled": $disabled ? "" : void 0,
          "aria-haspopop": "menu"
        };
      },
      action: (node) => {
        setMeltMenuAttribute(node, selector11);
        applyAttrsIfDisabled(node);
        const unsubTimer = () => {
          clearTimerStore(subOpenTimer);
          window.clearTimeout(get_store_value(pointerGraceTimer));
          pointerGraceIntent.set(null);
        };
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "click", (e) => {
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          if (!get_store_value(subOpen)) {
            subOpen.update((prev2) => {
              const isAlreadyOpen = prev2;
              if (!isAlreadyOpen) {
                subActiveTrigger.set(triggerEl);
                return !prev2;
              }
              return prev2;
            });
          }
        }), addMeltEventListener(node, "keydown", (e) => {
          const $typed = get_store_value(typed);
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))
            return;
          const isTypingAhead = $typed.length > 0;
          if (isTypingAhead && e.key === kbd.SPACE)
            return;
          if (SUB_OPEN_KEYS["ltr"].includes(e.key)) {
            if (!get_store_value(subOpen)) {
              triggerEl.click();
              e.preventDefault();
              return;
            }
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menuEl = document.getElementById(menuId);
            if (!isHTMLElement(menuEl))
              return;
            const firstItem = getMenuItems(menuEl)[0];
            handleRovingFocus(firstItem);
          }
        }), addMeltEventListener(node, "pointermove", (e) => {
          if (!isMouse(e))
            return;
          onItemEnter(e);
          if (e.defaultPrevented)
            return;
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          handleRovingFocus(triggerEl);
          const openTimer = get_store_value(subOpenTimer);
          if (!get_store_value(subOpen) && !openTimer && !isElementDisabled(triggerEl)) {
            subOpenTimer.set(window.setTimeout(() => {
              subOpen.update(() => {
                subActiveTrigger.set(triggerEl);
                return true;
              });
              clearTimerStore(subOpenTimer);
            }, 100));
          }
        }), addMeltEventListener(node, "pointerleave", (e) => {
          if (!isMouse(e))
            return;
          clearTimerStore(subOpenTimer);
          const submenuEl = document.getElementById(subIds.menu);
          const contentRect = submenuEl == null ? void 0 : submenuEl.getBoundingClientRect();
          if (contentRect) {
            const side = submenuEl == null ? void 0 : submenuEl.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            pointerGraceIntent.set({
              area: [
                // Apply a bleed on clientX to ensure that our exit point is
                // consistently within polygon bounds
                { x: e.clientX + bleed, y: e.clientY },
                { x: contentNearEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.top },
                { x: contentFarEdge, y: contentRect.bottom },
                { x: contentNearEdge, y: contentRect.bottom }
              ],
              side
            });
            window.clearTimeout(get_store_value(pointerGraceTimer));
            pointerGraceTimer.set(window.setTimeout(() => {
              pointerGraceIntent.set(null);
            }, 300));
          } else {
            onTriggerLeave(e);
            if (e.defaultPrevented)
              return;
            pointerGraceIntent.set(null);
          }
        }), addMeltEventListener(node, "focusout", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          removeHighlight(triggerEl);
          const relatedTarget = e.relatedTarget;
          if (!isHTMLElement(relatedTarget))
            return;
          const menuId = triggerEl.getAttribute("aria-controls");
          if (!menuId)
            return;
          const menu = document.getElementById(menuId);
          if (menu && !menu.contains(relatedTarget)) {
            subOpen.set(false);
          }
        }), addMeltEventListener(node, "focusin", (e) => {
          onItemFocusIn(e);
        }));
        return {
          destroy() {
            unsubTimer();
            unsubEvents();
          }
        };
      }
    });
    const subArrow = builder(name22("subarrow"), {
      stores: arrowSize2,
      returned: ($arrowSize) => ({
        "data-arrow": true,
        style: styleToString({
          position: "absolute",
          width: `var(--arrow-size, ${$arrowSize}px)`,
          height: `var(--arrow-size, ${$arrowSize}px)`
        })
      })
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!$rootOpen) {
        subActiveTrigger.set(null);
        subOpen.set(false);
      }
    });
    effect([pointerGraceIntent], ([$pointerGraceIntent]) => {
      if (!isBrowser || $pointerGraceIntent)
        return;
      window.clearTimeout(get_store_value(pointerGraceTimer));
    });
    effect([subOpen], ([$subOpen]) => {
      if (!isBrowser)
        return;
      sleep(1).then(() => {
        const menuEl = document.getElementById(subIds.menu);
        if (!menuEl)
          return;
        if ($subOpen && get_store_value(isUsingKeyboard)) {
          const menuItems = getMenuItems(menuEl);
          if (!menuItems.length)
            return;
          handleRovingFocus(menuItems[0]);
        }
        if (!$subOpen) {
          const focusedItem = get_store_value(currentFocusedItem);
          if (focusedItem && menuEl.contains(focusedItem)) {
            removeHighlight(focusedItem);
          }
        }
        if (menuEl && !$subOpen) {
          const subTriggerEl = document.getElementById(subIds.trigger);
          if (!subTriggerEl || document.activeElement === subTriggerEl)
            return;
          removeHighlight(subTriggerEl);
        }
      });
    });
    return {
      elements: {
        subTrigger,
        subMenu,
        subArrow
      },
      states: {
        subOpen
      },
      options
    };
  };
  onMount(() => {
    const triggerEl = document.getElementById(rootIds.trigger);
    if (isHTMLElement(triggerEl) && get_store_value(rootOpen)) {
      rootActiveTrigger.set(triggerEl);
    }
    const unsubs = [];
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = () => {
      isUsingKeyboard.set(true);
      unsubs.push(executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true })));
    };
    const keydownListener = (e) => {
      if (e.key === kbd.ESCAPE && get_store_value(closeOnEscape)) {
        rootOpen.set(false);
        return;
      }
    };
    unsubs.push(addEventListener(document, "keydown", handleKeyDown, { capture: true }));
    unsubs.push(addEventListener(document, "keydown", keydownListener));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {
    if (!$rootOpen && $currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
  });
  effect([rootOpen, rootActiveTrigger, preventScroll], ([$rootOpen, $rootActiveTrigger, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if (opts.removeScroll && $rootOpen && $preventScroll) {
      unsubs.push(removeScroll());
    }
    if (!$rootOpen && $rootActiveTrigger) {
      handleRovingFocus($rootActiveTrigger);
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(rootIds.menu);
      if (menuEl && $rootOpen && get_store_value(isUsingKeyboard)) {
        if (opts.disableFocusFirstItem) {
          handleRovingFocus(menuEl);
          return;
        }
        const menuItems = getMenuItems(menuEl);
        if (!menuItems.length)
          return;
        handleRovingFocus(menuItems[0]);
      } else if ($rootActiveTrigger) {
        handleRovingFocus($rootActiveTrigger);
      } else {
        if (opts.disableTriggerRefocus) {
          return;
        }
        const triggerEl = document.getElementById(rootIds.trigger);
        if (!triggerEl)
          return;
        handleRovingFocus(triggerEl);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect(rootOpen, ($rootOpen) => {
    if (!isBrowser)
      return;
    const handlePointer = () => isUsingKeyboard.set(false);
    const handleKeyDown = (e) => {
      isUsingKeyboard.set(true);
      if (e.key === kbd.ESCAPE && $rootOpen) {
        rootOpen.set(false);
        return;
      }
    };
    return executeCallbacks(addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true }), addEventListener(document, "keydown", handleKeyDown, { capture: true }));
  });
  function handleOpen(triggerEl) {
    rootOpen.update((prev2) => {
      const isOpen = !prev2;
      if (isOpen) {
        nextFocusable.set(getNextFocusable(triggerEl));
        prevFocusable.set(getPreviousFocusable(triggerEl));
        rootActiveTrigger.set(triggerEl);
      }
      return isOpen;
    });
  }
  function onItemFocusIn(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    const $currentFocusedItem = get_store_value(currentFocusedItem);
    if ($currentFocusedItem) {
      removeHighlight($currentFocusedItem);
    }
    addHighlight(itemEl);
    currentFocusedItem.set(itemEl);
  }
  function onItemFocusOut(e) {
    const itemEl = e.currentTarget;
    if (!isHTMLElement(itemEl))
      return;
    removeHighlight(itemEl);
  }
  function onItemEnter(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onItemLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    const target = e.target;
    if (!isHTMLElement(target))
      return;
    const parentMenuEl = getParentMenu(target);
    if (!parentMenuEl)
      return;
    handleRovingFocus(parentMenuEl);
  }
  function onTriggerLeave(e) {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  }
  function onMenuPointerMove(e) {
    if (!isMouse(e))
      return;
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
      return;
    const $lastPointerX = get_store_value(lastPointerX);
    const pointerXHasChanged = $lastPointerX !== e.clientX;
    if (currentTarget.contains(target) && pointerXHasChanged) {
      const newDir = e.clientX > $lastPointerX ? "right" : "left";
      pointerDir.set(newDir);
      lastPointerX.set(e.clientX);
    }
  }
  function onMenuItemPointerMove(e, currTarget = null) {
    if (!isMouse(e))
      return;
    onItemEnter(e);
    if (e.defaultPrevented)
      return;
    if (currTarget) {
      handleRovingFocus(currTarget);
      return;
    }
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onMenuItemPointerLeave(e) {
    if (!isMouse(e))
      return;
    onItemLeave(e);
  }
  function onItemKeyDown(e) {
    const $typed = get_store_value(typed);
    const isTypingAhead = $typed.length > 0;
    if (isTypingAhead && e.key === kbd.SPACE) {
      e.preventDefault();
      return;
    }
    if (SELECTION_KEYS.includes(e.key)) {
      e.preventDefault();
      const itemEl = e.currentTarget;
      if (!isHTMLElement(itemEl))
        return;
      itemEl.click();
    }
  }
  function isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function getCheckedState(checked) {
    return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function isPointerMovingToSubmenu(e) {
    return get_store_value(pointerMovingToSubmenu)(e);
  }
  function getParentMenu(element) {
    const parentMenuEl = element.closest('[role="menu"]');
    if (!isHTMLElement(parentMenuEl))
      return null;
    return parentMenuEl;
  }
  return {
    trigger: rootTrigger,
    menu: rootMenu,
    open: rootOpen,
    item,
    group,
    groupLabel,
    arrow: rootArrow,
    options: opts.rootOptions,
    createCheckboxItem,
    createSubmenu,
    createMenuRadioGroup,
    separator,
    rootIds,
    handleTypeaheadSearch
  };
}
function handleTabNavigation(e, nextFocusable, prevFocusable) {
  if (e.shiftKey) {
    const $prevFocusable = get_store_value(prevFocusable);
    if ($prevFocusable) {
      e.preventDefault();
      $prevFocusable.focus();
      prevFocusable.set(null);
    }
  } else {
    const $nextFocusable = get_store_value(nextFocusable);
    if ($nextFocusable) {
      e.preventDefault();
      $nextFocusable.focus();
      nextFocusable.set(null);
    }
  }
}
function getMenuItems(menuElement) {
  return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id="${menuElement.id}"]`)).filter((item) => isHTMLElement(item));
}
function applyAttrsIfDisabled(element) {
  if (!element || !isElementDisabled(element))
    return;
  element.setAttribute("data-disabled", "");
  element.setAttribute("aria-disabled", "true");
}
function clearTimerStore(timerStore) {
  if (!isBrowser)
    return;
  const timer = get_store_value(timerStore);
  if (timer) {
    window.clearTimeout(timer);
    timerStore.set(null);
  }
}
function isMouse(e) {
  return e.pointerType === "mouse";
}
function setMeltMenuAttribute(element, selector11) {
  if (!element)
    return;
  const menuEl = element.closest(`${selector11()}, ${selector11("submenu")}`);
  if (!isHTMLElement(menuEl))
    return;
  element.setAttribute("data-melt-menu-id", menuEl.id);
}
function handleMenuNavigation(e) {
  e.preventDefault();
  const currentFocusedItem = document.activeElement;
  const currentTarget = e.currentTarget;
  if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
    return;
  const menuItems = getMenuItems(currentTarget);
  if (!menuItems.length)
    return;
  const candidateNodes = menuItems.filter((item) => {
    if (item.hasAttribute("data-disabled") || item.getAttribute("disabled") === "true") {
      return false;
    }
    return true;
  });
  const currentIndex = candidateNodes.indexOf(currentFocusedItem);
  let nextIndex;
  switch (e.key) {
    case kbd.ARROW_DOWN:
      nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;
      break;
    case kbd.ARROW_UP:
      nextIndex = currentIndex > 0 ? currentIndex - 1 : 0;
      break;
    case kbd.HOME:
      nextIndex = 0;
      break;
    case kbd.END:
      nextIndex = candidateNodes.length - 1;
      break;
    default:
      return;
  }
  handleRovingFocus(candidateNodes[nextIndex]);
}
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  const cursorPos = { x: e.clientX, y: e.clientY };
  return isPointInPolygon(cursorPos, area);
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/context-menu/create.js
var defaults8 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom-start"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true
};
var { name: name4, selector: selector3 } = createElHelpers("context-menu");
function createContextMenu(props) {
  const withDefaults = { ...defaults8, ...props };
  const rootOptions = toWritableStores(withDefaults);
  const { positioning, closeOnOutsideClick, portal, forceVisible, closeOnEscape } = rootOptions;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { item, createCheckboxItem, arrow: arrow2, createSubmenu, createMenuRadioGroup, rootIds, separator, handleTypeaheadSearch, group, groupLabel } = createMenuBuilder({
    rootOpen,
    rootActiveTrigger,
    rootOptions,
    nextFocusable,
    prevFocusable,
    disableFocusFirstItem: true,
    disableTriggerRefocus: true,
    selector: "context-menu",
    removeScroll: true
  });
  const point = writable(null);
  const virtual = derivedWithUnsubscribe([point], ([$point]) => {
    if ($point === null)
      return null;
    return {
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...$point
      })
    };
  });
  const longPressTimer = writable(0);
  function handleClickOutside(e) {
    if (e.defaultPrevented)
      return;
    const target = e.target;
    if (!(target instanceof Element))
      return;
    if (target.id === rootIds.trigger && isLeftClick(e)) {
      rootOpen.set(false);
      return;
    }
    if (target.id !== rootIds.trigger && !target.closest(selector3())) {
      rootOpen.set(false);
    }
  }
  const isVisible = derivedVisible({
    open: rootOpen,
    forceVisible,
    activeTrigger: rootActiveTrigger
  });
  const menu = builder(name4(), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "menu",
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: rootIds.menu,
        "aria-labelledby": rootIds.trigger,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0,
        tabindex: -1
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$rootActiveTrigger)
          return;
        tick().then(() => {
          setMeltMenuAttribute(node, selector3);
          const $virtual = get_store_value(virtual);
          const popper = usePopper(node, {
            anchorElement: $virtual ? $virtual : $rootActiveTrigger,
            open: rootOpen,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? {
                handler: handleClickOutside
              } : null,
              portal: getPortalDestination(node, $portal),
              escapeKeydown: $closeOnEscape ? void 0 : null
            }
          });
          if (!popper || !popper.destroy)
            return;
          unsubPopper = popper.destroy;
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const target = e.target;
        const menuEl = e.currentTarget;
        if (!isHTMLElement(target) || !isHTMLElement(menuEl))
          return;
        const isKeyDownInside = target.closest("[role='menu']") === menuEl;
        if (!isKeyDownInside)
          return;
        if (FIRST_LAST_KEYS.includes(e.key)) {
          handleMenuNavigation(e);
        }
        if (e.key === kbd.TAB) {
          e.preventDefault();
          rootOpen.set(false);
          handleTabNavigation(e, nextFocusable, prevFocusable);
          return;
        }
        const isCharacterKey = e.key.length === 1;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        if (!isModifierKey && isCharacterKey) {
          handleTypeaheadSearch(e.key, getMenuItems(menuEl));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubEvents();
          unsubPopper();
        }
      };
    }
  });
  const trigger = builder(name4("trigger"), {
    stores: rootOpen,
    returned: ($rootOpen) => {
      return {
        "aria-controls": rootIds.menu,
        "aria-expanded": $rootOpen,
        "data-state": $rootOpen ? "open" : "closed",
        id: rootIds.trigger,
        style: styleToString({
          WebkitTouchCallout: "none"
        })
      };
    },
    action: (node) => {
      applyAttrsIfDisabled(node);
      const handleOpen = (e) => {
        point.set({
          x: e.clientX,
          y: e.clientY
        });
        nextFocusable.set(getNextFocusable(node));
        prevFocusable.set(getPreviousFocusable(node));
        rootActiveTrigger.set(node);
        rootOpen.set(true);
      };
      const unsubTimer = () => {
        clearTimerStore(longPressTimer);
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "contextmenu", (e) => {
        clearTimerStore(longPressTimer);
        handleOpen(e);
        e.preventDefault();
      }), addMeltEventListener(node, "pointerdown", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
        longPressTimer.set(window.setTimeout(() => handleOpen(e), 700));
      }), addMeltEventListener(node, "pointermove", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointercancel", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }), addMeltEventListener(node, "pointerup", (e) => {
        if (!isTouchOrPen(e))
          return;
        clearTimerStore(longPressTimer);
      }));
      return {
        destroy() {
          unsubTimer();
          unsub();
        }
      };
    }
  });
  return {
    elements: {
      menu,
      trigger,
      item,
      arrow: arrow2,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createSubmenu,
      createCheckboxItem,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}
function isTouchOrPen(e) {
  return e.pointerType !== "mouse";
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/dialog/create.js
var { name: name5 } = createElHelpers("dialog");
var defaults9 = {
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  role: "dialog",
  defaultOpen: false,
  portal: "body",
  forceVisible: false
};
var openDialogIds = writable([]);
function createDialog(props) {
  const withDefaults = { ...defaults9, ...props };
  const options = toWritableStores(withDefaults);
  const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible } = options;
  const activeTrigger = writable(null);
  const ids = {
    content: generateId(),
    title: generateId(),
    description: generateId(),
    trigger: generateId()
  };
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {
    return $open || $forceVisible;
  });
  function handleOpen(e) {
    const el = e.currentTarget;
    const triggerEl = e.currentTarget;
    if (!isHTMLElement(el) || !isHTMLElement(triggerEl))
      return;
    open.set(true);
    activeTrigger.set(triggerEl);
  }
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(ids.trigger);
    if (triggerEl) {
      tick().then(() => {
        triggerEl.focus();
      });
    }
  }
  onMount(() => {
    activeTrigger.set(document.getElementById(ids.trigger));
  });
  effect([open], ([$open]) => {
    sleep(100).then(() => {
      if ($open) {
        openDialogIds.update((prev2) => {
          prev2.push(ids.content);
          return prev2;
        });
      } else {
        openDialogIds.update((prev2) => prev2.filter((id) => id !== ids.content));
      }
    });
  });
  const trigger = builder(name5("trigger"), {
    stores: open,
    returned: ($open) => {
      return {
        id: ids.trigger,
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "aria-controls": ids.content,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        handleOpen(e);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleOpen(e);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const overlay = builder(name5("overlay"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        "aria-hidden": true,
        "data-state": $isVisible ? "open" : "closed"
      };
    },
    action: (node) => {
      let unsubEscapeKeydown = noop;
      if (get_store_value(closeOnEscape)) {
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          unsubEscapeKeydown = escapeKeydown.destroy;
        }
      }
      return {
        destroy() {
          unsubEscapeKeydown();
        }
      };
    }
  });
  const content = builder(name5("content"), {
    stores: [isVisible],
    returned: ([$isVisible]) => {
      return {
        id: ids.content,
        role: get_store_value(role),
        "aria-describedby": ids.description,
        "aria-labelledby": ids.title,
        "data-state": $isVisible ? "open" : "closed",
        tabindex: -1,
        hidden: $isVisible ? void 0 : true,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        })
      };
    },
    action: (node) => {
      let activate = noop;
      let deactivate = noop;
      const destroy = executeCallbacks(effect([open], ([$open]) => {
        if (!$open)
          return;
        const focusTrap = createFocusTrap3({
          immediate: false,
          escapeDeactivates: false,
          returnFocusOnDeactivate: false,
          fallbackFocus: node
        });
        activate = focusTrap.activate;
        deactivate = focusTrap.deactivate;
        const ac = focusTrap.useFocusTrap(node);
        if (ac && ac.destroy) {
          return ac.destroy;
        } else {
          return focusTrap.deactivate;
        }
      }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {
        return useClickOutside(node, {
          enabled: $open,
          handler: (e) => {
            if (e.defaultPrevented)
              return;
            const $openDialogIds = get_store_value(openDialogIds);
            const isLast = last($openDialogIds) === ids.content;
            if ($closeOnOutsideClick && isLast) {
              handleClose();
            }
          }
        }).destroy;
      }), effect([closeOnEscape], ([$closeOnEscape]) => {
        if (!$closeOnEscape)
          return noop;
        const escapeKeydown = useEscapeKeydown(node, {
          handler: () => {
            handleClose();
          }
        });
        if (escapeKeydown && escapeKeydown.destroy) {
          return escapeKeydown.destroy;
        }
        return noop;
      }), effect([isVisible], ([$isVisible]) => {
        tick().then(() => {
          if (!$isVisible) {
            deactivate();
          } else {
            activate();
          }
        });
      }));
      return {
        destroy
      };
    }
  });
  const portalled = builder(name5("portalled"), {
    stores: portal,
    returned: ($portal) => ({
      "data-portal": $portal ? "" : void 0
    }),
    action: (node) => {
      const unsubPortal = effect([portal], ([$portal]) => {
        if (!$portal)
          return noop;
        const portalDestination = getPortalDestination(node, $portal);
        if (portalDestination === null)
          return noop;
        const portalAction = usePortal(node, portalDestination);
        if (portalAction && portalAction.destroy) {
          return portalAction.destroy;
        } else {
          return noop;
        }
      });
      return {
        destroy() {
          unsubPortal();
        }
      };
    }
  });
  const title = builder(name5("title"), {
    returned: () => ({
      id: ids.title
    })
  });
  const description = builder(name5("description"), {
    returned: () => ({
      id: ids.description
    })
  });
  const close = builder(name5("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)
          return;
        e.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, preventScroll], ([$open, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if ($preventScroll && $open)
      unsubs.push(removeScroll());
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    elements: {
      content,
      trigger,
      title,
      description,
      overlay,
      close,
      portalled
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js
var defaults10 = {
  arrowSize: 8,
  positioning: {
    placement: "bottom"
  },
  preventScroll: true,
  closeOnEscape: true,
  closeOnOutsideClick: true,
  portal: void 0,
  loop: false,
  dir: "ltr",
  defaultOpen: false,
  forceVisible: false,
  typeahead: true
};
function createDropdownMenu(props) {
  const withDefaults = { ...defaults10, ...props };
  const rootOptions = toWritableStores(withDefaults);
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const rootOpen = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const rootActiveTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const { trigger, menu, item, arrow: arrow2, createSubmenu, createCheckboxItem, createMenuRadioGroup, separator, group, groupLabel } = createMenuBuilder({
    rootOptions,
    rootOpen,
    rootActiveTrigger,
    nextFocusable,
    prevFocusable,
    disableTriggerRefocus: true,
    selector: "dropdown-menu",
    removeScroll: true
  });
  return {
    elements: {
      trigger,
      menu,
      item,
      arrow: arrow2,
      separator,
      group,
      groupLabel
    },
    states: {
      open: rootOpen
    },
    builders: {
      createCheckboxItem,
      createSubmenu,
      createMenuRadioGroup
    },
    options: rootOptions
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/link-preview/create.js
var { name: name6 } = createElHelpers("hover-card");
var defaults11 = {
  defaultOpen: false,
  openDelay: 700,
  closeDelay: 300,
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  closeOnOutsideClick: true,
  forceVisible: false,
  portal: "body",
  closeOnEscape: true
};
function createLinkPreview(props = {}) {
  const withDefaults = { ...defaults11, ...props };
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const hasSelection = writable(false);
  const isPointerDownOnContent = writable(false);
  const containSelection = writable(false);
  const activeTrigger = writable(null);
  const options = toWritableStores(withDefaults);
  const { openDelay, closeDelay, positioning, arrowSize, closeOnOutsideClick, forceVisible, portal, closeOnEscape } = options;
  const ids = {
    content: generateId(),
    trigger: generateId()
  };
  let timeout = null;
  let originalBodyUserSelect;
  const handleOpen = derived(openDelay, ($openDelay) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      timeout = window.setTimeout(() => {
        open.set(true);
      }, $openDelay);
    };
  });
  const handleClose = derived([closeDelay, isPointerDownOnContent, hasSelection], ([$closeDelay, $isPointerDownOnContent, $hasSelection]) => {
    return () => {
      if (timeout) {
        window.clearTimeout(timeout);
        timeout = null;
      }
      if (!$isPointerDownOnContent && !$hasSelection) {
        timeout = window.setTimeout(() => {
          open.set(false);
        }, $closeDelay);
      }
    };
  });
  const trigger = builder(name6("trigger"), {
    stores: [open],
    returned: ([$open]) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "data-state": $open ? "open" : "closed",
        "aria-controls": ids.content,
        id: ids.trigger
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleClose)();
      }), addMeltEventListener(node, "focus", (e) => {
        if (!isElement(e.currentTarget) || !isFocusVisible(e.currentTarget))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "blur", () => get_store_value(handleClose)()));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const content = builder(name6("content"), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          "pointer-events": $isVisible ? void 0 : "none",
          opacity: $isVisible ? 1 : 0,
          userSelect: "text",
          WebkitUserSelect: "text"
        }),
        id: ids.content,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsub = noop;
      const unsubTimers = () => {
        if (timeout) {
          window.clearTimeout(timeout);
        }
      };
      let unsubPopper = noop;
      const unsubDerived = effect([isVisible, activeTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $activeTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        const popper = usePopper(node, {
          anchorElement: $activeTrigger,
          open,
          options: {
            floating: $positioning,
            clickOutside: $closeOnOutsideClick ? void 0 : null,
            portal: getPortalDestination(node, $portal),
            focusTrap: null,
            escapeKeydown: $closeOnEscape ? void 0 : null
          }
        });
        if (popper && popper.destroy) {
          unsubPopper = popper.destroy;
        }
      });
      unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", (e) => {
        const currentTarget = e.currentTarget;
        const target = e.target;
        if (!isHTMLElement(currentTarget) || !isHTMLElement(target))
          return;
        if (currentTarget.contains(target)) {
          containSelection.set(true);
        }
        hasSelection.set(false);
        isPointerDownOnContent.set(true);
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleOpen)();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        get_store_value(handleClose)();
      }), addMeltEventListener(node, "focusout", (e) => {
        e.preventDefault();
      }));
      return {
        destroy() {
          unsub();
          unsubPopper();
          unsubTimers();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = builder(name6("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  effect([containSelection], ([$containSelection]) => {
    if (!isBrowser || !$containSelection)
      return;
    const body = document.body;
    const contentElement = document.getElementById(ids.content);
    if (!contentElement)
      return;
    originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
    const originalContentUserSelect = contentElement.style.userSelect || contentElement.style.webkitUserSelect;
    body.style.userSelect = "none";
    body.style.webkitUserSelect = "none";
    contentElement.style.userSelect = "text";
    contentElement.style.webkitUserSelect = "text";
    return () => {
      body.style.userSelect = originalBodyUserSelect;
      body.style.webkitUserSelect = originalBodyUserSelect;
      contentElement.style.userSelect = originalContentUserSelect;
      contentElement.style.webkitUserSelect = originalContentUserSelect;
    };
  });
  onMount(() => {
    const triggerEl = document.getElementById(ids.trigger);
    if (!triggerEl)
      return;
    activeTrigger.set(triggerEl);
  });
  effect([open], ([$open]) => {
    if (!isBrowser || !$open)
      return;
    const handlePointerUp = () => {
      containSelection.set(false);
      isPointerDownOnContent.set(false);
      sleep(1).then(() => {
        var _a;
        const isSelection = ((_a = document.getSelection()) == null ? void 0 : _a.toString()) !== "";
        if (isSelection) {
          hasSelection.set(true);
        }
      });
    };
    document.addEventListener("pointerup", handlePointerUp);
    const contentElement = document.getElementById(ids.content);
    if (!contentElement)
      return;
    const tabbables = getTabbableNodes(contentElement);
    tabbables.forEach((tabbable3) => tabbable3.setAttribute("tabindex", "-1"));
    return () => {
      document.removeEventListener("pointerup", handlePointerUp);
      hasSelection.set(false);
      isPointerDownOnContent.set(false);
    };
  });
  return {
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/menubar/create.js
var MENUBAR_NAV_KEYS = [kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.HOME, kbd.END];
var { name: name7 } = createElHelpers("menubar");
var defaults12 = {
  loop: true,
  closeOnEscape: true
};
function createMenubar(props) {
  const withDefaults = { ...defaults12, ...props };
  const options = toWritableStores(withDefaults);
  const { loop, closeOnEscape } = options;
  const activeMenu = writable("");
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  const lastFocusedMenuTrigger = writable(null);
  const closeTimer = writable(0);
  let scrollRemoved = false;
  const rootIds = {
    menubar: generateId()
  };
  const menubar = builder(name7(), {
    returned() {
      return {
        role: "menubar",
        "data-melt-menubar": "",
        "data-orientation": "horizontal",
        id: rootIds.menubar
      };
    },
    action: (node) => {
      const menuTriggers = Array.from(node.querySelectorAll("[data-melt-menubar-trigger]"));
      if (!isHTMLElement(menuTriggers[0]))
        return {};
      menuTriggers[0].tabIndex = 0;
      return {
        destroy: noop
      };
    }
  });
  const menuDefaults = {
    positioning: {
      placement: "bottom-start"
    },
    preventScroll: true,
    arrowSize: 8,
    dir: "ltr",
    loop: false,
    closeOnEscape: true,
    closeOnOutsideClick: true,
    portal: void 0,
    forceVisible: false,
    defaultOpen: false,
    typeahead: true
  };
  const createMenu = (props2) => {
    const withDefaults2 = { ...menuDefaults, ...props2 };
    const rootOpen = writable(false);
    const rootActiveTrigger = writable(null);
    const options2 = toWritableStores(withDefaults2);
    const { positioning, portal, forceVisible } = options2;
    const m = createMenuBuilder({
      rootOptions: options2,
      rootOpen,
      rootActiveTrigger,
      disableTriggerRefocus: true,
      disableFocusFirstItem: true,
      nextFocusable,
      prevFocusable,
      selector: "menubar-menu",
      removeScroll: false
    });
    const isVisible = derivedVisible({
      open: rootOpen,
      forceVisible,
      activeTrigger: rootActiveTrigger
    });
    const menu = builder(name7("menu"), {
      stores: [isVisible, portal],
      returned: ([$isVisible, $portal]) => {
        return {
          role: "menu",
          hidden: $isVisible ? void 0 : true,
          style: styleToString({
            display: $isVisible ? void 0 : "none"
          }),
          id: m.rootIds.menu,
          "aria-labelledby": m.rootIds.trigger,
          "data-state": $isVisible ? "open" : "closed",
          "data-melt-scope": rootIds.menubar,
          "data-portal": $portal ? "" : void 0,
          tabindex: -1
        };
      },
      action: (node) => {
        let unsubPopper = noop;
        const unsubDerived = effect([rootOpen, rootActiveTrigger, positioning, portal], ([$rootOpen, $rootActiveTrigger, $positioning, $portal]) => {
          unsubPopper();
          if (!($rootOpen && $rootActiveTrigger))
            return;
          tick().then(() => {
            const popper = usePopper(node, {
              anchorElement: $rootActiveTrigger,
              open: rootOpen,
              options: {
                floating: $positioning,
                portal: getPortalDestination(node, $portal),
                clickOutside: {
                  ignore: (e) => {
                    const target = e.target;
                    const menubarEl = document.getElementById(rootIds.menubar);
                    if (!menubarEl || !isElement(target))
                      return false;
                    return menubarEl.contains(target);
                  },
                  handler: () => {
                    activeMenu.set("");
                  }
                }
              }
            });
            if (popper && popper.destroy) {
              unsubPopper = popper.destroy;
            }
          });
        });
        const unsubEvents = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
          const target = e.target;
          const menuEl = e.currentTarget;
          if (!isHTMLElement(menuEl) || !isHTMLElement(target))
            return;
          if (MENUBAR_NAV_KEYS.includes(e.key)) {
            handleCrossMenuNavigation(e);
          }
          const isKeyDownInside = target.closest('[role="menu"]') === menuEl;
          if (!isKeyDownInside)
            return;
          if (FIRST_LAST_KEYS.includes(e.key)) {
            handleMenuNavigation(e);
          }
          if (e.key === kbd.TAB) {
            e.preventDefault();
            rootActiveTrigger.set(null);
            rootOpen.set(false);
            handleTabNavigation(e, nextFocusable, prevFocusable);
          }
          const isCharacterKey = e.key.length === 1;
          const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
          if (!isModifierKey && isCharacterKey) {
            m.handleTypeaheadSearch(e.key, getMenuItems(menuEl));
          }
        }));
        return {
          destroy() {
            unsubDerived();
            unsubEvents();
            unsubPopper();
          }
        };
      }
    });
    const trigger = builder(name7("trigger"), {
      stores: [rootOpen],
      returned: ([$rootOpen]) => {
        return {
          "aria-controls": m.rootIds.menu,
          "aria-expanded": $rootOpen,
          "data-state": $rootOpen ? "open" : "closed",
          id: m.rootIds.trigger,
          "aria-haspopup": "menu",
          "data-orientation": "horizontal",
          role: "menuitem"
        };
      },
      action: (node) => {
        applyAttrsIfDisabled(node);
        const menubarEl = document.getElementById(rootIds.menubar);
        if (!menubarEl)
          return {};
        const menubarTriggers = Array.from(menubarEl.querySelectorAll("[data-melt-menubar-trigger]"));
        if (!menubarTriggers.length)
          return {};
        const unsubEffect = effect([lastFocusedMenuTrigger], ([$lastFocusedMenuTrigger]) => {
          if (!$lastFocusedMenuTrigger && menubarTriggers[0] === node) {
            node.tabIndex = 0;
          } else if ($lastFocusedMenuTrigger === node) {
            node.tabIndex = 0;
          } else {
            node.tabIndex = -1;
          }
        });
        if (menubarTriggers[0] === node) {
          node.tabIndex = 0;
        } else {
          node.tabIndex = -1;
        }
        const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
          const $rootOpen = get_store_value(rootOpen);
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          handleOpen(triggerEl);
          if (!$rootOpen)
            e.preventDefault();
        }), addMeltEventListener(node, "keydown", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          if (SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN) {
            e.preventDefault();
            handleOpen(triggerEl);
            const menuId = triggerEl.getAttribute("aria-controls");
            if (!menuId)
              return;
            const menu2 = document.getElementById(menuId);
            if (!menu2)
              return;
            const menuItems = getMenuItems(menu2);
            if (!menuItems.length)
              return;
            handleRovingFocus(menuItems[0]);
          }
        }), addMeltEventListener(node, "pointerenter", (e) => {
          const triggerEl = e.currentTarget;
          if (!isHTMLElement(triggerEl))
            return;
          const $activeMenu = get_store_value(activeMenu);
          const $rootOpen = get_store_value(rootOpen);
          if ($activeMenu && !$rootOpen) {
            rootOpen.set(true);
            activeMenu.set(m.rootIds.menu);
            rootActiveTrigger.set(triggerEl);
          }
        }));
        return {
          destroy() {
            unsub();
            unsubEffect();
          }
        };
      }
    });
    function handleOpen(triggerEl) {
      rootOpen.update((prev2) => {
        const isOpen = !prev2;
        if (isOpen) {
          nextFocusable.set(getNextFocusable(triggerEl));
          prevFocusable.set(getPreviousFocusable(triggerEl));
          rootActiveTrigger.set(triggerEl);
          activeMenu.set(m.rootIds.menu);
        } else {
          rootActiveTrigger.set(null);
        }
        return isOpen;
      });
    }
    effect([activeMenu], ([$activeMenu]) => {
      if (!isBrowser)
        return;
      if ($activeMenu === m.rootIds.menu) {
        if (get_store_value(rootOpen))
          return;
        const triggerEl = document.getElementById(m.rootIds.trigger);
        if (!triggerEl)
          return;
        rootActiveTrigger.set(triggerEl);
        addHighlight(triggerEl);
        rootOpen.set(true);
        return;
      }
      if ($activeMenu !== m.rootIds.menu) {
        if (!isBrowser)
          return;
        if (get_store_value(rootOpen)) {
          const triggerEl = document.getElementById(m.rootIds.trigger);
          if (!triggerEl)
            return;
          rootActiveTrigger.set(null);
          rootOpen.set(false);
          removeHighlight(triggerEl);
        }
        return;
      }
    });
    effect([rootOpen], ([$rootOpen]) => {
      if (!isBrowser)
        return;
      const triggerEl = document.getElementById(m.rootIds.trigger);
      if (!triggerEl)
        return;
      if (!$rootOpen && get_store_value(activeMenu) === m.rootIds.menu) {
        rootActiveTrigger.set(null);
        activeMenu.set("");
        removeHighlight(triggerEl);
        return;
      }
      if ($rootOpen) {
        lastFocusedMenuTrigger.set(triggerEl);
        addHighlight(triggerEl);
      }
    });
    onMount(() => {
      if (!isBrowser)
        return;
      const triggerEl = document.getElementById(m.rootIds.trigger);
      if (isHTMLElement(triggerEl) && get_store_value(rootOpen)) {
        rootActiveTrigger.set(triggerEl);
      }
    });
    return {
      elements: {
        menu,
        trigger,
        item: m.item,
        arrow: m.arrow,
        separator: m.separator,
        group: m.group,
        groupLabel: m.groupLabel
      },
      builders: {
        createCheckboxItem: m.createCheckboxItem,
        createSubmenu: m.createSubmenu,
        createMenuRadioGroup: m.createMenuRadioGroup
      },
      states: {
        open: rootOpen
      },
      options: options2
    };
  };
  function handleCrossMenuNavigation(e) {
    if (!isBrowser)
      return;
    e.preventDefault();
    const currentTarget = e.currentTarget;
    const target = e.target;
    if (!isHTMLElement(target) || !isHTMLElement(currentTarget))
      return;
    const targetIsSubTrigger = target.hasAttribute("data-melt-menubar-menu-subtrigger");
    const isKeyDownInsideSubMenu = target.closest('[role="menu"]') !== currentTarget;
    const prevMenuKey = kbd.ARROW_LEFT;
    const isPrevKey = e.key === prevMenuKey;
    const isNextKey = !isPrevKey;
    if (isNextKey && targetIsSubTrigger)
      return;
    if (isPrevKey && isKeyDownInsideSubMenu)
      return;
    const menubarEl = document.getElementById(rootIds.menubar);
    if (!isHTMLElement(menubarEl))
      return;
    const triggers = getMenuTriggers(menubarEl);
    const currTriggerId = currentTarget.getAttribute("aria-labelledby");
    const currIndex = triggers.findIndex((trigger) => trigger.id === currTriggerId);
    let nextIndex;
    switch (e.key) {
      case kbd.ARROW_RIGHT:
        nextIndex = currIndex < triggers.length - 1 ? currIndex + 1 : 0;
        break;
      case kbd.ARROW_LEFT:
        nextIndex = currIndex > 0 ? currIndex - 1 : triggers.length - 1;
        break;
      case kbd.HOME:
        nextIndex = 0;
        break;
      case kbd.END:
        nextIndex = triggers.length - 1;
        break;
      default:
        return;
    }
    const nextFocusedTrigger = triggers[nextIndex];
    const menuId = nextFocusedTrigger.getAttribute("aria-controls");
    menuId && activeMenu.set(menuId);
  }
  function getMenuTriggers(el) {
    const menuEl = el.closest('[role="menubar"]');
    if (!isHTMLElement(menuEl))
      return [];
    return Array.from(menuEl.querySelectorAll("[data-melt-menubar-trigger]")).filter((el2) => isHTMLElement(el2));
  }
  function handleMenubarNavigation(e) {
    e.preventDefault();
    const currentFocusedItem = document.activeElement;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget) || !isHTMLElement(currentFocusedItem))
      return;
    const menuTriggers = getMenuTriggers(currentTarget);
    if (!menuTriggers.length)
      return;
    const candidateNodes = menuTriggers.filter((item) => {
      if (item.hasAttribute("data-disabled")) {
        return false;
      }
      if (item.getAttribute("disabled") === "true") {
        return false;
      }
      return true;
    });
    const currentIndex = candidateNodes.indexOf(currentFocusedItem);
    let nextIndex;
    const $loop = get_store_value(loop);
    switch (e.key) {
      case kbd.ARROW_RIGHT:
        nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : $loop ? 0 : currentIndex;
        break;
      case kbd.ARROW_LEFT:
        nextIndex = currentIndex > 0 ? currentIndex - 1 : $loop ? candidateNodes.length - 1 : 0;
        break;
      case kbd.HOME:
        nextIndex = 0;
        break;
      case kbd.END:
        nextIndex = candidateNodes.length - 1;
        break;
      default:
        return;
    }
    handleRovingFocus(candidateNodes[nextIndex]);
  }
  onMount(() => {
    if (!isBrowser)
      return;
    const menubarEl = document.getElementById(rootIds.menubar);
    if (!menubarEl)
      return;
    const unsubEvents = executeCallbacks(addMeltEventListener(menubarEl, "keydown", (e) => {
      const target = e.target;
      const menuEl = e.currentTarget;
      if (!isHTMLElement(menuEl) || !isHTMLElement(target))
        return;
      const isTargetTrigger = target.hasAttribute("data-melt-menubar-trigger");
      if (!isTargetTrigger)
        return;
      if (MENUBAR_NAV_KEYS.includes(e.key)) {
        handleMenubarNavigation(e);
      }
    }), addEventListener(document, "keydown", (e) => {
      if (get_store_value(closeOnEscape) && e.key === kbd.ESCAPE) {
        window.clearTimeout(get_store_value(closeTimer));
        activeMenu.set("");
      }
    }));
    return () => {
      unsubEvents();
    };
  });
  const unsubs = [];
  effect([activeMenu], ([$activeMenu]) => {
    if (!isBrowser)
      return;
    if (!$activeMenu) {
      unsubs.forEach((unsub) => unsub());
      scrollRemoved = false;
    } else if (!scrollRemoved) {
      unsubs.push(removeScroll());
      scrollRemoved = true;
    }
  });
  onDestroy(() => {
    unsubs.forEach((unsub) => unsub());
  });
  return {
    elements: {
      menubar
    },
    builders: {
      createMenu
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pagination/helpers.js
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let p = 2; p <= totalPages - 1; p++) {
      pagesToShow.add(p);
    }
  } else if (page < firstItemWithSiblings) {
    for (let p = 2; p <= Math.min(firstItemWithSiblings, totalPages); p++) {
      pagesToShow.add(p);
    }
  } else if (page > lastItemWithSiblings) {
    for (let p = totalPages - 1; p >= Math.max(lastItemWithSiblings, 2); p--) {
      pagesToShow.add(p);
    }
  } else {
    for (let p = Math.max(page - siblingCount, 2); p <= Math.min(page + siblingCount, totalPages); p++) {
      pagesToShow.add(p);
    }
  }
  const addPage = (value) => {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  };
  const addEllipsis = () => {
    pageItems.push({ type: "ellipsis", key: `ellipsis-${pageItems.length}` });
  };
  let lastNumber = 0;
  for (const page2 of Array.from(pagesToShow).sort((a, b) => a - b)) {
    if (page2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(page2);
    lastNumber = page2;
  }
  return pageItems;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pagination/create.js
var defaults13 = {
  perPage: 1,
  siblingCount: 1,
  defaultPage: 1
};
var { name: name8, selector: selector4 } = createElHelpers("pagination");
function createPagination(props) {
  const withDefaults = { ...defaults13, ...props };
  const pageWritable = withDefaults.page ?? writable(withDefaults.defaultPage);
  const page = overridable(pageWritable, withDefaults == null ? void 0 : withDefaults.onPageChange);
  const options = toWritableStores(omit(withDefaults, "page", "onPageChange", "defaultPage"));
  const { perPage, siblingCount, count } = options;
  const totalPages = derived([count, perPage], ([$count, $perPage]) => {
    return Math.ceil($count / $perPage);
  });
  const range = derived([page, perPage, count], ([$page, $perPage, $count]) => {
    const start = ($page - 1) * $perPage;
    const end = Math.min(start + $perPage, $count);
    return { start, end };
  });
  const root = builder(name8(), {
    returned: () => ({
      "data-scope": "pagination"
    })
  });
  const pages = derived([page, totalPages, siblingCount], ([$page, $totalPages, $siblingCount]) => {
    return getPageItems({ page: $page, totalPages: $totalPages, siblingCount: $siblingCount });
  });
  const keydown = (e) => {
    const thisEl = e.target;
    if (!isHTMLElement(thisEl))
      return;
    const rootEl = thisEl.closest('[data-scope="pagination"]');
    if (!isHTMLElement(rootEl))
      return;
    const triggers = Array.from(rootEl.querySelectorAll(selector4("page"))).filter((el) => isHTMLElement(el));
    const prevButton2 = rootEl.querySelector(selector4("prev"));
    const nextButton2 = rootEl.querySelector(selector4("next"));
    if (isHTMLElement(prevButton2)) {
      triggers.unshift(prevButton2);
    }
    if (isHTMLElement(nextButton2)) {
      triggers.push(nextButton2);
    }
    const index = triggers.indexOf(thisEl);
    if (e.key === kbd.ARROW_LEFT && index !== 0) {
      e.preventDefault();
      triggers[index - 1].focus();
    } else if (e.key === kbd.ARROW_RIGHT && index !== triggers.length - 1) {
      e.preventDefault();
      triggers[index + 1].focus();
    } else if (e.key === kbd.HOME) {
      e.preventDefault();
      triggers[0].focus();
    } else if (e.key === kbd.END) {
      e.preventDefault();
      triggers[triggers.length - 1].focus();
    }
  };
  const pageTrigger = builder(name8("page"), {
    stores: page,
    returned: ($page) => {
      return (pageItem) => {
        return {
          "aria-label": `Page ${pageItem.value}`,
          "data-value": pageItem.value,
          "data-selected": pageItem.value === $page ? "" : void 0
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const value = node.dataset.value;
        if (!value || Number.isNaN(+value))
          return;
        page.set(Number(value));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  const prevButton = builder(name8("prev"), {
    stores: page,
    returned: ($page) => {
      return {
        "aria-label": "Previous",
        disabled: $page <= 1
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        page.update((p) => Math.max(p - 1, 1));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  const nextButton = builder(name8("next"), {
    stores: [page, totalPages],
    returned: ([$page, $totalPages]) => {
      return {
        "aria-label": "Next",
        disabled: $page >= $totalPages
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        const $totalPages = get_store_value(totalPages);
        page.update((p) => Math.min(p + 1, $totalPages));
      }), addMeltEventListener(node, "keydown", keydown));
      return {
        destroy: unsub
      };
    }
  });
  return {
    elements: {
      root,
      pageTrigger,
      prevButton,
      nextButton
    },
    states: {
      range: readonly(range),
      page,
      pages: readonly(pages),
      totalPages: readonly(totalPages)
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/pin-input/create.js
var { name: name9, selector: selector5 } = createElHelpers("pin-input");
var getInputs = (node) => {
  const rootEl = node.closest(selector5());
  if (!isHTMLElement(rootEl)) {
    return { inputs: null, el: node, elIndex: -1 };
  }
  const inputs = Array.from(rootEl.querySelectorAll(selector5("input"))).filter((input) => isHTMLInputElement(input));
  return {
    elIndex: inputs.indexOf(node),
    inputs
  };
};
var defaults14 = {
  placeholder: "",
  disabled: false,
  type: "text",
  name: void 0,
  defaultValue: []
};
function createPinInput(props) {
  const withDefaults = { ...defaults14, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { placeholder, disabled, type, name: nameStore } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const valueStr = derived(value, (v) => v.join(""));
  const ids = {
    root: generateId()
  };
  const root = builder(name9(), {
    stores: value,
    returned: ($value) => {
      return {
        id: ids.root,
        "data-complete": $value.length && $value.every((v) => v.length > 0) ? "" : void 0
      };
    }
  });
  let index = 0;
  const getTotalItems = () => {
    if (!isBrowser)
      return Infinity;
    const rootEl = document.getElementById(ids.root);
    if (!rootEl)
      return Infinity;
    const inputs = Array.from(rootEl.querySelectorAll(selector5("input")));
    return inputs.length;
  };
  const input = builder(name9("input"), {
    stores: [value, placeholder, disabled, type],
    returned: ([$value, $placeholder, $disabled, $type]) => {
      return () => {
        const totalItems = getTotalItems();
        const currIndex = index % totalItems;
        index = (index + 1) % totalItems;
        const currValue = $value[currIndex] ?? "";
        return {
          "data-complete": $value.length && $value.every((v) => v.length > 0) ? "" : void 0,
          placeholder: $placeholder,
          disabled: $disabled,
          type: $type,
          value: currValue
        };
      };
    },
    action: (node) => {
      const { elIndex } = getInputs(node);
      value.update((v) => {
        v[elIndex] = node.value;
        return v;
      });
      const unsub = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        if (e.key === "Backspace") {
          e.preventDefault();
          if (node.value) {
            node.value = "";
            tick().then(() => node.placeholder = "");
            value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
          } else {
            const prevEl = prev(inputs, elIndex2, false);
            prevEl.focus();
            prevEl.value = "";
            tick().then(() => prevEl.placeholder = "");
            value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
          }
        }
        if (e.key === "Delete") {
          e.preventDefault();
          node.value = "";
          tick().then(() => node.placeholder = "");
        }
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          const prevEl = prev(inputs, elIndex2, false);
          prevEl.focus();
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          const nextEl = next(inputs, elIndex2, false);
          nextEl.focus();
        }
        if (e.key === "Home") {
          e.preventDefault();
          inputs[0].focus();
        }
        if (e.key === "End") {
          e.preventDefault();
          last(inputs).focus();
        }
      }), addMeltEventListener(node, "input", (e) => {
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        const getInputted = (el) => {
          const $value = get_store_value(value);
          const prevElValue = $value[elIndex2];
          const selectionStart = el.selectionStart ?? 1;
          if (!prevElValue)
            return el.value;
          return selectionStart > 1 ? el.value.slice(1) : el.value.slice(0, Math.max(el.value.length - 2, 1));
        };
        const inputted = getInputted(node);
        const inputEvent = e;
        if (inputEvent.inputType === "insertFromPaste") {
          return;
        }
        node.value = inputted.slice(-1);
        if (node.value.length !== 0) {
          const nextEl = next(inputs, elIndex2, false);
          nextEl.focus();
        }
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "paste", (e) => {
        var _a;
        e.preventDefault();
        const { inputs, elIndex: elIndex2 } = getInputs(node);
        if (!inputs)
          return;
        const inputEvent = e;
        const clipboardData = inputEvent.clipboardData;
        if (!clipboardData)
          return;
        const pasted = clipboardData.getData("text");
        const initialIndex = pasted.length >= inputs.length ? 0 : elIndex2;
        const lastIndex = Math.min(initialIndex + pasted.length, inputs.length);
        for (let i = initialIndex; i < lastIndex; i++) {
          const input2 = inputs[i];
          input2.value = pasted[i - initialIndex];
          input2.focus();
        }
        (_a = inputs[lastIndex]) == null ? void 0 : _a.focus();
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "change", () => {
        const { inputs } = getInputs(node);
        if (!inputs)
          return;
        value.set(inputs.map((input2) => input2.value.slice(-1) ?? void 0));
      }), addMeltEventListener(node, "focus", () => {
        node.setSelectionRange(1, 1);
        node.placeholder = "";
        tick().then(() => {
          node.placeholder = "";
        });
      }), addMeltEventListener(node, "blur", () => {
        node.placeholder = get_store_value(placeholder);
      }));
      return {
        destroy() {
          unsub();
        }
      };
    }
  });
  const hiddenInput = builder(name9("hidden-input"), {
    stores: [value, nameStore],
    returned: ([$value, $nameStore]) => ({
      value: $value,
      name: $nameStore,
      hidden: true,
      style: styleToString({
        display: "none"
      })
    })
  });
  const clear = () => {
    value.update((v) => {
      v.forEach((_, i) => v[i] = "");
      return v;
    });
  };
  return {
    elements: {
      root,
      input,
      hiddenInput
    },
    states: {
      value,
      valueStr: readonly(valueStr)
    },
    helpers: {
      clear
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/popover/create.js
var defaults15 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  disableFocusTrap: false,
  closeOnEscape: true,
  preventScroll: false,
  onOpenChange: void 0,
  closeOnOutsideClick: true,
  portal: void 0,
  forceVisible: false
};
var { name: name10 } = createElHelpers("popover");
function createPopover(args) {
  const withDefaults = { ...defaults15, ...args };
  const options = toWritableStores(omit(withDefaults, "open"));
  const { positioning, arrowSize, disableFocusTrap, preventScroll, closeOnEscape, closeOnOutsideClick, portal, forceVisible } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const activeTrigger = writable(null);
  const ids = {
    content: generateId(),
    trigger: generateId()
  };
  onMount(() => {
    activeTrigger.set(document.getElementById(ids.trigger));
  });
  function handleClose() {
    open.set(false);
    const triggerEl = document.getElementById(ids.trigger);
    if (triggerEl) {
      tick().then(() => {
        triggerEl.focus();
      });
    }
  }
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = builder(name10("content"), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        hidden: $isVisible && isBrowser ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: ids.content,
        "data-state": $isVisible ? "open" : "closed",
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      const unsubDerived = effect([
        isVisible,
        activeTrigger,
        positioning,
        disableFocusTrap,
        closeOnEscape,
        closeOnOutsideClick,
        portal
      ], ([$isVisible, $activeTrigger, $positioning, $disableFocusTrap, $closeOnEscape, $closeOnOutsideClick, $portal]) => {
        unsubPopper();
        if (!$isVisible || !$activeTrigger)
          return;
        const popper = usePopper(node, {
          anchorElement: $activeTrigger,
          open,
          options: {
            floating: $positioning,
            focusTrap: $disableFocusTrap ? null : void 0,
            clickOutside: $closeOnOutsideClick ? void 0 : null,
            escapeKeydown: $closeOnEscape ? {
              handler: () => {
                handleClose();
              }
            } : null,
            portal: getPortalDestination(node, $portal)
          }
        });
        if (popper && popper.destroy) {
          unsubPopper = popper.destroy;
        }
      });
      return {
        destroy() {
          unsubDerived();
          unsubPopper();
        }
      };
    }
  });
  function toggleOpen(triggerEl) {
    open.update((prev2) => {
      return !prev2;
    });
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
  }
  const trigger = builder(name10("trigger"), {
    stores: open,
    returned: ($open) => {
      return {
        role: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": $open,
        "data-state": $open ? "open" : "closed",
        "aria-controls": ids.content,
        id: ids.trigger
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        toggleOpen(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleOpen(node);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const arrow2 = builder(name10("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const close = builder(name10("close"), {
    returned: () => ({
      type: "button"
    }),
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleOpen();
      }));
      return {
        destroy: unsub
      };
    }
  });
  effect([open, activeTrigger, preventScroll], ([$open, $activeTrigger, $preventScroll]) => {
    if (!isBrowser)
      return;
    const unsubs = [];
    if ($open) {
      if (!$activeTrigger) {
        tick().then(() => {
          const triggerEl = document.getElementById(ids.trigger);
          if (!isHTMLElement(triggerEl))
            return;
          activeTrigger.set(triggerEl);
        });
      }
      if ($preventScroll) {
        unsubs.push(removeScroll());
      }
    }
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  return {
    elements: {
      trigger,
      content,
      arrow: arrow2,
      close
    },
    states: {
      open
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/progress/create.js
var defaults16 = {
  defaultValue: 0,
  max: 100
};
var { name: name11 } = createElHelpers("progress");
var createProgress = (props) => {
  const withDefaults = { ...defaults16, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { max: max2 } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root = builder(name11(), {
    stores: [value, max2],
    returned: ([$value, $max]) => {
      return {
        value: $value,
        max: $max,
        role: "meter",
        "aria-valuemin": 0,
        "aria-valuemax": $max,
        "aria-valuenow": $value,
        "data-value": $value,
        "data-state": $value === null ? "indeterminate" : $value === $max ? "complete" : "loading",
        "data-max": $max
      };
    }
  });
  return {
    elements: {
      root
    },
    states: {
      value
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/radio-group/create.js
var defaults17 = {
  orientation: "vertical",
  loop: true,
  disabled: false,
  required: false,
  defaultValue: void 0
};
var { name: name12, selector: selector6 } = createElHelpers("radio-group");
function createRadioGroup(props) {
  const withDefaults = { ...defaults17, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { disabled, required, loop, orientation } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const focusedHistory = {
    prev: null,
    curr: null
  };
  onMount(() => {
    return addEventListener(document, "focus", (e) => {
      const focusedItem = e.target;
      if (!isHTMLElement(focusedItem))
        return;
      focusedHistory.prev = focusedHistory.curr;
      focusedHistory.curr = focusedItem;
    });
  });
  let hasActiveTabIndex = false;
  effect(value, ($value) => {
    if ($value === void 0) {
      hasActiveTabIndex = false;
    } else {
      hasActiveTabIndex = true;
    }
  });
  const selectItem = (item2) => {
    const disabled2 = item2.dataset.disabled === "true";
    const itemValue = item2.dataset.value;
    if (disabled2 || itemValue === void 0)
      return;
    value.set(itemValue);
  };
  const root = builder(name12(), {
    stores: [required, orientation],
    returned: ([$required, $orientation]) => {
      return {
        role: "radiogroup",
        "aria-required": $required,
        "data-orientation": $orientation
      };
    }
  });
  const item = builder(name12("item"), {
    stores: [value, orientation, disabled],
    returned: ([$value, $orientation, $disabled]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const checked = $value === itemValue;
        const tabindex = !hasActiveTabIndex ? 0 : checked ? 0 : -1;
        hasActiveTabIndex = true;
        return {
          disabled: disabled2,
          "data-value": itemValue,
          "data-orientation": $orientation,
          "data-disabled": disabled2 ? true : void 0,
          "data-state": checked ? "checked" : "unchecked",
          "aria-checked": checked,
          type: "button",
          role: "radio",
          tabindex
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        selectItem(node);
      }), addMeltEventListener(node, "keydown", (e) => {
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const root2 = el.closest(selector6());
        if (!isHTMLElement(root2))
          return;
        const items = Array.from(root2.querySelectorAll(selector6("item"))).filter((el2) => isHTMLElement(el2));
        const currentIndex = items.indexOf(el);
        const dir = getElemDirection(root2);
        const { nextKey, prevKey } = getDirectionalKeys(dir, get_store_value(orientation));
        const $loop = get_store_value(loop);
        let itemToFocus = null;
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items.length && $loop) {
            itemToFocus = items[0];
          } else {
            itemToFocus = items[nextIndex];
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            itemToFocus = items[items.length - 1];
          } else {
            itemToFocus = items[prevIndex];
          }
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          itemToFocus = items[0];
        } else if (e.key === kbd.END) {
          e.preventDefault();
          itemToFocus = items[items.length - 1];
        }
        if (itemToFocus) {
          itemToFocus.focus();
          selectItem(itemToFocus);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const hiddenInput = builder(name12("hidden-input"), {
    stores: [disabled, value, required],
    returned: ([$disabled, $value, $required]) => {
      return {
        "aria-hidden": true,
        tabindex: -1,
        disabled: $disabled,
        value: $value,
        required: $required,
        style: styleToString({
          "pointer-events": "none",
          position: "absolute",
          opacity: 0,
          width: 0,
          height: 0
        })
      };
    },
    action: (_node) => {
      _node;
    }
  });
  const isChecked = derived(value, ($value) => {
    return (itemValue) => {
      return $value === itemValue;
    };
  });
  return {
    elements: {
      root,
      item,
      hiddenInput
    },
    states: {
      value
    },
    helpers: {
      isChecked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/select/create.js
var defaults18 = {
  arrowSize: 8,
  required: false,
  disabled: false,
  positioning: {
    placement: "bottom",
    sameWidth: true
  },
  preventScroll: true,
  loop: false,
  name: void 0,
  defaultOpen: false,
  forceVisible: false,
  portal: void 0,
  closeOnEscape: true,
  closeOnOutsideClick: true
};
var { name: name13 } = createElHelpers("select");
function createSelect(props) {
  const withDefaults = { ...defaults18, ...props };
  const options = toWritableStores({
    ...omit(withDefaults, "selected", "defaultSelected", "onSelectedChange", "onOpenChange", "open", "defaultOpen"),
    multiple: withDefaults.multiple ?? false
  });
  const { positioning, arrowSize, required, disabled, loop, preventScroll, name: nameStore, portal, forceVisible, closeOnEscape, closeOnOutsideClick, multiple } = options;
  const openWritable = withDefaults.open ?? writable(false);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
  const selected = overridable(selectedWritable, withDefaults == null ? void 0 : withDefaults.onSelectedChange);
  const activeTrigger = writable(null);
  const nextFocusable = writable(null);
  const prevFocusable = writable(null);
  let isUsingKeyboard = false;
  const ids = {
    menu: generateId(),
    trigger: generateId(),
    label: generateId()
  };
  const { typed, handleTypeaheadSearch } = createTypeaheadSearch();
  const isSelected = derived([selected], ([$selected]) => {
    return (value) => {
      if (Array.isArray($selected)) {
        return $selected.map((o) => o.value).includes(value);
      }
      return dequal($selected == null ? void 0 : $selected.value, value);
    };
  });
  function isMouse2(e) {
    return e.pointerType === "mouse";
  }
  function getSelectedOption(menuElement) {
    const selectedOption = menuElement.querySelector("[data-selected]");
    return isHTMLElement(selectedOption) ? selectedOption : null;
  }
  function onOptionPointerMove(e) {
    if (!isMouse2(e))
      return;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentTarget))
      return;
    handleRovingFocus(currentTarget);
  }
  function onOptionLeave() {
    const menuElement = document.getElementById(ids.menu);
    if (!isHTMLElement(menuElement))
      return;
    handleRovingFocus(menuElement);
  }
  function handleMenuNavigation2(e) {
    e.preventDefault();
    const currentFocusedItem = document.activeElement;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))
      return;
    const items = getOptions(currentTarget);
    if (!items.length)
      return;
    const candidateNodes = items.filter((opt) => !isElementDisabled(opt));
    const currentIndex = candidateNodes.indexOf(currentFocusedItem);
    let nextItem;
    const $loop = get_store_value(loop);
    switch (e.key) {
      case kbd.ARROW_DOWN:
        nextItem = next(candidateNodes, currentIndex, $loop);
        break;
      case kbd.PAGE_DOWN:
        nextItem = forward(candidateNodes, currentIndex, 10, $loop);
        break;
      case kbd.ARROW_UP:
        nextItem = prev(candidateNodes, currentIndex, $loop);
        break;
      case kbd.PAGE_UP:
        nextItem = back(candidateNodes, currentIndex, 10, $loop);
        break;
      case kbd.HOME:
        nextItem = candidateNodes[0];
        break;
      case kbd.END:
        nextItem = last(candidateNodes);
        break;
      default:
        return;
    }
    handleRovingFocus(nextItem);
  }
  function handleTabNavigation2(e) {
    if (e.shiftKey) {
      const $prevFocusable = get_store_value(prevFocusable);
      if ($prevFocusable) {
        e.preventDefault();
        $prevFocusable.focus();
        prevFocusable.set(null);
      }
    } else {
      const $nextFocusable = get_store_value(nextFocusable);
      if ($nextFocusable) {
        e.preventDefault();
        $nextFocusable.focus();
        nextFocusable.set(null);
      }
    }
  }
  const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
  const selectedLabel = derived(selected, ($selected) => {
    if (Array.isArray($selected)) {
      return $selected.map((o) => o.label).join(", ");
    }
    return ($selected == null ? void 0 : $selected.label) ?? "";
  });
  const menu = builder(name13("menu"), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: ids.menu,
        "aria-labelledby": ids.trigger,
        role: "listbox",
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubPopper = noop;
      let unsubScroll = noop;
      const unsubDerived = effect([isVisible, preventScroll, positioning, portal, closeOnEscape, closeOnOutsideClick], ([$isVisible, $preventScroll, $positioning, $portal, $closeOnEscape, $closeOnOutsideClick]) => {
        unsubPopper();
        unsubScroll();
        const $activeTrigger = get_store_value(activeTrigger);
        if (!($isVisible && $activeTrigger))
          return;
        if ($preventScroll) {
          unsubScroll = removeScroll();
        }
        const ignoreHandler = createClickOutsideIgnore(ids.trigger);
        tick().then(() => {
          const popper = usePopper(node, {
            anchorElement: $activeTrigger,
            open,
            options: {
              floating: $positioning,
              clickOutside: $closeOnOutsideClick ? {
                ignore: ignoreHandler
              } : null,
              escapeKeydown: $closeOnEscape ? {
                handler: () => {
                  open.set(false);
                }
              } : null,
              portal: getPortalDestination(node, $portal)
            }
          });
          if (popper && popper.destroy) {
            unsubPopper = popper.destroy;
          }
        });
      });
      const unsubEventListeners = executeCallbacks(addMeltEventListener(node, "keydown", (e) => {
        const menuEl = e.currentTarget;
        const target = e.target;
        if (!isHTMLElement(menuEl) || !isHTMLElement(target))
          return;
        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
        const isCharacterKey = e.key.length === 1;
        if (e.key === kbd.TAB) {
          e.preventDefault();
          open.set(false);
          handleTabNavigation2(e);
        }
        if (FIRST_LAST_KEYS.includes(e.key)) {
          e.preventDefault();
          if (menuEl === target) {
            const selectedOption = getSelectedOption(menuEl);
            if (selectedOption) {
              handleRovingFocus(selectedOption);
              return;
            }
          }
          handleMenuNavigation2(e);
        }
        if (!isModifierKey && isCharacterKey) {
          handleTypeaheadSearch(e.key, getOptions(node));
        }
      }));
      return {
        destroy() {
          unsubDerived();
          unsubPopper();
          unsubScroll();
          unsubEventListeners();
        }
      };
    }
  });
  const trigger = builder(name13("trigger"), {
    stores: [open, disabled, required],
    returned: ([$open, $disabled, $required]) => {
      return {
        role: "combobox",
        type: "button",
        "aria-autocomplete": "none",
        "aria-haspopup": "listbox",
        "aria-controls": ids.menu,
        "aria-expanded": $open,
        "aria-required": $required,
        "data-state": $open ? "open" : "closed",
        "data-disabled": $disabled ? true : void 0,
        "aria-labelledby": ids.label,
        "data-melt-id": ids.trigger,
        disabled: $disabled,
        id: ids.trigger,
        tabindex: 0
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        if (get_store_value(disabled)) {
          e.preventDefault();
          return;
        }
        const $open = get_store_value(open);
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        open.update((prev2) => {
          const isOpen = !prev2;
          if (isOpen) {
            nextFocusable.set(getNextFocusable(triggerEl));
            prevFocusable.set(getPreviousFocusable(triggerEl));
            activeTrigger.set(triggerEl);
          }
          return isOpen;
        });
        if (!$open)
          e.preventDefault();
      }), addMeltEventListener(node, "keydown", (e) => {
        const triggerEl = e.currentTarget;
        if (!isHTMLElement(triggerEl))
          return;
        if (SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
          if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
            e.preventDefault();
          }
          open.update((prev2) => {
            const isOpen = !prev2;
            if (isOpen) {
              e.preventDefault();
              nextFocusable.set(getNextFocusable(triggerEl));
              prevFocusable.set(getPreviousFocusable(triggerEl));
              activeTrigger.set(triggerEl);
            }
            return isOpen;
          });
          const menu2 = document.getElementById(ids.menu);
          if (!menu2)
            return;
          const selectedOption = menu2.querySelector("[data-selected]");
          if (isHTMLElement(selectedOption)) {
            handleRovingFocus(selectedOption);
            return;
          }
          const options2 = getOptions(menu2);
          if (!options2.length)
            return;
          handleRovingFocus(options2[0]);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const { elements: { root: labelBuilder } } = createLabel();
  const { action: labelAction } = get_store_value(labelBuilder);
  const label = builder(name13("label"), {
    returned: () => {
      return {
        id: ids.label,
        for: ids.trigger
      };
    },
    action: (node) => {
      const destroy = executeCallbacks(labelAction(node).destroy ?? noop, addMeltEventListener(node, "click", (e) => {
        e.preventDefault();
        const triggerEl = document.getElementById(ids.trigger);
        if (!isHTMLElement(triggerEl))
          return;
        triggerEl.focus();
      }));
      return {
        destroy
      };
    }
  });
  const { elements: { root: separator } } = createSeparator({
    decorative: true
  });
  const group = builder(name13("group"), {
    returned: () => {
      return (groupId) => ({
        role: "group",
        "aria-labelledby": groupId
      });
    }
  });
  const groupLabel = builder(name13("group-label"), {
    returned: () => {
      return (groupId) => ({
        id: groupId
      });
    }
  });
  const arrow2 = builder(name13("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  const getOptionProps = (el) => {
    const value = el.getAttribute("data-value");
    const label2 = el.getAttribute("data-label");
    const disabled2 = el.hasAttribute("data-disabled");
    return {
      value: value ? JSON.parse(value) : value,
      label: label2 ?? el.textContent ?? void 0,
      disabled: disabled2 ? true : false
    };
  };
  const setOption = (newOption) => {
    selected.update(($option) => {
      const $multiple = get_store_value(multiple);
      if ($multiple) {
        const optionArr = Array.isArray($option) ? $option : [];
        return toggle(newOption, optionArr);
      }
      return newOption;
    });
  };
  const option = builder(name13("option"), {
    stores: selected,
    returned: ($selected) => {
      return (props2) => {
        const isSelected2 = Array.isArray($selected) ? $selected.map((o) => o.value).includes(props2.value) : dequal($selected == null ? void 0 : $selected.value, props2 == null ? void 0 : props2.value);
        return {
          role: "option",
          "aria-selected": isSelected2,
          "data-selected": isSelected2 ? "" : void 0,
          "data-value": JSON.stringify(props2.value),
          "data-label": props2.label ?? void 0,
          "data-disabled": props2.disabled ? "" : void 0,
          tabindex: -1
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        const itemElement = e.currentTarget;
        if (!isHTMLElement(itemElement))
          return;
        const props2 = getOptionProps(node);
        if (props2.disabled) {
          e.preventDefault();
          return;
        }
        handleRovingFocus(itemElement);
        setOption(props2);
        const $multiple = get_store_value(multiple);
        if (!$multiple)
          open.set(false);
      }), addMeltEventListener(node, "keydown", (e) => {
        const $typed = get_store_value(typed);
        const isTypingAhead = $typed.length > 0;
        if (isTypingAhead && e.key === kbd.SPACE) {
          e.preventDefault();
          return;
        }
        if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
          e.preventDefault();
          const props2 = getOptionProps(node);
          node.setAttribute("data-selected", "");
          setOption(props2);
          const $multiple = get_store_value(multiple);
          if (!$multiple)
            open.set(false);
        }
      }), addMeltEventListener(node, "pointermove", (e) => {
        const props2 = getOptionProps(node);
        if (props2.disabled) {
          e.preventDefault();
          return;
        }
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        if (props2.disabled) {
          const menuElement = document.getElementById(ids.menu);
          if (!menuElement)
            return;
          handleRovingFocus(menuElement);
        }
        onOptionPointerMove(e);
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (!isMouse2(e))
          return;
        onOptionLeave();
      }), addMeltEventListener(node, "focusin", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        addHighlight(itemEl);
      }), addMeltEventListener(node, "focusout", (e) => {
        const itemEl = e.currentTarget;
        if (!isHTMLElement(itemEl))
          return;
        removeHighlight(itemEl);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder(name13("input"), {
    stores: [selected, required, disabled, nameStore],
    returned: ([$value, $required, $disabled, $nameStore]) => {
      return {
        type: "hidden",
        name: $nameStore,
        value: $value,
        "aria-hidden": true,
        hidden: true,
        tabIndex: -1,
        required: $required,
        disabled: $disabled,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  onMount(() => {
    const triggerEl = getElementByMeltId(ids.trigger);
    if (triggerEl) {
      activeTrigger.set(triggerEl);
    }
  });
  let hasOpened = false;
  effect(open, ($open) => {
    if ($open) {
      hasOpened = true;
    }
  });
  effect([open, activeTrigger], function handleFocus([$open, $activeTrigger]) {
    const unsubs = [];
    if (!isBrowser)
      return;
    if ($open && get_store_value(preventScroll)) {
      unsubs.push(removeScroll());
    }
    sleep(1).then(() => {
      const menuEl = document.getElementById(ids.menu);
      if (menuEl && $open && isUsingKeyboard) {
        const selectedOption = getSelectedOption(menuEl);
        if (!selectedOption) {
          const firstOption = getFirstOption(menuEl);
          if (!firstOption)
            return;
          handleRovingFocus(firstOption);
        } else {
          handleRovingFocus(selectedOption);
        }
      } else if (menuEl && $open) {
        handleRovingFocus(menuEl);
      } else if ($activeTrigger && hasOpened) {
        handleRovingFocus($activeTrigger);
      }
    });
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  });
  effect([open, activeTrigger], ([$open, $activeTrigger]) => {
    if (!isBrowser)
      return;
    const handlePointer = () => isUsingKeyboard = false;
    const handleKeyDown = (e) => {
      isUsingKeyboard = true;
      if (e.key === kbd.ESCAPE && $open) {
        open.set(false);
        if (!$activeTrigger)
          return;
        handleRovingFocus($activeTrigger);
      }
    };
    return executeCallbacks(addEventListener(document, "keydown", handleKeyDown, { capture: true }), addEventListener(document, "pointerdown", handlePointer, { capture: true, once: true }), addEventListener(document, "pointermove", handlePointer, { capture: true, once: true }));
  });
  return {
    elements: {
      menu,
      trigger,
      option,
      input,
      group,
      groupLabel,
      arrow: arrow2,
      separator,
      label
    },
    states: {
      open,
      selected,
      selectedLabel
    },
    helpers: {
      isSelected
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/separator/create.js
var defaults19 = {
  orientation: "horizontal",
  decorative: false
};
var createSeparator = (props) => {
  const withDefaults = { ...defaults19, ...props };
  const options = toWritableStores(withDefaults);
  const { orientation, decorative } = options;
  const root = builder("separator", {
    stores: [orientation, decorative],
    returned: ([$orientation, $decorative]) => {
      const ariaOrientation = $orientation === "vertical" ? $orientation : void 0;
      return {
        role: $decorative ? "none" : "separator",
        "aria-orientation": ariaOrientation,
        "aria-hidden": $decorative,
        "data-orientation": $orientation
      };
    }
  });
  return {
    elements: {
      root
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/slider/helpers.js
function multiplier(x) {
  const parts = x.toString().split(".");
  if (parts.length < 2) {
    return 1;
  }
  return Math.pow(10, parts[1].length);
}
function correctionFactor(...args) {
  return Math.max(...args.map(multiplier));
}
function add(...args) {
  const factor = correctionFactor(...args);
  let sum = 0;
  for (const number of args) {
    sum += number * factor;
  }
  return sum / factor;
}
function sub(...[first, ...args]) {
  const factor = correctionFactor(...args);
  let sum = first * factor;
  for (const number of args) {
    sum -= number * factor;
  }
  return sum / factor;
}
function mul(...args) {
  let total = 1;
  for (const number of args) {
    const factor = correctionFactor(total, number);
    total = total * factor * (number * factor) / (factor * factor);
  }
  return total;
}
function div(...[first, ...args]) {
  let total = first;
  for (const number of args) {
    const factor = correctionFactor(total, number);
    total = total * factor / (number * factor);
  }
  return total;
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/slider/create.js
var defaults20 = {
  defaultValue: [],
  min: 0,
  max: 100,
  step: 1,
  orientation: "horizontal",
  disabled: false
};
var { name: name14 } = createElHelpers("slider");
var createSlider = (props) => {
  const withDefaults = { ...defaults20, ...props };
  const options = toWritableStores(omit(withDefaults, "value", "onValueChange", "defaultValue"));
  const { min: min2, max: max2, step, orientation, disabled } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const isActive = writable(false);
  const currentThumbIndex = writable(0);
  const activeThumb = writable(null);
  const ids = {
    root: generateId()
  };
  const root = builder(name14(), {
    stores: [disabled, orientation],
    returned: ([$disabled, $orientation]) => {
      return {
        disabled: $disabled,
        "data-orientation": $orientation,
        style: $disabled ? void 0 : "touch-action: none;",
        "data-melt-id": ids.root
      };
    }
  });
  const position = derived([min2, max2], ([$min, $max]) => {
    return (val) => {
      const pos = mul(div(sub(val, $min), sub($max, $min)), 100);
      return pos;
    };
  });
  const range = builder(name14("range"), {
    stores: [value, orientation, position],
    returned: ([$value, $orientation, $position]) => {
      const minimum = $value.length > 1 ? $position(Math.min(...$value) ?? 0) : 0;
      const maximum = 100 - $position(Math.max(...$value) ?? 0);
      const orientationStyles = $orientation === "horizontal" ? { left: `${minimum}%`, right: `${maximum}%` } : { top: `${maximum}%`, bottom: `${minimum}%` };
      return {
        style: styleToString({
          position: "absolute",
          ...orientationStyles
        })
      };
    }
  });
  const updatePosition = (val, index) => {
    value.update((prev2) => {
      if (!prev2)
        return [val];
      const newValue = [...prev2];
      const direction = newValue[index] > val ? -1 : 1;
      function swap() {
        newValue[index] = newValue[index + direction];
        newValue[index + direction] = val;
        const thumbs = getAllThumbs();
        if (thumbs) {
          thumbs[index + direction].focus();
          activeThumb.set({ thumb: thumbs[index + direction], index: index + direction });
        }
      }
      if (direction === -1 && val < newValue[index - 1]) {
        swap();
        return newValue;
      } else if (direction === 1 && val > newValue[index + 1]) {
        swap();
        return newValue;
      }
      const $min = get_store_value(min2);
      const $max = get_store_value(max2);
      newValue[index] = Math.min(Math.max(val, $min), $max);
      return newValue;
    });
  };
  const getAllThumbs = () => {
    const root2 = getElementByMeltId(ids.root);
    if (!root2)
      return null;
    return Array.from(root2.querySelectorAll('[data-melt-part="thumb"]')).filter((thumb2) => isHTMLElement(thumb2));
  };
  const thumb = builder(name14("thumb"), {
    stores: [value, position, min2, max2, disabled, orientation],
    returned: ([$value, $position, $min, $max, $disabled, $orientation]) => {
      let index = -1;
      return () => {
        index++;
        const currentThumb = get_store_value(currentThumbIndex);
        if (currentThumb < $value.length) {
          currentThumbIndex.update((prev2) => prev2 + 1);
        }
        const thumbPosition = `${$position($value[index])}%`;
        return {
          role: "slider",
          "aria-valuemin": $min,
          "aria-valuemax": $max,
          "aria-valuenow": $value[index],
          "data-melt-part": "thumb",
          style: styleToString({
            position: "absolute",
            ...$orientation === "horizontal" ? { left: thumbPosition, translate: "-50% 0" } : { bottom: thumbPosition, translate: "0 50%" }
          }),
          tabindex: $disabled ? -1 : 0
        };
      };
    },
    action: (node) => {
      const unsub = addMeltEventListener(node, "keydown", (event) => {
        const $min = get_store_value(min2);
        const $max = get_store_value(max2);
        if (get_store_value(disabled))
          return;
        const target = event.currentTarget;
        if (!isHTMLElement(target))
          return;
        const thumbs = getAllThumbs();
        if (!(thumbs == null ? void 0 : thumbs.length))
          return;
        const index = thumbs.indexOf(target);
        currentThumbIndex.set(index);
        if (![
          kbd.ARROW_LEFT,
          kbd.ARROW_RIGHT,
          kbd.ARROW_UP,
          kbd.ARROW_DOWN,
          kbd.HOME,
          kbd.END
        ].includes(event.key)) {
          return;
        }
        event.preventDefault();
        const $step = get_store_value(step);
        const $value = get_store_value(value);
        const $orientation = get_store_value(orientation);
        switch (event.key) {
          case kbd.HOME: {
            updatePosition($min, index);
            break;
          }
          case kbd.END: {
            updatePosition($max, index);
            break;
          }
          case kbd.ARROW_LEFT: {
            if ($orientation !== "horizontal")
              break;
            if (event.metaKey) {
              updatePosition($min, index);
            } else if ($value[index] > $min) {
              const newValue = sub($value[index], $step);
              updatePosition(newValue, index);
            }
            break;
          }
          case kbd.ARROW_RIGHT: {
            if ($orientation !== "horizontal")
              break;
            if (event.metaKey) {
              updatePosition($max, index);
            } else if ($value[index] < $max) {
              const newValue = add($value[index], $step);
              updatePosition(newValue, index);
            }
            break;
          }
          case kbd.ARROW_UP: {
            if (event.metaKey) {
              updatePosition($max, index);
            } else if ($value[index] > $min && $orientation === "vertical") {
              const newValue = add($value[index], $step);
              updatePosition(newValue, index);
            } else if ($value[index] < $max) {
              const newValue = add($value[index], $step);
              updatePosition(newValue, index);
            }
            break;
          }
          case kbd.ARROW_DOWN: {
            if (event.metaKey) {
              updatePosition($min, index);
            } else if ($value[index] < $max && $orientation === "vertical") {
              const newValue = sub($value[index], $step);
              updatePosition(newValue, index);
            } else if ($value[index] > $min) {
              const newValue = sub($value[index], $step);
              updatePosition(newValue, index);
            }
            break;
          }
        }
      });
      return {
        destroy: unsub
      };
    }
  });
  effect([root, min2, max2, disabled, orientation, step], ([$root, $min, $max, $disabled, $orientation, $step]) => {
    if (!isBrowser || $disabled)
      return;
    const applyPosition = (clientXY, activeThumbIdx, leftOrBottom, rightOrTop) => {
      const percent = div(sub(clientXY, leftOrBottom), sub(rightOrTop, leftOrBottom));
      const val = add(mul(percent, sub($max, $min)), $min);
      if (val < $min) {
        updatePosition($min, activeThumbIdx);
      } else if (val > $max) {
        updatePosition($max, activeThumbIdx);
      } else {
        const step2 = $step;
        const newValue = mul(Math.round(div(val, step2)), step2);
        updatePosition(newValue, activeThumbIdx);
      }
    };
    const getClosestThumb = (e) => {
      const thumbs = getAllThumbs();
      if (!thumbs)
        return;
      thumbs.forEach((thumb3) => thumb3.blur());
      const distances = thumbs.map((thumb3) => {
        if ($orientation === "horizontal") {
          const { left, right } = thumb3.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb3.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const thumb2 = thumbs[distances.indexOf(Math.min(...distances))];
      const index = thumbs.indexOf(thumb2);
      return { thumb: thumb2, index };
    };
    const pointerDown = (e) => {
      if (e.button !== 0)
        return;
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = getClosestThumb(e);
      if (!closestThumb || !sliderEl)
        return;
      const target = e.target;
      if (!isHTMLElement(target) || !sliderEl.contains(target))
        return;
      e.preventDefault();
      activeThumb.set(closestThumb);
      closestThumb.thumb.focus();
      isActive.set(true);
      if ($orientation === "horizontal") {
        const { left, right } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientX, closestThumb.index, left, right);
      } else {
        const { top, bottom } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientY, closestThumb.index, bottom, top);
      }
    };
    const pointerUp = () => {
      isActive.set(false);
    };
    const pointerMove = (e) => {
      if (!get_store_value(isActive))
        return;
      const sliderEl = getElementByMeltId($root["data-melt-id"]);
      const closestThumb = get_store_value(activeThumb);
      if (!sliderEl || !closestThumb)
        return;
      closestThumb.thumb.focus();
      if ($orientation === "horizontal") {
        const { left, right } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientX, closestThumb.index, left, right);
      } else {
        const { top, bottom } = sliderEl.getBoundingClientRect();
        applyPosition(e.clientY, closestThumb.index, bottom, top);
      }
    };
    const unsub = executeCallbacks(addEventListener(document, "pointerdown", pointerDown), addEventListener(document, "pointerup", pointerUp), addEventListener(document, "pointerleave", pointerUp), addEventListener(document, "pointermove", pointerMove));
    return () => {
      unsub();
    };
  });
  return {
    elements: {
      root,
      thumb,
      range
    },
    states: {
      value
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/switch/create.js
var defaults21 = {
  defaultChecked: false,
  disabled: false,
  required: false,
  name: "",
  value: ""
};
var { name: name15 } = createElHelpers("switch");
function createSwitch(props) {
  const propsWithDefaults = { ...defaults21, ...props };
  const options = toWritableStores(omit(propsWithDefaults, "checked"));
  const { disabled, required, name: nameStore, value } = options;
  const checkedWritable = propsWithDefaults.checked ?? writable(propsWithDefaults.defaultChecked);
  const checked = overridable(checkedWritable, propsWithDefaults == null ? void 0 : propsWithDefaults.onCheckedChange);
  function toggleSwitch() {
    if (get_store_value(disabled))
      return;
    checked.update((prev2) => !prev2);
  }
  const root = builder(name15(), {
    stores: [checked, disabled, required],
    returned: ([$checked, $disabled, $required]) => {
      return {
        "data-disabled": $disabled,
        disabled: $disabled,
        "data-state": $checked ? "checked" : "unchecked",
        type: "button",
        role: "switch",
        "aria-checked": $checked,
        "aria-required": $required
      };
    },
    action(node) {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        toggleSwitch();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        toggleSwitch();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder(name15("input"), {
    stores: [checked, nameStore, required, disabled, value],
    returned: ([$checked, $name, $required, $disabled, $value]) => {
      return {
        type: "checkbox",
        "aria-hidden": true,
        hidden: true,
        tabindex: -1,
        name: $name,
        value: $value,
        checked: $checked,
        required: $required,
        disabled: $disabled,
        style: styleToString({
          position: "absolute",
          opacity: 0,
          "pointer-events": "none",
          margin: 0,
          transform: "translateX(-100%)"
        })
      };
    }
  });
  return {
    elements: {
      root,
      input
    },
    states: {
      checked
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tabs/create.js
var defaults22 = {
  orientation: "horizontal",
  activateOnFocus: true,
  loop: true,
  autoSet: true
};
var { name: name16, selector: selector7 } = createElHelpers("tabs");
function createTabs(props) {
  const withDefaults = { ...defaults22, ...props };
  const options = toWritableStores(omit(withDefaults, "defaultValue", "value", "onValueChange", "autoSet"));
  const { orientation, activateOnFocus, loop } = options;
  const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  let ssrValue = withDefaults.defaultValue ?? get_store_value(value);
  const root = builder(name16(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        "data-orientation": $orientation
      };
    }
  });
  const list = builder(name16("list"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "tablist",
        "aria-orientation": $orientation,
        "data-orientation": $orientation
      };
    }
  });
  const parseTriggerProps = (props2) => {
    if (typeof props2 === "string") {
      return { value: props2 };
    } else {
      return props2;
    }
  };
  const trigger = builder(name16("trigger"), {
    stores: [value, orientation],
    returned: ([$value, $orientation]) => {
      return (props2) => {
        const { value: tabValue, disabled } = parseTriggerProps(props2);
        if (!$value && !ssrValue && withDefaults.autoSet) {
          ssrValue = tabValue;
          $value = tabValue;
          value.set(tabValue);
        }
        const sourceOfTruth = isBrowser ? $value : ssrValue;
        const isActive = sourceOfTruth === tabValue;
        return {
          type: "button",
          role: "tab",
          "data-state": isActive ? "active" : "inactive",
          tabindex: isActive ? 0 : -1,
          "data-value": tabValue,
          "data-orientation": $orientation,
          "data-disabled": disabled ? true : void 0,
          disabled
        };
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "focus", () => {
        const disabled = node.dataset.disabled === "true";
        const tabValue = node.dataset.value;
        if (get_store_value(activateOnFocus) && !disabled && tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "click", (e) => {
        node.focus();
        e.preventDefault();
        const disabled = node.dataset.disabled === "true";
        if (disabled)
          return;
        const tabValue = node.dataset.value;
        node.focus();
        if (tabValue !== void 0) {
          value.set(tabValue);
        }
      }), addMeltEventListener(node, "keydown", (e) => {
        const tabValue = node.dataset.value;
        if (!tabValue)
          return;
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const rootEl = el.closest(selector7());
        if (!isHTMLElement(rootEl))
          return;
        const $loop = get_store_value(loop);
        const triggers = Array.from(rootEl.querySelectorAll('[role="tab"]')).filter((trigger2) => isHTMLElement(trigger2));
        const enabledTriggers = triggers.filter((el2) => !el2.hasAttribute("data-disabled"));
        const triggerIdx = enabledTriggers.findIndex((el2) => el2 === e.target);
        const dir = getElemDirection(rootEl);
        const { nextKey, prevKey } = getDirectionalKeys(dir, get_store_value(orientation));
        if (e.key === nextKey) {
          e.preventDefault();
          const nextEl = next(enabledTriggers, triggerIdx, $loop);
          nextEl.focus();
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevEl = prev(enabledTriggers, triggerIdx, $loop);
          prevEl.focus();
        } else if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
          e.preventDefault();
          value.set(tabValue);
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          const firstTrigger = enabledTriggers[0];
          firstTrigger.focus();
        } else if (e.key === kbd.END) {
          e.preventDefault();
          const lastTrigger = last(enabledTriggers);
          lastTrigger.focus();
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const content = builder(name16("content"), {
    stores: value,
    returned: ($value) => {
      return (tabValue) => {
        return {
          role: "tabpanel",
          // TODO: improve
          "aria-labelledby": tabValue,
          hidden: isBrowser ? $value === tabValue ? void 0 : true : ssrValue === tabValue ? void 0 : true,
          tabindex: 0
        };
      };
    }
  });
  return {
    elements: {
      root,
      list,
      trigger,
      content
    },
    states: {
      value
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/table-of-contents/create.js
var defaults23 = {
  exclude: ["h1"],
  scrollOffset: 0,
  scrollBehaviour: "smooth",
  activeType: "lowest"
};
function createTableOfContents(args) {
  const argsWithDefaults = { ...defaults23, ...args };
  const { selector: selector11, exclude, activeType, scrollBehaviour, scrollOffset, headingFilterFn, scrollFn } = argsWithDefaults;
  const { name: name22 } = createElHelpers("table-of-contents");
  const possibleHeadings = ["h1", "h2", "h3", "h4", "h5", "h6"];
  let headingsList = [];
  let elementsList = [];
  let elementHeadingLU = {};
  let headingParentsLU = {};
  const activeParentIdxs = writable([]);
  const visibleElementIdxs = writable([]);
  let elementTarget = null;
  let mutationObserver = null;
  let observer = null;
  const observer_threshold = 0.25;
  const activeHeadingIdxs = writable([]);
  const headingsTree = writable([]);
  function createTree(arr, startIndex = 0) {
    const tree = [];
    let i = 0;
    while (i < arr.length) {
      const node = {
        title: arr[i].innerText,
        index: startIndex + i,
        id: arr[i].id,
        node: arr[i],
        children: []
      };
      let j = i + 1;
      while (j < arr.length && parseInt(arr[j].tagName.charAt(1)) > parseInt(arr[i].tagName.charAt(1))) {
        j++;
      }
      node.children = createTree(arr.slice(i + 1, j), startIndex + i + 1);
      tree.push(node);
      i = j;
    }
    return tree;
  }
  function generateInitialLists(elementTarget2) {
    let headingsList2 = [];
    let elementsList2 = [];
    const includedHeadings = possibleHeadings.filter((h) => !exclude.includes(h));
    const targetHeaders = elementTarget2 == null ? void 0 : elementTarget2.querySelectorAll(includedHeadings.join(", "));
    targetHeaders == null ? void 0 : targetHeaders.forEach((el) => {
      if (!el.id) {
        const uniqueID = el.innerText.replaceAll(/[^a-zA-Z0-9 ]/g, "").replaceAll(" ", "-").toLowerCase();
        el.id = `${uniqueID}`;
      }
      headingsList2.push(el);
    });
    headingsList2 = [...headingsList2];
    if (headingFilterFn) {
      headingsList2 = headingsList2.filter((heading) => headingFilterFn(heading));
    }
    elementsList2 = [].slice.call(elementTarget2 == null ? void 0 : elementTarget2.getElementsByTagName("*"));
    elementsList2 = elementsList2.filter((el) => includedHeadings.includes(el.nodeName.toLowerCase()) || el.children.length === 0);
    elementsList2.splice(0, elementsList2.indexOf(headingsList2[0]));
    return {
      headingsList: headingsList2,
      elementsList: elementsList2
    };
  }
  function findParentIdxs() {
    headingsList.forEach((h, i) => {
      headingParentsLU[i] = null;
      let current_heading = h.tagName;
      let parents = [];
      for (let j = i - 1; j >= 0; j--) {
        if (headingsList[j].tagName < current_heading) {
          current_heading = headingsList[j].tagName;
          parents = [...parents, j];
        }
      }
      headingParentsLU[i] = parents.length > 0 ? parents : null;
    });
  }
  function createElementHeadingLU() {
    headingsList.forEach((h, i) => {
      const startIndex = elementsList.indexOf(headingsList[i]);
      const endIndex = i !== headingsList.length - 1 ? elementsList.indexOf(headingsList[i + 1]) : elementsList.length;
      for (let j = startIndex; j < endIndex; j++) {
        elementHeadingLU[j] = i;
      }
    });
  }
  function handleElementObservation(entries) {
    var _a;
    for (let i = 0; i < entries.length; i++) {
      const el_idx = elementsList.indexOf(entries[i].target);
      const toc_idx = elementHeadingLU[el_idx];
      let tempVisibleElementIdxs = get_store_value(visibleElementIdxs);
      if (entries[i].intersectionRatio >= observer_threshold) {
        if (tempVisibleElementIdxs.indexOf(el_idx) === -1) {
          tempVisibleElementIdxs = [...tempVisibleElementIdxs, el_idx];
          visibleElementIdxs.set(tempVisibleElementIdxs);
          activeParentIdxs.set((activeType === "highest-parents" || activeType === "lowest-parents") && headingParentsLU[toc_idx] ? [...get_store_value(activeParentIdxs), ...headingParentsLU[toc_idx]] : []);
        }
      } else {
        tempVisibleElementIdxs = tempVisibleElementIdxs.filter((item2) => item2 !== el_idx);
        visibleElementIdxs.set(tempVisibleElementIdxs);
        if ((activeType === "highest-parents" || activeType === "lowest-parents") && headingParentsLU[toc_idx]) {
          (_a = headingParentsLU[toc_idx]) == null ? void 0 : _a.forEach((parent) => {
            const tempActiveParentIdxs = get_store_value(activeParentIdxs);
            const index = tempActiveParentIdxs.indexOf(parent);
            tempActiveParentIdxs.splice(index, 1);
            activeParentIdxs.set(tempActiveParentIdxs);
          });
        }
      }
    }
    const allActiveHeaderIdxs = Array.from(new Set(get_store_value(visibleElementIdxs).map((idx) => elementHeadingLU[idx])));
    let activeHeaderIdxs;
    if (allActiveHeaderIdxs.length === 0) {
      activeHeaderIdxs = [];
    } else if (activeType === "highest") {
      activeHeaderIdxs = [Math.min(...allActiveHeaderIdxs)];
    } else if (activeType === "lowest") {
      activeHeaderIdxs = [Math.max(...allActiveHeaderIdxs)];
    } else if (activeType === "all") {
      activeHeaderIdxs = allActiveHeaderIdxs;
    } else {
      const activeHeaderIdx = activeType === "highest-parents" ? Math.min(...allActiveHeaderIdxs) : Math.max(...allActiveHeaderIdxs);
      if (headingParentsLU[activeHeaderIdx]) {
        activeHeaderIdxs = [...headingParentsLU[activeHeaderIdx], activeHeaderIdx];
      } else {
        activeHeaderIdxs = [activeHeaderIdx];
      }
    }
    activeHeadingIdxs.set(activeHeaderIdxs);
  }
  function scrollToTargetAdjusted(selector12) {
    const element = document.getElementById(selector12);
    if (element) {
      const elementPosition = element.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.scrollY - scrollOffset;
      window.scrollTo({
        top: offsetPosition,
        behavior: scrollBehaviour
      });
    }
  }
  const item = builder(name22("item"), {
    stores: activeHeadingIdxs,
    returned: ($activeHeadingIdxs) => {
      return (id) => {
        const idx = headingsList.findIndex((heading) => heading.id === id);
        const active = $activeHeadingIdxs.includes(idx);
        return {
          "data-id": id,
          "data-active": active ? "" : void 0
        };
      };
    },
    action: (node) => {
      const id = node.getAttribute("data-id");
      const unsub = executeCallbacks(addEventListener(node, "click", (e) => {
        e.preventDefault();
        if (scrollFn) {
          scrollFn(`${id}`);
        } else {
          scrollToTargetAdjusted(`${id}`);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  function mutationHandler() {
    const newElementTarget = document.querySelector(selector11);
    if (!newElementTarget)
      return;
    const { headingsList: newHeadingsList, elementsList: newElementsList } = generateInitialLists(newElementTarget);
    if (dequal(headingsList, newHeadingsList))
      return;
    headingsList = newHeadingsList;
    elementsList = newElementsList;
    headingParentsLU = {};
    elementHeadingLU = {};
    initialization();
  }
  function initialization() {
    observer == null ? void 0 : observer.disconnect();
    findParentIdxs();
    createElementHeadingLU();
    headingsTree.set(createTree(headingsList));
    if (activeType !== "none") {
      observer = new IntersectionObserver(handleElementObservation, {
        root: null,
        threshold: observer_threshold
      });
      elementsList.forEach((el) => observer == null ? void 0 : observer.observe(el));
    }
  }
  onMount(() => {
    elementTarget = document.querySelector(selector11);
    if (!elementTarget)
      return;
    ({ headingsList, elementsList } = generateInitialLists(elementTarget));
    initialization();
    mutationObserver = new MutationObserver(mutationHandler);
    mutationObserver.observe(elementTarget, { childList: true, subtree: true });
    return () => {
      observer == null ? void 0 : observer.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    };
  });
  return {
    elements: {
      item
    },
    states: {
      activeHeadingIdxs,
      headingsTree
    }
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tags-input/helpers.js
function focusInput(id, pos = "default") {
  const inputEl = getElementByMeltId(id);
  if (!isHTMLInputElement(inputEl))
    return;
  inputEl.focus();
  if (pos === "start") {
    inputEl.setSelectionRange(0, 0);
  } else if (pos === "end") {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
  }
}
function setSelectedFromEl(el, selected) {
  if (!el) {
    selected.set(null);
    return;
  }
  selected.set({
    id: el.getAttribute("data-tag-id") ?? "",
    value: el.getAttribute("data-tag-value") ?? ""
  });
}
function highlightText(query) {
  const el = document.querySelector(query);
  if (!isHTMLElement(el))
    return;
  el.focus();
  const range = document.createRange();
  range.selectNodeContents(el);
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tags-input/create.js
var defaults24 = {
  placeholder: "",
  disabled: false,
  editable: true,
  defaultTags: [],
  unique: false,
  trim: true,
  blur: "nothing",
  addOnPaste: false,
  maxTags: void 0,
  allowed: [],
  denied: [],
  add: void 0,
  remove: void 0,
  update: void 0
};
var { name: name17, attribute, selector: selector8 } = createElHelpers("tags-input");
function createTagsInput(props) {
  const withDefaults = { ...defaults24, ...props };
  const ids = {
    root: generateId(),
    input: generateId()
  };
  const options = toWritableStores(omit(withDefaults, "tags"));
  const { placeholder, disabled, editable, unique, trim, blur, addOnPaste, allowed, denied, add: add2, remove, update, maxTags } = options;
  const inputValue = writable("");
  const inputInvalid = writable(false);
  const editValue = writable("");
  const tagsWritable = withDefaults.tags ?? writable(
    withDefaults.defaultTags && withDefaults.defaultTags.length > 0 ? typeof withDefaults.defaultTags[0] === "string" ? withDefaults.defaultTags.map((tag2) => ({ id: generateId(), value: tag2 })) : withDefaults.defaultTags : []
    // if undefined)
  );
  const tags = overridable(tagsWritable, withDefaults == null ? void 0 : withDefaults.onTagsChange);
  const selected = writable(withDefaults.selected ?? null);
  const editing = writable(null);
  const isInputValid = (v) => {
    const $tags = get_store_value(tags);
    const $editing = get_store_value(editing);
    const $allowed = get_store_value(allowed);
    const $denied = get_store_value(denied);
    const $maxTags = get_store_value(maxTags);
    if (get_store_value(trim))
      v = v.trim();
    if (get_store_value(unique) && ($editing == null ? void 0 : $editing.value) !== v) {
      const index = $tags.findIndex((tag2) => tag2.value === v);
      if (index >= 0)
        return false;
    }
    if ($allowed && $allowed.length > 0 && !$allowed.includes(v))
      return false;
    if ($denied && $denied.length > 0 && $denied.includes(v))
      return false;
    if ($maxTags && $maxTags > 0 && $tags.length >= $maxTags)
      return false;
    return true;
  };
  const addTag = async (v) => {
    const $add = get_store_value(add2);
    let workingTag = { id: "", value: v };
    if ($add) {
      try {
        const res = await $add(v);
        if (typeof res === "string")
          workingTag.value = res;
        else
          workingTag = res;
        if (!workingTag.id)
          workingTag.id = generateId();
      } catch {
        return false;
      }
    } else {
      workingTag.id = generateId();
    }
    if (get_store_value(trim))
      workingTag.value = workingTag.value.trim();
    if (!isInputValid(workingTag.value))
      return false;
    tags.update((current) => {
      current.push(workingTag);
      return current;
    });
    return true;
  };
  async function updateTag(tag2, select = false) {
    const $update = get_store_value(update);
    const oldId = tag2.id;
    let workingTag = tag2;
    if ($update) {
      try {
        const res = await $update(workingTag);
        workingTag = res;
        if (!workingTag.id)
          workingTag.id = generateId();
      } catch {
        return false;
      }
    }
    if (get_store_value(trim))
      workingTag.value = workingTag.value.trim();
    if (!isInputValid(workingTag.value))
      return false;
    tags.update(($tags) => {
      return $tags.map((t) => {
        if (t.id === oldId) {
          return workingTag;
        }
        return t;
      });
    });
    if (select)
      selected.set(workingTag);
    return true;
  }
  async function removeTag(t) {
    const $remove = get_store_value(remove);
    if ($remove) {
      try {
        if (!await $remove(t))
          return false;
      } catch {
        return false;
      }
    }
    const $tags = get_store_value(tags);
    const index = $tags.findIndex((tag2) => tag2.id === t.id);
    tags.update((t2) => {
      t2.splice(index, 1);
      return t2;
    });
    return true;
  }
  const root = builder(name17(""), {
    stores: disabled,
    returned: ($disabled) => {
      return {
        "data-melt-id": ids.root,
        "data-disabled": $disabled ? true : void 0,
        disabled: $disabled
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "mousedown", (e) => {
        const target = e.target;
        if (!isHTMLElement(target))
          return;
        if (target.hasAttribute(attribute())) {
          e.preventDefault();
          focusInput(ids.input);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const input = builder(name17("input"), {
    stores: [disabled, placeholder],
    returned: ([$disabled, $placeholder]) => {
      return {
        "data-melt-id": ids.input,
        "data-disabled": $disabled ? "" : void 0,
        disabled: $disabled,
        placeholder: $placeholder
      };
    },
    action: (node) => {
      const getTagsInfo = (id) => {
        const rootEl = getElementByMeltId(ids.root);
        let tagsEl = [];
        let selectedIndex = -1;
        let prevIndex = -1;
        let nextIndex = -1;
        if (rootEl) {
          tagsEl = Array.from(rootEl.querySelectorAll(selector8("tag")));
          selectedIndex = tagsEl.findIndex((element) => element.getAttribute("data-tag-id") === id);
          prevIndex = selectedIndex - 1;
          nextIndex = selectedIndex + 1;
        }
        return {
          tagsEl,
          selectedIndex,
          prevIndex,
          nextIndex
        };
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "focus", () => {
        const rootEl = getElementByMeltId(ids.root);
        if (rootEl)
          rootEl.setAttribute("data-focus", "");
        node.setAttribute("data-focus", "");
      }), addMeltEventListener(node, "blur", async () => {
        const rootEl = getElementByMeltId(ids.root);
        if (rootEl)
          rootEl.removeAttribute("data-focus");
        node.removeAttribute("data-focus");
        selected.set(null);
        const value = node.value;
        if (!value)
          return;
        const $blur = get_store_value(blur);
        if ($blur === "clear") {
          node.value = "";
        } else if ($blur === "add") {
          if (isInputValid(value) && await addTag(value)) {
            node.value = "";
            inputValue.set("");
          } else {
            inputInvalid.set(true);
          }
        }
      }), addMeltEventListener(node, "paste", async (e) => {
        if (!e.clipboardData)
          return;
        const pastedText = e.clipboardData.getData("text");
        if (!pastedText)
          return;
        if (!get_store_value(addOnPaste))
          return;
        if (isInputValid(pastedText) && await addTag(pastedText)) {
          node.value = "";
        } else {
          inputInvalid.set(true);
        }
      }), addMeltEventListener(node, "keydown", async (e) => {
        const $selected = get_store_value(selected);
        if ($selected) {
          if (e.key.length === 1) {
            selected.set(null);
          } else if (e.key === kbd.ARROW_LEFT) {
            e.preventDefault();
            const { tagsEl, prevIndex } = getTagsInfo($selected.id);
            if (prevIndex >= 0) {
              setSelectedFromEl(tagsEl[prevIndex], selected);
            }
          } else if (e.key === kbd.ARROW_RIGHT) {
            e.preventDefault();
            const { tagsEl, nextIndex } = getTagsInfo($selected.id);
            if (nextIndex === -1 || nextIndex >= tagsEl.length) {
              selected.set(null);
              focusInput(ids.input, "start");
            } else {
              setSelectedFromEl(tagsEl[nextIndex], selected);
            }
          } else if (e.key === kbd.HOME) {
            e.preventDefault();
            const { tagsEl } = getTagsInfo($selected.id);
            if (tagsEl.length > 0)
              setSelectedFromEl(tagsEl[0], selected);
          } else if (e.key === kbd.END) {
            e.preventDefault();
            selected.set(null);
            focusInput(ids.input);
          } else if (e.key === kbd.DELETE) {
            e.preventDefault();
            const prevSelected = $selected;
            const { tagsEl, nextIndex } = getTagsInfo($selected.id);
            if (nextIndex === -1 || nextIndex >= tagsEl.length) {
              selected.set(null);
              focusInput(ids.input);
            } else {
              setSelectedFromEl(tagsEl[nextIndex], selected);
            }
            if (!await removeTag(prevSelected))
              selected.set(prevSelected);
          } else if (e.key === kbd.BACKSPACE) {
            e.preventDefault();
            const prevSelected = $selected;
            const { tagsEl, nextIndex, prevIndex } = getTagsInfo($selected.id);
            if (prevIndex >= 0) {
              setSelectedFromEl(tagsEl[prevIndex], selected);
            } else {
              if (nextIndex === -1 || nextIndex >= tagsEl.length) {
                selected.set(null);
                focusInput(ids.input, "start");
              } else {
                setSelectedFromEl(tagsEl[nextIndex], selected);
              }
            }
            if (!await removeTag(prevSelected))
              selected.set(prevSelected);
          } else if (e.key === kbd.ENTER) {
            e.preventDefault();
            const editEl = document.querySelector(selector8("edit") + `[data-tag-id="${$selected.id}"]`);
            if (!editEl)
              return;
            editing.set({ id: $selected.id, value: $selected.value });
            editEl.textContent = $selected.value;
            await tick();
            highlightText(selector8("edit") + `[data-tag-id="${$selected.id}"]`);
          }
        } else {
          if (e.key === kbd.ENTER) {
            e.preventDefault();
            const value = node.value;
            if (!value)
              return;
            if (isInputValid(value) && await addTag(value)) {
              node.value = "";
              inputValue.set("");
            } else {
              inputInvalid.set(true);
            }
          } else if (node.selectionStart === 0 && node.selectionEnd === 0 && (e.key === kbd.ARROW_LEFT || e.key === kbd.BACKSPACE)) {
            e.preventDefault();
            const { tagsEl } = getTagsInfo("");
            const lastTag = tagsEl.at(-1);
            if (!lastTag)
              return;
            setSelectedFromEl(lastTag, selected);
          }
        }
      }), addMeltEventListener(node, "input", () => {
        inputValue.set(node.value);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const tag = builder(name17("tag"), {
    stores: [selected, editing, disabled, editable],
    returned: ([$selected, $editing, $disabled, $editable]) => {
      return (tag2) => {
        const disabled2 = $disabled || tag2.disabled;
        const editable2 = $editable && tag2.editable !== false;
        const selected2 = disabled2 ? void 0 : ($selected == null ? void 0 : $selected.id) === (tag2 == null ? void 0 : tag2.id);
        const editing2 = editable2 ? ($editing == null ? void 0 : $editing.id) === (tag2 == null ? void 0 : tag2.id) : void 0;
        return {
          "aria-hidden": editing2,
          "aria-selected": selected2,
          "data-tag-id": tag2.id,
          "data-tag-value": tag2.value,
          "data-selected": selected2 ? "" : void 0,
          "data-editable": editable2 ? "" : void 0,
          "data-editing": editing2 ? "" : void 0,
          "data-disabled": disabled2 ? "" : void 0,
          disabled: disabled2,
          hidden: editing2,
          tabindex: -1,
          style: editing2 ? styleToString({
            position: "absolute",
            opacity: 0,
            "pointer-events": "none",
            margin: 0
          }) : void 0
        };
      };
    },
    action: (node) => {
      const getElProps = () => {
        const id = node.getAttribute("data-tag-id") ?? "";
        return {
          id
        };
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "mousedown", (e) => {
        const $editing = get_store_value(editing);
        if ($editing && $editing.id !== getElProps().id)
          return;
        focusInput(ids.input);
        e.preventDefault();
        setSelectedFromEl(node, selected);
        editing.set(null);
      }), addMeltEventListener(node, "click", (e) => {
        const $editing = get_store_value(editing);
        if ($editing && $editing.id === getElProps().id)
          return;
        focusInput(ids.input);
        e.preventDefault();
        setSelectedFromEl(node, selected);
        editing.set(null);
      }), addMeltEventListener(node, "dblclick", async () => {
        if (!isBrowser)
          return;
        if (!node.hasAttribute("data-editable"))
          return;
        const editEl = document.querySelector(selector8("edit") + `[data-tag-id="${getElProps().id}"]`);
        if (!editEl)
          return;
        const value = node.getAttribute("data-tag-value") ?? "";
        editing.set({
          id: node.getAttribute("data-tag-id") ?? "",
          value
        });
        editEl.textContent = value;
        await tick();
        highlightText(selector8("edit") + `[data-tag-id="${getElProps().id}"]`);
      }));
      return {
        destroy: unsub
      };
    }
  });
  const deleteTrigger = builder(name17("delete-trigger"), {
    stores: [selected, editing, disabled, editable],
    returned: ([$selected, $editing, $disabled, $editable]) => {
      return (tag2) => {
        const disabled2 = $disabled || tag2.disabled;
        const editable2 = $editable && tag2.editable !== false;
        const selected2 = disabled2 ? void 0 : ($selected == null ? void 0 : $selected.id) === (tag2 == null ? void 0 : tag2.id);
        const editing2 = editable2 ? ($editing == null ? void 0 : $editing.id) === (tag2 == null ? void 0 : tag2.id) : void 0;
        return {
          "aria-selected": selected2,
          "data-tag-id": tag2.id,
          "data-tag-value": tag2.value,
          "data-selected": selected2 ? "" : void 0,
          "data-editing": editing2 ? "" : void 0,
          "data-disabled": disabled2 ? "" : void 0,
          disabled: disabled2,
          tabindex: -1
        };
      };
    },
    action: (node) => {
      function handleDelete() {
        if (node.hasAttribute("data-disabled"))
          return;
        const value = node.getAttribute("data-tag-value") ?? "";
        const id = node.getAttribute("data-tag-id") ?? "";
        removeTag({ id, value });
        focusInput(ids.input);
      }
      const unsub = executeCallbacks(addMeltEventListener(node, "click", (e) => {
        e.stopPropagation();
        handleDelete();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleDelete();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const edit = builder(name17("edit"), {
    stores: [editing, editable],
    returned: ([$editing, $editable]) => {
      return (tag2) => {
        const editable2 = $editable;
        const editing2 = editable2 ? ($editing == null ? void 0 : $editing.id) === tag2.id : void 0;
        return {
          "aria-hidden": !editing2,
          "data-tag-id": tag2.id,
          "data-tag-value": tag2.value,
          hidden: !editing2 ? true : void 0,
          contenteditable: editing2,
          tabindex: -1,
          style: !editing2 ? styleToString({
            position: "absolute",
            opacity: 0,
            "pointer-events": "none",
            margin: 0
          }) : void 0
        };
      };
    },
    action: (node) => {
      const getElProps = () => {
        const id = node.getAttribute("data-tag-id") ?? "";
        const value = node.getAttribute("data-tag-value") ?? "";
        return {
          id,
          value
        };
      };
      const unsub = executeCallbacks(addMeltEventListener(node, "blur", () => {
        var _a;
        if (node.hasAttribute("hidden"))
          return;
        editing.set(null);
        node.textContent = getElProps().value;
        (_a = getElementByMeltId(ids.root)) == null ? void 0 : _a.removeAttribute("data-invalid-edit");
        node.removeAttribute("data-invalid-edit");
      }), addMeltEventListener(node, "keydown", async (e) => {
        var _a;
        if (node.hasAttribute("hidden"))
          return;
        if (e.key === kbd.ENTER) {
          e.preventDefault();
          const value = node.textContent;
          if (!value)
            return;
          const t = { id: getElProps().id, value };
          if (isInputValid(value) && await updateTag(t, true)) {
            node.textContent = t.value;
            editValue.set("");
            focusInput(ids.input);
          } else {
            (_a = getElementByMeltId(ids.root)) == null ? void 0 : _a.setAttribute("data-invalid-edit", "");
            node.setAttribute("data-invalid-edit", "");
          }
        } else if (e.key === kbd.ESCAPE) {
          e.preventDefault();
          node.textContent = getElProps().value;
          editValue.set("");
          setSelectedFromEl(node, selected);
          focusInput(ids.input);
        }
      }), addMeltEventListener(node, "input", () => {
        if (node.hasAttribute("hidden"))
          return;
        editValue.set(node.textContent || "");
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isSelected = derived(selected, ($selected) => {
    return (tag2) => ($selected == null ? void 0 : $selected.id) === tag2.id;
  });
  effect(inputValue, () => {
    inputInvalid.set(false);
  });
  effect(inputInvalid, ($inputInvalid) => {
    var _a, _b, _c, _d;
    if ($inputInvalid) {
      (_a = getElementByMeltId(ids.root)) == null ? void 0 : _a.setAttribute("data-invalid", "");
      (_b = getElementByMeltId(ids.input)) == null ? void 0 : _b.setAttribute("data-invalid", "");
    } else {
      (_c = getElementByMeltId(ids.root)) == null ? void 0 : _c.removeAttribute("data-invalid");
      (_d = getElementByMeltId(ids.input)) == null ? void 0 : _d.removeAttribute("data-invalid");
    }
  });
  effect(editValue, () => {
    var _a;
    if (!isBrowser)
      return;
    (_a = getElementByMeltId(ids.root)) == null ? void 0 : _a.removeAttribute("data-invalid-edit");
    const invalidEl = Array.from(document.querySelectorAll(selector8("edit") + "[data-invalid-edit]"));
    invalidEl.forEach((e) => {
      e.removeAttribute("data-invalid-edit");
    });
  });
  return {
    elements: {
      root,
      input,
      deleteTrigger,
      edit,
      tag
    },
    states: {
      tags,
      inputValue: readonly(inputValue),
      inputInvalid: readonly(inputInvalid),
      selected: readonly(selected)
    },
    helpers: {
      isSelected,
      isInputValid,
      addTag,
      updateTag,
      removeTag
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toast/create.js
var { name: name18 } = createElHelpers("toast");
var defaults25 = {
  closeDelay: 5e3,
  type: "foreground"
};
function createToaster(props) {
  const withDefaults = { ...defaults25, ...props };
  const options = toWritableStores(withDefaults);
  const { closeDelay, type } = options;
  const toastsMap = writable(/* @__PURE__ */ new Map());
  const addToast = (props2) => {
    const propsWithDefaults = {
      closeDelay: get_store_value(closeDelay),
      type: get_store_value(type),
      ...props2
    };
    const ids = {
      content: generateId(),
      title: generateId(),
      description: generateId()
    };
    const timeout = propsWithDefaults.closeDelay === 0 ? null : window.setTimeout(() => {
      removeToast(ids.content);
    }, propsWithDefaults.closeDelay);
    const getPercentage = () => {
      const { createdAt, pauseDuration, closeDelay: closeDelay2, pausedAt } = toast;
      if (closeDelay2 === 0)
        return 0;
      if (pausedAt) {
        return 100 * (pausedAt - createdAt - pauseDuration) / closeDelay2;
      } else {
        const now = performance.now();
        return 100 * (now - createdAt - pauseDuration) / closeDelay2;
      }
    };
    const toast = {
      id: ids.content,
      ids,
      ...propsWithDefaults,
      timeout,
      createdAt: performance.now(),
      pauseDuration: 0,
      getPercentage
    };
    toastsMap.update((currentMap) => {
      currentMap.set(ids.content, toast);
      return new Map(currentMap);
    });
    return toast;
  };
  const removeToast = (id) => {
    toastsMap.update((currentMap) => {
      currentMap.delete(id);
      return new Map(currentMap);
    });
  };
  const updateToast = (id, data) => {
    toastsMap.update((currentMap) => {
      const toast = currentMap.get(id);
      if (!toast)
        return currentMap;
      currentMap.set(id, { ...toast, data });
      return new Map(currentMap);
    });
  };
  const content = builder(name18("content"), {
    stores: toastsMap,
    returned: ($toasts) => {
      return (id) => {
        const t = $toasts.get(id);
        if (!t)
          return null;
        const { ...toast } = t;
        return {
          id,
          role: "alert",
          "aria-describedby": toast.ids.description,
          "aria-labelledby": toast.ids.title,
          "aria-live": toast.type === "foreground" ? "assertive" : "polite",
          tabindex: -1
        };
      };
    },
    action: (node) => {
      let destroy = noop;
      destroy = executeCallbacks(addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        toastsMap.update((currentMap) => {
          const currentToast = currentMap.get(node.id);
          if (!currentToast || currentToast.closeDelay === 0)
            return currentMap;
          if (currentToast.timeout !== null) {
            window.clearTimeout(currentToast.timeout);
          }
          currentToast.pausedAt = performance.now();
          return new Map(currentMap);
        });
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        toastsMap.update((currentMap) => {
          const currentToast = currentMap.get(node.id);
          if (!currentToast || currentToast.closeDelay === 0)
            return currentMap;
          const pausedAt = currentToast.pausedAt ?? currentToast.createdAt;
          const elapsed = pausedAt - currentToast.createdAt - currentToast.pauseDuration;
          const remaining = currentToast.closeDelay - elapsed;
          currentToast.timeout = window.setTimeout(() => {
            removeToast(node.id);
          }, remaining);
          currentToast.pauseDuration += performance.now() - pausedAt;
          currentToast.pausedAt = void 0;
          return new Map(currentMap);
        });
      }), () => {
        removeToast(node.id);
      });
      return {
        destroy
      };
    }
  });
  const title = builder(name18("title"), {
    stores: toastsMap,
    returned: ($toasts) => {
      return (id) => {
        const toast = $toasts.get(id);
        if (!toast)
          return null;
        return {
          id: toast.ids.title
        };
      };
    }
  });
  const description = builder(name18("description"), {
    stores: toastsMap,
    returned: ($toasts) => {
      return (id) => {
        const toast = $toasts.get(id);
        if (!toast)
          return null;
        return {
          id: toast.ids.description
        };
      };
    }
  });
  const close = builder(name18("close"), {
    returned: () => {
      return (id) => ({
        type: "button",
        "data-id": id
      });
    },
    action: (node) => {
      function handleClose() {
        if (!node.dataset.id)
          return;
        removeToast(node.dataset.id);
      }
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleClose();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleClose();
      }));
      return {
        destroy: unsub
      };
    }
  });
  const toasts = derived(toastsMap, ($toastsMap) => {
    return Array.from($toastsMap.values());
  });
  return {
    elements: {
      content,
      title,
      description,
      close
    },
    states: {
      toasts: readonly(toasts)
    },
    helpers: {
      addToast,
      removeToast,
      updateToast
    },
    actions: {
      portal: usePortal
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toggle/create.js
var defaults26 = {
  defaultPressed: false,
  disabled: false
};
function createToggle(props) {
  const withDefaults = { ...defaults26, ...props };
  const options = toWritableStores(omit(withDefaults, "pressed"));
  const { disabled } = options;
  const pressedWritable = withDefaults.pressed ?? writable(withDefaults.defaultPressed);
  const pressed = overridable(pressedWritable, withDefaults == null ? void 0 : withDefaults.onPressedChange);
  function handleToggle() {
    const $disabled = get_store_value(disabled);
    if ($disabled)
      return;
    pressed.update((v) => !v);
  }
  const root = builder("toggle", {
    stores: [pressed, disabled],
    returned: ([$pressed, $disabled]) => {
      return {
        "data-disabled": $disabled ? true : void 0,
        disabled: $disabled,
        "data-state": $pressed ? "on" : "off",
        "aria-pressed": $pressed,
        type: "button"
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleToggle();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)
          return;
        e.preventDefault();
        handleToggle();
      }));
      return {
        destroy: unsub
      };
    }
  });
  return {
    elements: {
      root
    },
    states: {
      pressed
    },
    options
  };
}

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toggle-group/create.js
var defaults27 = {
  type: "single",
  orientation: "horizontal",
  loop: true,
  rovingFocus: true,
  disabled: false,
  defaultValue: ""
};
var { name: name19, selector: selector9 } = createElHelpers("toggle-group");
var createToggleGroup = (props) => {
  const withDefaults = { ...defaults27, ...props };
  const options = toWritableStores(omit(withDefaults, "value"));
  const { type, orientation, loop, rovingFocus, disabled } = options;
  const defaultValue = withDefaults.defaultValue ? withDefaults.defaultValue : withDefaults.type === "single" ? "undefined" : [];
  const valueWritable = withDefaults.value ?? writable(defaultValue);
  const value = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
  const root = builder(name19(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "group",
        "data-orientation": $orientation
      };
    }
  });
  const item = builder(name19("item"), {
    stores: [value, disabled, orientation, type],
    returned: ([$value, $disabled, $orientation, $type]) => {
      return (props2) => {
        const itemValue = typeof props2 === "string" ? props2 : props2.value;
        const argDisabled = typeof props2 === "string" ? false : !!props2.disabled;
        const disabled2 = $disabled || argDisabled;
        const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
        return {
          disabled: disabled2,
          pressed,
          "data-orientation": $orientation,
          "data-disabled": disabled2 ? true : void 0,
          "data-state": pressed ? "on" : "off",
          "data-value": itemValue,
          "aria-pressed": pressed,
          type: "button",
          role: $type === "single" ? "radio" : void 0,
          tabindex: pressed ? 0 : -1
        };
      };
    },
    action: (node) => {
      let unsub = noop;
      const parentGroup = node.closest(selector9());
      if (!isHTMLElement(parentGroup))
        return {};
      const items = Array.from(parentGroup.querySelectorAll(selector9("item")));
      const $value = get_store_value(value);
      const anyPressed = Array.isArray($value) ? $value.length > 0 : $value !== null;
      if (!anyPressed && items[0] === node) {
        node.tabIndex = 0;
      }
      function getNodeProps() {
        const itemValue = node.dataset.value;
        const disabled2 = node.dataset.disabled === "true";
        return { value: itemValue, disabled: disabled2 };
      }
      function handleValueUpdate() {
        const { value: itemValue, disabled: disabled2 } = getNodeProps();
        if (itemValue === void 0 || disabled2)
          return;
        value.update(($value2) => {
          if (Array.isArray($value2)) {
            if ($value2.includes(itemValue)) {
              return $value2.filter((i) => i !== itemValue);
            }
            $value2.push(itemValue);
            return $value2;
          }
          return $value2 === itemValue ? void 0 : itemValue;
        });
      }
      unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
        handleValueUpdate();
      }), addMeltEventListener(node, "keydown", (e) => {
        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {
          e.preventDefault();
          handleValueUpdate();
          return;
        }
        if (!get_store_value(rovingFocus))
          return;
        const el = e.currentTarget;
        if (!isHTMLElement(el))
          return;
        const root2 = el.closest(selector9());
        if (!isHTMLElement(root2))
          return;
        const items2 = Array.from(root2.querySelectorAll(selector9("item") + ":not([data-disabled])")).filter((item2) => isHTMLElement(item2));
        const currentIndex = items2.indexOf(el);
        const dir = getElemDirection(el);
        const $orientation = get_store_value(orientation);
        const nextKey = {
          horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
          vertical: kbd.ARROW_DOWN
        }[$orientation ?? "horizontal"];
        const prevKey = {
          horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
          vertical: kbd.ARROW_UP
        }[$orientation ?? "horizontal"];
        const $loop = get_store_value(loop);
        if (e.key === nextKey) {
          e.preventDefault();
          const nextIndex = currentIndex + 1;
          if (nextIndex >= items2.length && $loop) {
            handleRovingFocus(items2[0]);
          } else {
            handleRovingFocus(items2[nextIndex]);
          }
        } else if (e.key === prevKey) {
          e.preventDefault();
          const prevIndex = currentIndex - 1;
          if (prevIndex < 0 && $loop) {
            handleRovingFocus(items2[items2.length - 1]);
          } else {
            handleRovingFocus(items2[prevIndex]);
          }
        } else if (e.key === kbd.HOME) {
          e.preventDefault();
          handleRovingFocus(items2[0]);
        } else if (e.key === kbd.END) {
          e.preventDefault();
          handleRovingFocus(items2[items2.length - 1]);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isPressed = derived(value, ($value) => {
    return (itemValue) => {
      return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
    };
  });
  return {
    elements: {
      root,
      item
    },
    states: {
      value
    },
    helpers: {
      isPressed
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/toolbar/create.js
var defaults28 = {
  loop: true,
  orientation: "horizontal"
};
var { name: name20, selector: selector10 } = createElHelpers("toolbar");
var createToolbar = (props) => {
  const withDefaults = { ...defaults28, ...props };
  const options = toWritableStores(withDefaults);
  const { loop, orientation } = options;
  const root = builder(name20(), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "toolbar",
        "data-orientation": $orientation
      };
    }
  });
  const button = builder(name20("button"), {
    returned: () => ({
      role: "button",
      type: "button",
      tabIndex: -1
    }),
    action: (node) => {
      const unsub = addMeltEventListener(node, "keydown", handleKeyDown);
      return {
        destroy: unsub
      };
    }
  });
  const link = builder(name20("link"), {
    returned: () => ({
      role: "link",
      "data-melt-toolbar-item": "",
      tabIndex: -1
    }),
    action: (node) => {
      const unsub = addMeltEventListener(node, "keydown", handleKeyDown);
      return {
        destroy: unsub
      };
    }
  });
  const separator = builder(name20("separator"), {
    stores: orientation,
    returned: ($orientation) => {
      return {
        role: "separator",
        "data-orientation": $orientation === "horizontal" ? "vertical" : "horizontal",
        "aria-orientation": $orientation === "horizontal" ? "vertical" : "horizontal"
      };
    }
  });
  const groupDefaults = {
    type: "single",
    disabled: false
  };
  const createToolbarGroup = (props2) => {
    const groupWithDefaults = { ...groupDefaults, ...props2 };
    const options2 = toWritableStores(groupWithDefaults);
    const { type, disabled } = options2;
    const defaultValue = groupWithDefaults.defaultValue ? groupWithDefaults.defaultValue : groupWithDefaults.type === "single" ? void 0 : [];
    const valueWritable = groupWithDefaults.value ?? writable(defaultValue);
    const value = overridable(valueWritable, groupWithDefaults == null ? void 0 : groupWithDefaults.onValueChange);
    const { name: name22 } = createElHelpers("toolbar-group");
    const group = builder(name22(), {
      stores: orientation,
      returned: ($orientation) => {
        return {
          role: "group",
          "data-orientation": $orientation
        };
      }
    });
    const item = builder(name22("item"), {
      stores: [disabled, type, value, orientation],
      returned: ([$disabled, $type, $value, $orientation]) => {
        return (props3) => {
          const itemValue = typeof props3 === "string" ? props3 : props3.value;
          const argDisabled = typeof props3 === "string" ? false : !!props3.disabled;
          const disabled2 = $disabled || argDisabled;
          const pressed = Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
          return {
            disabled: disabled2,
            pressed,
            "data-orientation": $orientation,
            "data-disabled": disabled2 ? true : void 0,
            "data-value": itemValue,
            "data-state": pressed ? "on" : "off",
            "aria-pressed": pressed,
            type: "button",
            role: $type === "single" ? "radio" : void 0,
            "data-melt-toolbar-item": ""
          };
        };
      },
      action: (node) => {
        function getNodeProps() {
          const itemValue = node.dataset.value;
          const disabled2 = node.dataset.disabled === "true";
          return { value: itemValue, disabled: disabled2 };
        }
        function handleValueUpdate() {
          const { value: itemValue, disabled: disabled2 } = getNodeProps();
          if (itemValue === void 0 || disabled2)
            return;
          value.update(($value) => {
            if (Array.isArray($value)) {
              if ($value.includes(itemValue)) {
                return $value.filter((i) => i !== itemValue);
              }
              $value.push(itemValue);
              return $value;
            }
            return $value === itemValue ? void 0 : itemValue;
          });
        }
        const parentToolbar = node.closest("[data-melt-toolbar]");
        if (!isHTMLElement(parentToolbar))
          return {};
        const items = getToolbarItems(parentToolbar);
        if (items[0] === node) {
          node.tabIndex = 0;
        } else {
          node.tabIndex = -1;
        }
        const unsub = executeCallbacks(addMeltEventListener(node, "click", () => {
          handleValueUpdate();
        }), addMeltEventListener(node, "keydown", (e) => {
          if (e.key === kbd.ENTER || e.key === kbd.SPACE) {
            e.preventDefault();
            handleValueUpdate();
            return;
          }
          handleKeyDown(e);
        }));
        return {
          destroy: unsub
        };
      }
    });
    const isPressed = derived(value, ($value) => {
      return (itemValue) => {
        return Array.isArray($value) ? $value.includes(itemValue) : $value === itemValue;
      };
    });
    return {
      elements: {
        group,
        item
      },
      states: {
        value
      },
      helpers: {
        isPressed
      },
      options: options2
    };
  };
  function getToolbarItems(element) {
    return Array.from(element.querySelectorAll(`${selector10("item")}, ${selector10("button")}`)).filter((el) => isHTMLElement(el));
  }
  function handleKeyDown(e) {
    const $orientation = get_store_value(orientation);
    const $loop = get_store_value(loop);
    const dir = "ltr";
    const nextKey = {
      horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
      vertical: kbd.ARROW_DOWN
    }[$orientation ?? "horizontal"];
    const prevKey = {
      horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
      vertical: kbd.ARROW_UP
    }[$orientation ?? "horizontal"];
    const el = e.currentTarget;
    if (!isHTMLElement(el))
      return;
    const root2 = el.closest("[data-melt-toolbar]");
    if (!isHTMLElement(root2))
      return;
    const items = Array.from(root2.querySelectorAll(`${selector10("item")}, ${selector10("button")}`)).filter((el2) => isHTMLElement(el2));
    const currentIndex = items.indexOf(el);
    if (e.key === nextKey) {
      e.preventDefault();
      const nextIndex = currentIndex + 1;
      if (nextIndex >= items.length && $loop) {
        handleRovingFocus(items[0]);
      } else {
        handleRovingFocus(items[nextIndex]);
      }
    } else if (e.key === prevKey) {
      e.preventDefault();
      const prevIndex = currentIndex - 1;
      if (prevIndex < 0 && $loop) {
        handleRovingFocus(items[items.length - 1]);
      } else {
        handleRovingFocus(items[prevIndex]);
      }
    } else if (e.key === kbd.HOME) {
      e.preventDefault();
      handleRovingFocus(items[0]);
    } else if (e.key === kbd.END) {
      e.preventDefault();
      handleRovingFocus(items[items.length - 1]);
    }
  }
  return {
    elements: {
      root,
      button,
      separator,
      link
    },
    builders: {
      createToolbarGroup
    },
    options
  };
};

// ../../node_modules/.pnpm/@melt-ui+svelte@0.43.0_svelte@4.1.2/node_modules/@melt-ui/svelte/dist/builders/tooltip/create.js
var defaults29 = {
  positioning: {
    placement: "bottom"
  },
  arrowSize: 8,
  defaultOpen: false,
  closeOnPointerDown: true,
  openDelay: 1e3,
  closeDelay: 0,
  forceVisible: false,
  portal: "body",
  closeOnEscape: true
};
var { name: name21 } = createElHelpers("tooltip");
function createTooltip(props) {
  const withDefaults = { ...defaults29, ...props };
  const options = toWritableStores(omit(withDefaults, "open"));
  const { positioning, arrowSize, closeOnPointerDown, openDelay, closeDelay, forceVisible, portal, closeOnEscape } = options;
  const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
  const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
  const activeTrigger = writable(null);
  const ids = {
    content: generateId(),
    trigger: generateId()
  };
  let clickedTrigger = false;
  onMount(() => {
    if (!isBrowser)
      return;
    activeTrigger.set(document.querySelector(`[aria-describedby="${ids.content}"]`));
  });
  let openTimeout = null;
  let closeTimeout = null;
  function openTooltip() {
    if (closeTimeout) {
      window.clearTimeout(closeTimeout);
      closeTimeout = null;
    }
    if (!openTimeout) {
      openTimeout = window.setTimeout(() => {
        open.set(true);
        openTimeout = null;
      }, get_store_value(openDelay));
    }
  }
  function closeTooltip(isBlur) {
    if (openTimeout) {
      window.clearTimeout(openTimeout);
      openTimeout = null;
    }
    if (isBlur && isMouseInTooltipArea)
      return;
    if (!closeTimeout) {
      closeTimeout = window.setTimeout(() => {
        open.set(false);
        if (isBlur)
          clickedTrigger = false;
        closeTimeout = null;
      }, get_store_value(closeDelay));
    }
  }
  const trigger = builder(name21("trigger"), {
    returned: () => {
      return {
        "aria-describedby": ids.content
      };
    },
    action: (node) => {
      const unsub = executeCallbacks(addMeltEventListener(node, "pointerdown", () => {
        const $closeOnPointerDown = get_store_value(closeOnPointerDown);
        if (!$closeOnPointerDown)
          return;
        open.set(false);
        clickedTrigger = true;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "pointerenter", (e) => {
        if (isTouch(e))
          return;
        openTooltip();
      }), addMeltEventListener(node, "pointerleave", (e) => {
        if (isTouch(e))
          return;
        if (openTimeout) {
          window.clearTimeout(openTimeout);
          openTimeout = null;
        }
      }), addMeltEventListener(node, "focus", () => {
        if (clickedTrigger)
          return;
        openTooltip();
      }), addMeltEventListener(node, "blur", () => closeTooltip(true)), addMeltEventListener(node, "keydown", (e) => {
        if (get_store_value(closeOnEscape) && e.key === kbd.ESCAPE) {
          if (openTimeout) {
            window.clearTimeout(openTimeout);
            openTimeout = null;
          }
          open.set(false);
        }
      }));
      return {
        destroy: unsub
      };
    }
  });
  const isVisible = derivedVisible({ open, activeTrigger, forceVisible });
  const content = builder(name21("content"), {
    stores: [isVisible, portal],
    returned: ([$isVisible, $portal]) => {
      return {
        role: "tooltip",
        hidden: $isVisible ? void 0 : true,
        tabindex: -1,
        style: styleToString({
          display: $isVisible ? void 0 : "none"
        }),
        id: ids.content,
        "data-portal": $portal ? "" : void 0
      };
    },
    action: (node) => {
      let unsubFloating = noop;
      let unsubPortal = noop;
      const unsubDerived = effect([isVisible, activeTrigger, positioning, portal], ([$isVisible, $activeTrigger, $positioning, $portal]) => {
        if (!$isVisible || !$activeTrigger) {
          unsubPortal();
          unsubFloating();
          return;
        }
        tick().then(() => {
          const floatingReturn = useFloating($activeTrigger, node, $positioning);
          unsubFloating = floatingReturn.destroy;
          if (!$portal) {
            unsubPortal();
            return;
          }
          const portalDest = getPortalDestination(node, $portal);
          if (portalDest) {
            const portalReturn = usePortal(node, portalDest);
            if (portalReturn && portalReturn.destroy) {
              unsubPortal = portalReturn.destroy;
            }
          }
        });
      });
      const unsubEvents = executeCallbacks(addMeltEventListener(node, "pointerenter", openTooltip), addMeltEventListener(node, "pointerdown", openTooltip));
      return {
        destroy() {
          unsubEvents();
          unsubPortal();
          unsubFloating();
          unsubDerived();
        }
      };
    }
  });
  const arrow2 = builder(name21("arrow"), {
    stores: arrowSize,
    returned: ($arrowSize) => ({
      "data-arrow": true,
      style: styleToString({
        position: "absolute",
        width: `var(--arrow-size, ${$arrowSize}px)`,
        height: `var(--arrow-size, ${$arrowSize}px)`
      })
    })
  });
  let isMouseInTooltipArea = false;
  effect([isVisible, activeTrigger], ([$isVisible, $activeTrigger]) => {
    if (!$isVisible || !$activeTrigger)
      return;
    return executeCallbacks(addEventListener(document, "mousemove", (e) => {
      const contentEl = document.getElementById(ids.content);
      if (!contentEl)
        return;
      const polygon = makeHullFromElements([$activeTrigger, contentEl]);
      isMouseInTooltipArea = pointInPolygon({
        x: e.clientX,
        y: e.clientY
      }, polygon);
      if (isMouseInTooltipArea || document.activeElement === $activeTrigger && !clickedTrigger) {
        openTooltip();
      } else {
        closeTooltip();
      }
    }));
  });
  return {
    elements: {
      trigger,
      content,
      arrow: arrow2
    },
    states: { open },
    options
  };
}
export {
  INTERACTION_KEYS,
  createAccordion,
  createAvatar,
  createCheckbox,
  createCollapsible,
  createCombobox,
  createContextMenu,
  createDialog,
  createDropdownMenu,
  createLabel,
  createLinkPreview,
  createMenubar,
  createPagination,
  createPinInput,
  createPopover,
  createProgress,
  createRadioGroup,
  createSelect,
  createSeparator,
  createSlider,
  createSwitch,
  createTableOfContents,
  createTabs,
  createTagsInput,
  createToaster,
  createToggle,
  createToggleGroup,
  createToolbar,
  createTooltip,
  melt
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@melt-ui_svelte.js.map
